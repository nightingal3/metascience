2014,Cost-Aware Automatic Program Repair.,"Abstract
We present a formal framework for repairing infinite-state, imperative, sequential programs, with (possibly recursive) procedures and multiple assertions; the framework can generate repaired programs by modifying the original erroneous program in multiple program locations, and can ensure the readability of the repaired program using user-defined expression templates; the framework also generates a set of inductive assertions that serve as a proof of correctness of the repaired program. As a step toward integrating programmer intent and intuition in automated program repair, we present a cost-aware formulation - given a cost function associated with permissible statement modifications, the goal is to ensure that the total program modification cost does not exceed a given repair budget. As part of our predicate abstractionbased solution framework, we present a sound and complete algorithm for repair of Boolean programs. We have developed a prototype tool based on SMT solving and used it successfully to repair diverse errors in benchmark C programs."
2012,"Systems Architecture, Design, Engineering, and Verification - The Practice in Research and Research in Practice.","More than any other area in computer science, the interaction and boundary between science and engineering is blurred in the systems area, with cross fertilization from both directions. The systems panel will explore the past, present and future relationship between systems research and engineering practice.
They will discuss the relationship between systems research and engineering practices: when does systems innovation emanating from industry become an invention and when does academic research stop being science and become engineering? How does practice-driven research impact the real world and how does the real world reflect back on foundations? In what forms does technology create research challenges, and in what manner does applied research give solid base for development?
They will surmise about the future of systems research: What are the fundamental challenges posed by the scale of today's cloud computing systems and mega-size data centers? How to organize software of large-scale distributed executions or mega-ton lines of code? What new opportunities are enabled by novel technologies like flash memory and transactional memory? How to integrate hand-in-hand design of software and architecture?"
2012,Improved Binary Decision Diagram Constraint Propagation for Satisfiability Problems.,"Abstract:
In general, search-based solvers have been dominating symbolic solvers according to experimental results reported in the SAT and QBF literature. However, some recent efforts have contributed to close that performance gap. One novel approach involves the use of Binary Decision Diagrams(BDDs) and a simplification routine called BDD constraint propagation. The main idea is to adapt optimizations from search-based solvers in the context of BDDs. In this paper we improve upon the existing BDD constraint propagation procedure. Concretely, for a BDD A and its support set SupportSet(A), we reduce the asymptotic upper bound for the clause BDD pure literal extraction from O(A * SupportSet(A)) to O(n) time and nonclause BDD unit literal extraction from O(A * SupportSet(A)) to O(A) time. We also formulate for the first time the Trivial Falsity, Forced Literal and Universal Reduction rules for BDDs. We show in the experimental section that these improvements allow a BDD-based solver to tackle new families of problems, and outperform state-of-the art solvers in some cases."
2011,Symbolic modular deadlock analysis.,"Methods in object-oriented concurrent libraries often encapsulate internal synchronization details. As a result of information hiding, clients calling the library methods may cause thread safety violations by invoking methods in an unsafe manner. This is frequently a cause of deadlocks. Given a concurrent library, we present a technique for inferring interface contracts that specify permissible concurrent method calls and patterns of aliasing among method arguments. In this work, we focus on deriving contracts that guarantee deadlock-free execution for the methods in the library. The contracts also help client developers by documenting required assumptions about the library methods. Alternatively, the contracts can be statically enforced in the client code to detect potential deadlocks in the client. Our technique combines static analysis with a symbolic encoding scheme for tracking lock dependencies, allowing us to synthesize contracts using a SMT solver. Additionally, we investigate extensions of our technique to reason about deadlocks in libraries that employ signaling primitives such as wait-notify for cooperative synchronization. Our prototype tool analyzes over a million lines of code for some widely-used Java libraries within an hour, thus demonstrating its scalability and efficiency. Furthermore, the contracts inferred by our approach have been able to pinpoint real deadlocks in clients, i.e. deadlocks that have been a part of bug-reports filed by users and developers of client code.
"
2011,An Algorithmic Framework for Synthesis of Concurrent Programs.,"Abstract
We present a framework that takes unsynchronized sequential processes along with a temporal specification of their global concurrent behaviour, and automatically generates a concurrent program with synchronization code ensuring correct global behaviour. The synthesized synchronization code is based on monitors with wait and notify operations on condition variables, and mutual-exclusion locks. Novel aspects of our framework include realistic low-level synchronization implementations, synthesis of both simple coarse-grained synchronization and more complex fine-grained synchronization, and accommodation of both safety and liveness in global correctness properties. The method is fully automatic as well as sound and complete."
2011,A More Efficient BDD-Based QBF Solver.,"Abstract
In this paper we present a QBF solver that is based on BDD technologies but includes optimizations from search-based algorithms. We enhance the early quantification technique from model checking, favoring aggressive quantification over conjunction of BDDs. BDD Constraint propagation is also described, a strategy inspired by the efficient simplifications applied to CNFs in DPLL-based algorithms . Some dynamic variable elimination heuristics that enforce quantification and bounded space usage are also presented, coping with the difficulties faced by static heuristics included in previous BDD-based solvers. Experimental results show that our solver outperforms both symbolic and search-based competitive solvers in formal verification benchmarks with practical applications in equivalence checking and theorem proving, by completing more problems or finishing in less time. Some preliminary results also show that the solver is able to handle some other hard problems for symbolic solvers in the planning domain with similar efficiency. The benchmarks we used contain QBFs of nearly up to 9000 variables and are available at the QBFLIB website."
2010,Meanings of Model Checking.,"Abstract
Model checking was introduced in the early 1980’s to provide a practical automated method for verifying concurrent systems. Model checking has had substantive impact on program verification. For the first time industrial strength systems are being verified on a routine basis. As time has progressed, the term model checking has acquired slightly different shades of meaning. In this paper we these consider variant aspects of model checking, elucidating some often overlooked and subtle distinctions."
2010,Time of Time.,"Abstract
In his landmark 1977 paper “The Temporal Logic of Programs”, Amir Pnueli gave a fundamental recognition that the ideally nonterminating behavior of ongoing concurrent programs, such as operating systems and protocols, was a vital aspect of program reasoning. As classical approaches to program correctness were based on initial-state/final-state semantics for terminating programs, these approaches were inapplicable to programs where infinite behavior was the norm. To address this shortcoming, Pnueli suggested the use of temporal logic, a formalism for reasoning about change over time originally studied by philosophers, to meaningfully describe and reason about the infinite behavior of programs. This suggestion turned out to be remarkably fruitful. It struck a resonant chord within the formal verification community, and it has had an enormous impact on the development of the area. It matured into an extremely effective mathematical tool for specifying and verifying a vast class of synchronization and coordination problems common in concurrency. Pnueli thus caused a sea-change in the field of program verification, founding the time of reasoning about time, which has been the most successful period in formal methods yet."
2009,Verification of recursive methods on tree-like data structures.,"Abstract:
Programs that manipulate heap-allocated data structures present a formidable challenge for algorithmic verification. Recursive procedures (methods) in such software libraries are used for a large number of tasks ranging from simple traversals to complex structural transformations. Verification of such methods is undecidable in general. Hence, we present a programming language fragment with a syntax similar to that of C for which correctness can be algorithmically checked. For methods written in our fragment, and specifications in the form of tree automata, verification is efficient in most cases, as illustrated by our prototype tool. Our framework can be used to verify methods such as insertion and deletion of nodes in k-ary trees, binary search trees, linked lists, linked list reversal, and rotations in balanced trees, with respect to specifications such as acyclicity, sortedness, list-ness, tree-ness, and absence of null pointer dereferences."
2009,Symbolic Deadlock Analysis in Concurrent Libraries and Their Clients.,"Abstract:
Methods in object-oriented concurrent libraries hide internal synchronization details. However, information hiding may result in clients causing thread safety violations by invoking methods in an unsafe manner. Given such a library, we present a technique for inferring interface contracts that specify permissible concurrent method calls and patterns of aliasing among method arguments, such that the derived contracts guarantee deadlock free execution for the methods in the library. The contracts also help client developers by documenting required assumptions about the library methods. Alternatively, the contracts can be statically enforced in the client code to detect potential deadlocks in the client. Our technique combines static analysis with a symbolic encoding for tracking lock dependencies, allowing us to synthesize contracts using a SMT solver. Our prototype tool analyzes over a million lines of code for some widely-used Java libraries within an hour, thus demonstrating its scalability and efficiency. Furthermore, the contracts inferred by our approach have been able to pinpoint real deadlocks in clients, i.e. deadlocks that have been a part of bug-reports filed by users and developers of the client code."
2009,Model Checking: Progress and Problems.,"Abstract
Model checking is an automatic method of verifying finite state concurrent programs. The use of temporal logic and related frameworks to specify correctness has greatly facilitated simply thinking about the verification problem. Despite early worries about the intractability of state explosion, nowadays it can often be ameliorated, permitting verification of enormously large systems in practice. Important techniques include abstraction and compact (symbolic) representation.
Unfortunately, none of these techniques scale well beyond a certain range. Nor is temporal logic universally viewed as a natural specification framework. We will discuss some possible ways to enhance efficiency and expressiveness of model checking."
2008,Automatic Generation of Local Repairs for Boolean Programs.,"Abstract:
Automatic techniques for software verification focus on obtaining witnesses of program failure. Such counterexamples often fail to localize the precise cause of an error and usually do not suggest a repair strategy. We present an efficient algorithm to automatically generate a repair for an incorrect sequential Boolean program where program correctness is specified using a pre-condition and a post-condition. Our approach draws on standard techniques from predicate calculus to obtain annotations for the program statements. These annotations are then used to generate a synthesis query for each program statement, which if successful, yields a repair. Furthermore, we show that if a repair exists for a given program under specified conditions, our technique is always able to find it."
2008,The Beginning of Model Checking: A Personal Perspective.,"Abstract
Model checking provides an automated method for verifying concurrent systems. Correctness specifications are given in temporal logic. The method hinges on an efficient and flexible graph-theoretic reachability algorithm. At the time of its introduction in the early 1980’s, the prevailing paradigm for verification was a manual one of proof-theoretic reasoning using formal axioms and inference rules oriented towards sequential programs. The need to encompass concurrent programs, the desire to avoid the difficulties with manual deductive proofs, and the small model theorem for temporal logic motivated the development of model checking."
2008,Design and Synthesis of Synchronization Skeletons Using Branching Time Temporal Logic.,"Abstract
We Propose a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a high-level (branching time) Temporal Logic specification. The synchronization skeleton is an abstraction of the actual program where detail irrelevant to synchronization is suppressed. For example, in the synchronization skeleton for a solution to the critical section problem each process’s critical section may be viewed as a single node since the internal structure of the critical section is unimportant. Most solutions to synchronization problems in the literature are in fact given as synchronization skeletons. Because synchronization skeletons are in general finite state, the propositional version of Temporal Logic can be used to specify their properties."
2008,SVISS: Symbolic Verification of Symmetric Systems.,"Abstract
Sviss is a flexible platform for incorporating efficient symmetry reduction into symbolic model checking. The tool comes with an extensive C++ library for system modeling using BDDs and a rich CTL-based model checking engine. Applications range from communication protocols to computer hardware and multi-threaded software. We believe Sviss to be the first symbolic tool to exploit symmetry in concurrent device-driver verification, which is vital in operating system design."
2007,Improved verification of hardware designs through antecedent conditioned slicing.,"Static slicing has shown itself to be a valuable tool, facilitating the verification of hardware designs. In this paper, we present a sharpened notion, antecedent conditioned slicing that provides a more effective abstraction for reducing the size of the state space. In antecedent conditioned slicing, extra information from the antecedent is used to permit greater pruning of the state space. In a previous version of this paper, we applied antecedent conditioned slicing to safety properties of the form G(antecedent ? consequent) where antecedent and consequent were written in propositional logic. In this paper, we use antecedent conditioned slicing to handle safety and bounded liveness property specifications written in linear time temporal logic. We present a theoretical justification of our technique. We provide experimental results on a Verilog RTL implementation of the USB 2.0 functional core, which is a large design with about 1,100 state elements (10331 states). The results demonstrate that the technique provides significant performance benefits over static program slicing using state-of-the-art model checkers.
"
2006,Under-approximation Heuristics for Grid-based Bounded Model Checking.,"Abstract
In this paper, we consider the effect of BDD-based under-approximation on a hybrid approach using BDDs and SAT-BMC for error detection on a computing grid. We experimentally study effect of under-approximation approaches on a non-traditional parallelization of BMC based on state space partitioning. This parallelization is accomplished by executing multiple instances of BMC independently from different seed states, that are selected from the reachable states in different partitions. Such states are spread out across the state space and can potentially be deep. Since all processors work independently of each other, this scheme is suitable for bug hunting using a grid-like network. Our experimental results demonstrate improvement over existing approaches, and we show that the method can effectively utilize a large grid network."
2006,Molecular Model Checking.,"This paper shows how to perform model checking, a technique for automatic program verification, by a DNA algorithm. Our method depends on two ideas. First, Kripke structures can be compactly represented in a DNA substrate, coding each state and each edge by a strand of DNA. Second, satisfaction of temporal eventualities can be achieved through a self-propagating molecular chain reaction.
"
2006,On partitioning and symbolic model checking.,"Abstract:
State-space-partitioning-based approaches have been proposed in the literature to address the state-explosion problem in model checking. These approaches, whether sequential or distributed, perform a large amount of work in the form of interpartition (crossover) image computations, which can be expensive. A model-checking algorithm that aggregates these expensive crossover images by localizing computation to individual partitions is presented. It reduces the number of crossover images and drastically outperforms extant approaches in terms of crossover image computation cost as well as total model-checking time, often by two orders of magnitude."
2006,Reducing Model Checking of the Few to the One.,"Abstract
Verification of parameterized systems for an arbitrary number of instances is generally undecidable. Existing approaches resort to non-trivial restrictions on the system or lack automation. In practice, applications can often provide a suitable bound on the parameter size. We propose a new technique toward the bounded formulation of parameterized reasoning: how to efficiently verify properties of a family of systems over a large finite parameter range. We show how to accomplish this with a single verification run on a model that aggregates the individual instances. Such a run takes significantly less time than if the systems were considered one by one. Our method is applicable to a completely inhomogeneous family of systems, where properties may not even be preserved across instances. In this case the method exposes the parameter values for which the verification fails. If symmetry is present in the systems, it is inherited by the aggregate representation, allowing for verification over a reduced model. Our technique is fully automatic and requires no approximation."
2006,Automatic Verification of Parameterized Data Structures.,"Abstract
Verifying correctness of programs operating on data structures has become an integral part of software verification. A method is a program that acts on an input data structure (modeled as a graph) and produces an output data structure. The parameterized correctness problem for such methods can be defined as follows: Given a method and a property of the input graphs, we wish to verify that for all input graphs, parameterized by their size, the output graphs also satisfy the property. We present an automated approach to verify that a given method preserves a given property for a large class of methods. Examples include reversals of linked lists, insertion, deletion and iterative modification of nodes in directed graphs. Our approach draws on machinery from automata theory and temporal logic. For a useful class of data structures and properties, our solution is polynomial in the size of the method and size of the property specification."
2005,Efficient Model Checking of Hardware Using Conditioned Slicing.,"Abstract
In this work, we present an abstraction based property verification technique for hardware using conditioned slicing. We handle safety property specifications of the form
. We use the antecedent of the properties to create our abstractions, Antecedent Conditioned Slices. We extend conditioned slicing to Hardware Description Languages (HDLs). We provide a theoretical foundation for our conditioned slicing based verification technique. We also present experimental results on the Verilog RTL implementation of the USB 2.0. We demonstrate very high performance gains achieved by our technique when compared to static program slicing, using state-of-the-art model checkers."
2005,Efficient Reduction Techniques for Systems with Many Components.,"Abstract
We present an improved approach to verifying systems involving many copies of a few kinds of components. Replication of this type occurs frequently in practice and is regarded a major source of state explosion during temporal logic model checking. Our solution makes use of symmetry reduction through counter abstraction. The efficiency of this approach directly depends on the size of the components' local state space, which is exponential in the number of local variables. We show how program analysis can significantly reduce the local state space and can help towards a succinct BDD representation of the system. Our reduction techniques synergistically combine into efficient symbolic verification, as documented by promising experimental results."
2005,Predictive Reachability Using a Sample-Based Approach.,"Abstract
BDD based reachability methods suffer from lack of robustness in performance, whereby it is difficult to estimate which one should be adopted for a given problem. We present a novel approach that examines a few short samples of the computation leading to an automatic, robust and modular way of reconciling the various methods for reachability. Our approach is able to intelligently integrate diverse reachability techniques such that each method can possibly get enhanced in efficiency. The method is in many cases orders of magnitude more efficient and it finishes all the invariant checking properties in VIS-Verilog benchmarks."
2005,Multi-threaded reachability.,Partitioned BDD-based algorithms have been proposed in the literature to solve the memory explosion problem in BDD-based verification. Such algorithms can be at times ineffective as they suffer from the problem of scheduling the relative order in which the partitions are processed. In this paper we present a novel multi-threaded reachability algorithm that avoids this scheduling problem while increasing the latent parallelism in partitioned state space traversal. We show that in most cases our method is significantly faster than both the standard reachability algorithm as well as the existing partitioned approaches. The gains are further magnified when our threaded implementation is evaluated in the context of a parallel framework.
2005,On Partitioning and Symbolic Model Checking.,"Abstract
State space partitioning-based approaches have been proposed in the literature to address the state-space explosion problem in model checking. These approaches, whether sequential or distributed, perform a large amount of work in the form of inter-partition (cross-over) image computations, which can be expensive. We present a model checking algorithm that aggregates these expensive cross-over images by localizing computation to individual partitions. It reduces the number of cross-over images and drastically outperforms extant approaches in terms of cross-over image computation cost as well as total model checking time, often by two orders of magnitude."
2005,Dynamic Symmetry Reduction.,"Abstract
Symmetry reduction is a technique to combat the state explosion problem in temporal logic model checking. Its use with symbolic representation has suffered from the prohibitively large BDD for the orbit relation. One suggested solution is to pre-compute a mapping from states to possibly multiple representatives of symmetry equivalence classes. In this paper, we propose a more efficient method that determines representatives dynamically during fixpoint iterations. Our scheme preserves the uniqueness of representatives. Another alternative to using the orbit relation is counter abstraction. It proved efficient for the special case of full symmetry, provided a conducive program structure. In contrast, our solution applies also to systems with less than full symmetry, and to systems where a translation into counters is not feasible. We support these claims with experimental results."
2004,Synthesis of fault-tolerant concurrent programs.,"Methods for mechanically synthesizing concurrent programs from temporal logic specifications obviate the need to manually construct a program and compose a proof of its correctness. A serious drawback of extant synthesis methods, however, is that they produce concurrent programs for models of computation that are often unrealistic. In particular, these methods assume completely fault-free operation, that is, the programs they produce are fault-intolerant. In this paper, we show how to mechanically synthesize fault-tolerant concurrent programs for various fault classes. We illustrate our method by synthesizing fault-tolerant solutions to the mutual exclusion and barrier synchronization problems."
2004,Parameterized Model Checking of Ring-Based Message Passing Systems.,"Abstract
The Parameterized Model Checking Problem (PMCP) is to decide whether a temporal property holds for a uniform family of systems, U n , comprised of finite, but arbitrarily many, copies of a template process U. Unfortunately, it is undecidable in general [3]. In this paper, we consider the PMCP for systems comprised of processes arranged in a ring that communicate by passing messages via tokens whose values can be updated at most a bounded number of times. Correctness properties are expressed using the stuttering-insensitive linear time logic LTL∖X. For bidirectional rings we show how to reduce reasoning about rings with an arbitrary number of processes to rings with up to a certain finite cutoff number of processes. This immediately yields decidability of the PMCP at hand. We go on to show that for unidirectional rings small cutoffs can be achieved, making the decision procedure provably efficient. As example applications, we consider protocols for the leader election problem."
2004,A Partitioning Methodology for BDD-Based Verification.,"Abstract
The main challenge in BDD-based verification is dealing with the memory explosion problem during reachability analysis. In this paper we advocate a methodology to handle this problem based on state space partitioning of functions as well as relations. We investigate the key questions of how to perform partitioning in reachability based verification and provide suitable algorithms. We also address the problem of instability of BDD-based verification by automatically picking the best configuration from different short traces of the reachability computation. Our approach drastically decreases verification time, often by orders of magnitude."
2003,On Reasoning About Rings.,"Distributed protocols are often composed of similar processes connected in a unidirectional ring network. Processes communicate by passing a token in a fixed direction; the process that holds the token is allowed to perform certain actions. Usually, correctness properties are expected to hold irrespective of the size of the ring. We show that the question of checking many useful correctness properties for rings of all sizes can be reduced to checking them on ring of sizes up to a small cutoff size. We apply our results to the verification of a mutual exclusion protocol and Milner's scheduler protocol.
"
2003,On Combining Symmetry Reduction and Symbolic Representation for Efficient Model Checking.,"Abstract
BDDs allow succinct symbolic representation of digital circuits. Symmetry reduction factors out redundancy inherent in the regular organization of many systems. Both are successful techniques for combating state space explosion. It would be desirable to combine them into symbolic symmetry reduction. Unfortunately, the straight-forward approach to symmetry reduction requires the orbit relation, whose symbolic representation as a BDD is in general of exponential size. We investigate the use of generic representatives as a means of overcoming this problem for fully symmetric systems: instead of first representing the system as a BDD and then applying symmetry reduction, we translate the given program text into a symmetry-reduced version. The result can then be encoded using a BDD. We demonstrate that this method is superior not only to the traditional orbit-relation based symmetry reduction, but also to the approach using multiple representatives."
2003,Exact and Efficient Verification of Parameterized Cache Coherence Protocols.,"Abstract
We propose new, tractably (in some cases provably) efficient algorithmic methods for exact (sound and complete) parameterized reasoning about cache coherence protocols. For reasoning about general snoopy cache protocols, we introduce the guarded broadcast protocols model and show how an abstract history graph construction can be used to reason about safety properties for this framework. Although the worst case size of the abstract history graph can be exponential in the size of the transition diagram of the given protocol, the actual size is small for standard cache protocols as is evidenced by our experimental results. The framework can handle all 8 of the cache protocols in [19] as well as their split-transaction versions. We next identify a framework called initialized broadcast protocols suitable for reasoning about invalidation-based snoopy cache protocols and show how to reduce reasoning about such systems with an arbitrary number of caches to a system with at most 7 caches. This yields a provably polynomial time algorithm for the parameterized verification of invalidation based snoopy protocols. Our results apply to both safety and liveness properties. Finally, we present a methodology for reducing parameterized reasoning about directory based protocols to snoopy protocols, thus leveraging techniques developed for verifying snoopy protocols to directory based ones, which are typically are much harder to reason about. We demonstrate by reducing reasoning about a directory based protocol suggested by German [17] to the ESI snoopy protocol, a modification of the MSI snoopy protocol."
2003,Abstract Patterns of Compositional Reasoning.,"Abstract
Compositional Reasoning – reducing reasoning about a concurrent system to reasoning about its individual components – is an essential tool for managing proof complexity and state explosion in model checking. Typically, such reasoning is carried out in an assume-guarantee manner: each component guarantees its behavior based on assumptions about the behavior of other components. Restrictions imposed on such methods to avoid unsoundness usually also result in incompleteness – i.e., one is unable to prove certain properties. In this paper, we construct an abstract framework for reasoning about process composition, formulate an assume-guarantee method, and show that it is sound and semantically complete. We then show how to instantiate the framework for several common notions of process behavior and composition. For these notions, the instantiations result in the first methods known to be complete for mutually inductive, assume-guarantee reasoning."
2003,Model Checking Guarded Protocols.,"Abstract:
The parameterized model checking problem (PMCP) is to decide whether a temporal property holds for a uniform family of systems, C||U/sup n/, comprised of a control process, C, and finitely, but arbitrarily, many copies of a user process, U, executing concurrently with interleaving semantics. We delineate the decidability/undecidability boundary of the PMCP for all possible systems that arise by letting processes coordinate using different subsets of the following communication primitives: conjunctive Boolean guards, disjunctive Boolean guards, pairwise rendezvous, asynchronous rendezvous and broadcast actions. Our focus is on the following linear time properties: (p1) LTL/spl bsol/X formulae over C; (p2) LTL formulae over C; (p3) regular properties specified as regular automata; and (p4) /spl omega/-regular automata. We also establish a hierarchy based on the relative expressive power of the primitives by showing that disjunctive guards and pairwise rendezvous are equally expressive, in that we can reduce the PMCP for regular and /spl omega/-regular properties for systems with disjunctive guards and pairwise rendezvous are equally expressive, in that we can reduce the PMCP for regular and /spl omega/-regular properties for systems with disjunctive guards to ones with pairwise rendezvous and vise versa, but that each of asynchronous rendezvous and broadcasts is strictly more expressive than pairwise rendezvous (and disjunctive guards). Moreover, for systems with conjunctive guards, we give a simple characterization of the decidability/undecidability boundary of the PMCP by showing that allowing stuttering sensitive properties bridges the gap between decidability (for p1) and undecidability (for p2). A broad framework for modeling snoopy cache protocols is also presented for which the PMCP for p3 is decidable and that can model all snoopy cache protocols given by Culler and Emerson (1988) thereby overcoming the undecidability results."
2003,Rapid Parameterized Model Checking of Snoopy Cache Coherence Protocols.,"Abstract
A new method is proposed for parameterized reasoning about snoopy cache coherence protocols. The method is distinctive for being exact (sound and complete), fully automatic (algorithmic), and tractably efficient. The states of most cache coherence protocols can be organized into a hierarchy reflecting how tightly a memory block in a given cache state is bound to the processor. A broad framework encompassing snoopy cache coherence protocols is proposed where the hierarchy implicit in the design of protocols is captured as a pre-order. This yields a new solution technique that hinges on the construction of an abstract history graph where a global concrete state is represented by an abstract state reflecting the occupied local states. The abstract graph also takes into account the history of local transitions of the protocol that were fired along the computation to get to the global state. This permits the abstract history graph to exactly capture the behaviour of systems with an arbitrary number of homogeneous processes. Although the worst case size of the abstract history graph can be exponential in the size of the transition diagram describing the protocol, the actual size of the abstract history graph is small for standard cache protocols. The method is applicable to all 8 of the most common snoopy cache protocols described in Handy’s book [19] from Illinois-MESI to Dragon. The experimental results for parameterized verification of each of those 8 protocols document the efficiency of this new method in practice, with each protocol being verified in just a fraction of a second. It is emphasized that this is parameterized verification."
2002,Visual Specifications for Modular Reasoning about Asynchronous Systems.,"Abstract
We propose a framework that closely ties together visual specification and modular reasoning of asynchronous systems. The basis of the framework is a new notation, called Modular Timing Diagrams (MTD’s), for specifying the universal properties about causality and timing of events in an asynchronous system. MTD’s are complementary in nature to Message Sequence Charts, that are typically used to specify existential properties. Our framework includes two algorithms for formal reasoning withMTD’s. The first is an efficient polynomial-time model checking algorithm. The second is an algorithm for automatically generating an assume-guarantee partitioning of an MTD, that exploits its inherent decompositional structure. We show how to use this decomposition for modular reasoning withMTD properties in conjunction with an asynchronous compositional reasoning rule. To illustrate the notation and our method, we describe a case study where we specified telephony features, suchas call forwarding withMTD’s, and verified these properties on an asynchronous telephony model. The compositional reasoning methods led to savings of 15%-80% in verification times, and comparable savings in space."
2002,Model Checking Large-Scale and Parameterized Resource Allocation Systems.,"Abstract
In this paper, techniques are proposed for limiting state explosion in the context of resource allocation problems. It is shown that given any system organized into a—possibly irregular—network of n—possibly heterogeneous — processes, model checking over that system can be reduced by an efficient, fully automatic and exact method to model checking over a certain small system. These results are established for correctness properties expressed in LTLX. The precise size and topology of the small system are dependent on the large system, as well as the correctness specification. When the network is symmetric and the processes homogeneous, this new method provides an efficient solution to the Parameterized Model Checking Problem. As an application, it is shown how to efficiently verify a variety of solutions to the parameterized Dining Philosophers Problem."
2001,On model checking for the µ-calculus and its fragments.,"Abstract
In this paper, we consider the model checking problem for the μ-calculus and show that it is succinctly equivalent to the non-emptiness problem of finite-state automata on infinite binary trees with the parity acceptance condition. We also present efficient model checking algorithms for two rich subclasses of the μ-calculus formulas and relate their expressive power to well-known extensions of branching time temporal logics."
2001,Synthesis of concurrent programs for an atomic read/write model of computation.,"Methods for mechanically synthesizing concurrent programs for temporal logic specifications have been proposed by Emerson and Clarke and by Manna and Wolper. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. A serious drawback of these methods in practice, however, is that they produce concurrent programs for models of computation that are often unrealistic, involving highly centralized system architecture (Manna and Wolper), processes with global information about the system state (Emerson and Clarke), or reactive modules that can read all of their inputs in one atomic step (Anuchitanukul and Manna, and Pnueli and Rosner). Even simple synchronization protocols based on atomic read/write primitives such as Peterson's solution to the mutual exclusion problem have remained outside the scope of practical mechanical synthesis methods. In this paper, we show how to mechanically synthesize in more realistic computational models solutions to synchronization problems. We illustrate the method by synthesizing Peterson's solution to the mutual exclusion problem."
2001,Rtdt: A Front-End for Efficient Model Checking of Synchronous Timing Diagrams.,"Abstract
Model checking 6 13 is an automated procedure for determining whether a finite state program satisfies a temporal property.Model checking tools, due to the complex nature of the specification methods, are used most effectively by verification experts. In order to make these tools more accessible to non-expert users, who may not be familiar with these formal notations, we need to make model checkers easier to use. Visually intuitive specification methods may provide an alternative way to specify temporal behavior."
2001,Assume-Guarantee Based Compositional Reasoning for Synchronous Timing Diagrams.,"Abstract
The explosion in the number of states due to several interacting components limits the application of model checking in practice. Compositional reasoning ameliorates this problem by reducing reasoning about the entire system to reasoning about individual components. Such reasoning is often carried out in the assume-guarantee paradigm: each component guarantees certain properties based on assumptions about the other components. Naïve applications of this reasoning can be circular and, therefore, unsound. We present a new rule for assume-guarantee reasoning, which is sound and complete. We show how to apply it, in a fully automated manner, to properties specified as synchronous timing diagrams. We show that timing diagram properties have a natural decomposition into assume-guarantee pairs, and liveness restrictions that result in simple subgoals which can be checked efficiently. We have implemented our method in a timing diagram analysis tool, which carries out the compositional proof in a fully automated manner. Initial applications of this method have yielded promising results, showing substantial reductions in the space requirements for model checking."
2000,Automated formal methods: model checking and beyond.,n/a
2000,SMC: a symmetry-based model checker for verification of safety and liveness properties.,"The article presents the SMC system. SMC can be used for checking safety and liveness properties of concurrent programs under different fairness assumptions. It is based on explicit state enumeration. It combats the state explosion by exploiting symmetries of the input concurrent program, usually present in the form of identical processes, in two different ways. Firstly, it reduces the number of explored states by identifying those states that are equivalent under the symmetries of the system; this is called process symmetry. Secondly, it reduces the number of edges explored from each state, in0 the reduced state graph, by exploiting the symmetry of a single state; this is called state symmetry. SMC works in an on-the-fly manner; it constructs the reduced state graph as and when it is needed. This method facilitates early termination, speeds up model checking, and reduces memory requirements. We employed SMC to check the correctness of, among other standard examples, the Link Layer part of the IEEE Standard 1394 “Firewire” high-speed serial bus protocol. SMC found deadlocks in the protocol. SMC was also to check certain liveness properties. A report on the case study is included in the article."
2000,Reducing Model Checking of the Many to the Few.,"Abstract
The Parameterized Model Checking Problem (PMCP) is to determine whether a temporal property is true for every size instance of a system comprised of many homogenous processes. Unfortunately, it is undecidable in general. We are able to establish, nonetheless, decidability of the PMCP in quite a broad framework. We consider asynchronous systems comprised of an arbitrary number of homogeneous copies of a generic process template. The process template is represented as a synchronization skeleton while correctness properties are expressed using Indexed CTL*∖ X. We reduce model checking for systems of arbitrary size n to model checking for systems of size up to (of) a small cutoff size c. This establishes decidability of PMCP as it is only necessary to model check a finite number of relatively small systems. Efficient decidability can be obtained in some cases. The results generalize to systems comprised of multiple heterogeneous classes of processes, where each class is instantiated by many homogenous copies of the class template (e.g., m readers and n writers)."
2000,Model Checking Synchronous Timing Diagrams.,"Abstract
Model checking is an automated approach to the formal verification of hardware and software. To allow model checking tools to be used by the hardware or software designers themselves, instead of by veri.cation experts, the tools should support speci.cation methods that correspond closely to the common usage. For hardware systems, timing diagrams form such a commonly used and visually appealing specification method. In this paper, we introduce a class of synchronous timing diagrams with a syntax and a formal semantics that is close to the informal usage. We present an e.cient, decompositional algorithm for model checking such timing diagrams. This algorithm has been implemented in a user-friendly tool called RTDT (the Regular Timing Diagram Translator). We have applied this tool to verify several properties of Lucent's PCI synthesizable core."
2000,Model Checking: Theory into Practice.,"Abstract
Model checking is an automatic method for verifying correctness of reactive programs. Originally proposed as part of the dissertation work of the author, model checking is based on efficient algorithms searching for the presence or absence of temporal patterns. In fact, model checking rests on a theoretical foundation of basic principles from modal logic, lattice theory, as well as automata theory that permits program reasoning to be completely automated in principle and highly automated in practice. Because of this automation, the practice of model checking is nowadays well-developed, and the range of successful applications is growing. Model checking is used by most major hardware manufacturers to verify microprocessor circuits, while there have been promising advances in its use in software verification as well. The key obstacle to applicability of model checking is, of course, the state explosion problem. This paper discusses part of our ongoing research program to limit state explosion. The relation of theory to practice is also discussed."
2000,Virtual Symmetry Reduction.,"Abstract:
We provide a general method for ameliorating state explosion via symmetry reduction in certain asymmetric systems, such as systems with many similar, but not identical, processes. The method applies to systems whose structures (i.e., state transition graphs) have more state symmetries than arc symmetries. We introduce a new notion of ""virtual symmetry"" that strictly subsumes earlier notions of ""rough symmetry"" and ""near symmetry"" (Emerson and Trefler, 1999). Virtual symmetry is the most general condition under which the structure of a system is naturally bisimilar to its quotient by a group of state symmetries. We give several example systems exhibiting virtual symmetry that are not amenable to symmetry reduction by earlier techniques: a one-lane bridge system, where the direction with priority for crossing changes dynamically; an abstract system with asymmetric communication network; and a system with asymmetric resource sharing motivated from the drinking philosophers problem. These examples show that virtual symmetry reduction applies to a significantly broader class of asymmetric systems than could be handled before."
1999,The Complexity of Tree Automata and Logics of Programs.,"The complexity of testing nonemptiness of finite state automata on infinite trees is investigated. It is shown that for tree automata with the pairs (or complemented pairs) acceptance condition having m states and n pairs, nonemptiness can be tested in deterministic time (mn)O(n) ; however, it is shown that the problem is in general NP-complete (or co-NP-complete, respectively). The new nonemptiness algorithm yields exponentially improved, essentially tight upper bounds for numerous important modal logics of programs, interpreted with the usual semantics over structures generated by binary relations. For example, it follows that satisfiability for the full branching time logic CTL* can be tested in deterministic double exponential time. Another consequence is that satisfiability for propositional dynamic logic (PDL) with a repetition construct (PDL-delta) and for the propositional Mu-calculus ($L\mu$) can be tested in deterministic single exponential time.
"
1999,Efficient Decompositional Model Checking for Regular Timing Diagrams.,"Abstract
Timing diagrams are widely used in industrial practice to express precedence and timing relationships amongst a collection of signals. This graphical notation is often more convenient than the use of temporal logic or automata. We introduce a class of timing diagrams called Regular Timing Diagrams (RTD’s). RTD’s have a precise syntax, and a formal semantics that is simple and corresponds to common usage. Moreover, RTD’s have an inherent compositional structure, which is exploited to construct an efficient algorithm for model checking a RTD with respect to a system description. The algorithm has time complexity that is linear in the system size and a small polynomial in the representation of the diagram. The algorithm can be easily used with symbolic (BDDbased) model checkers. We illustrate the workings of our algorithm with the verification of a simple master-slave system."
1999,From Asymmetry to Full Symmetry: New Techniques for Symmetry Reduction in Model Checking.,"Abstract
It is often the case that systems are “nearly symmetric”; they exhibit symmetry in a part of their description but are, nevertheless, globally asymmetric. We formalize several notions of near symmetry and show how to obtain the benefits of symmetry reduction when applied to asymmetric systems which are nearly symmetric. We show that for some nearly symmetric systems it is possible to perform symmetry reduction and obtain a bisimilar (up to permutation) symmetry reduced system.Using a more general notion of “sub-symmetry” we show how to generate a reduced structure that is simulated (up to permutation) by the original asymmetric program.
In the symbolic model checking paradigm, representing the symmetry reduced quotient structure entails representing the BDD for the orbit relation. Unfortunately, for many important symmetry groups, including the full symmetry group, this BDD is provably always intractably large, of size exponential in the number of bits in the state space. In contrast, under the assumption of full symmetry, we show that it is possible to reduce a textual program description of a symmetric system to a textual program description of the symmetry reduced system. This obviates the need for building the BDD representation of the orbit relation on the program states under the symmetry group. We establish that the BDD representing the reduced program is provably small, essentially polynomial in the number of bits in the state space of the original program."
1999,Parametric Quantitative Temporal Reasoning.,"Abstract:
We define Parameterized Real-Time Computation Tree Logic (PRTCTL), which allows quantitative temporal specifications to be parameterized over the natural numbers. Parameterized quantitative specifications are quantitative specifications in which concrete timing information has been abstracted away. Such abstraction allows designers to specify quantitative restrictions on the temporal ordering of events without having to use specific timing information from the model. A model checking algorithm for the logic is given which is polynomial for any fixed number of parameters. A subclass of formulae are identified for which the model checking problem is linear in the length of the formula and size of the structure. PRTCTL is generalised to allow quantitative reasoning about the number of occurrences of atomic events."
1998,Synthesis of Concurrent Systems with Many Similar Processes.,"Methods for synthesizing concurrent programs from temporal logic specifications based on the use of a decision procedure for testing temporal satisfiability have been proposed by Emerson and Clarke and by Manna and Wolper. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. One only has to formulate a precise problem specification; the synthesis method then mechanically constructs a correct solution. A serious drawback of these methods in practice, however, is that they suffer from the state explosion problem. To synthesize a concurrent system consisting of K sequential processes, each having N states in its local transition diagram, requires construction of the global product-machine having about NK global states in general. This exponential growth in K makes it infeasible to synthesize systems composed of more than 2 or 3 processes. In this article, we show how to synthesize concurrent systems consisting of many (i.e., a finite but arbitrarily large number K of) similar sequential processes. Our approach avoids construction of the global product-machine for K processes; instead, it constructs a two-process product-machine for a single pair of generic sequential processes. The method is uniform in K, providing a simple template that can be instantiated for each process to yield a solution for any fixed K. The method is also illustrated on synchronization problems from the literature."
1998,Symmetry Reductions inModel Checking.,"Abstract
The use of symmetry to alleviate state-explosion problems during model-checking has become a important research topic. This paper investigates several problems which are important to techniques exploiting symmetry. The most important of these problems is the orbit problem. We prove that the orbit problem is equivalent to an important problem in computational group theory which is at least as hard as the graph isomorphism but not known to be NP-complete. This paper also shows classes of commonly occurring groups for which the orbit problem is easy. Some methods of deriving symmetry for a shared variable model of concurrent programs are also investigated. Experimental results providing evidence of reduction in state space by using symmetry are also provided."
1998,Verification of Parameterized Bus Arbitration Protocol.,"Abstract
Model Checking is well established as a verification technique for finite-state systems. Many protocols, while composed of finite-state processes, are parameterized by the number of such processes, hence Model Checking cannot be applied directly to determine correctness of the inherently infinite-state parameterized system. We present a case study on the verification of such a parameterized protocol, the SAE-J1850 data transfer procotol. This is a standard in the automobile industry, where it is used to transmit data between various sensors and micro-controllers in an automobile. The protocol communicates data over a single-wire bus, and provides on-the-fly arbitration between competing transmissions. Our verification effort is interesting from many aspects : it proves correctness for arbitrary instances, is largely automated, and uses abstraction in an essential way. The abstractions used are exact, in the sense that a property is true of the parameterized protocol if and only if it is true of the finite-state abstraction."
1998,On Model Checking for Non-Deterministic Infinite-State Systems.,"Abstract:
We demonstrate that many known algorithms for model checking infinite-state systems can be derived uniformly from a reachability procedure that generates a ""covering graph"", a generalization of the Karp-Miller graph for Petri Nets. Each node of the covering graph has an associated non-empty set of reachable states, which makes it possible to model check safety properties of the system on the covering graph. For systems with a well-quasi-ordered simulation relation, each infinite fair computation has a finite witness, which may be detected using the covering graph and combinatorial properties of the specific infinite state system. These results explain many known decidability results in a simple, uniform manner. This is a strong indication that the covering graph construction is appropriate for the analysis of infinite state systems. We also consider the new application domain of parameterized broadcast protocols, and indicate how to apply the construction in this domain. This application is illustrated on an invalidation-based cache coherency protocol, for which many safety properties can be proved fully automatically for an arbitrary number of processes."
1998,Model Checking Real-Time Properties of Symmetric Systems.,"Abstract
We develop efficient algorithms for model checking quantitative properties of symmetric reactive systems in the general framework of a Real-Time Mu-calculus. Previous work has been limited to qualitative correctness properties. Our work not only permits handling of quantitative correctness, but it provides a strictly more expressive framework for qualitative correctness since the Mu-calculus strictly subsumes, e.g, CTL. Unlike the previous “group-theoretic” approaches of [CE96] and [ES96] and the technical “automata-theoretic” approach of [ES97], our new approach may be viewed as “model-theoretic”."
1998,Synthesis of Fault-Tolerant Concurrent Programs.,"Methods for mechanically synthesizing concurrent programs from temporal logic specifications obviate the need to manually construct a program and compose a proof of its correctness. A serious drawback of extant synthesis methods, however, is that they produce concurrent programs for models of computation that are often unrealistic. In particular, these methods assume completely fault-free operation, that is, the programs they produce are fault-intolerant. In this paper, we show how to mechanically synthesize fault-tolerant concurrent programs for various fault classes. We illustrate our method by synthesizing fault-tolerant solutions to the mutual exclusion and barrier synchronization problems."
1997,Utilizing Symmetry when Model-Checking under Fairness Assumptions: An Automata-Theoretic Approach.,"One useful technique for combating the state explosion problem is to exploit symmetry when performing temporal logic model checking. In previous work it is shown how, using some basic notions of group theory, symmetry may be exploited for the full range of correctness properties expressible in the very expressive temporal logic CTL*. Surprisingly, while fairness properties are readily expressible in CTL*, these methods are not powerful enough to admit any amelioration of state explosion, when fairness assumptions are involved. We show that it is nonetheless possible to handle fairness efficiently by trading some group theory for automata theory. Our automata-theoretic approach depends on detecting fair paths subtly encoded in a quotient structure whose arcs are annotated with permutations, by using a threaded structure that reflects coordinate shifts caused by the permutations."
1997,Checking Formal Specifications under Simulation.,"Abstract:
""Verification"" of large multiprocessor designs currently heavily on simulation. Formal techniques such as model checking are typically only applied to small parts of the system, due to issues of computational and notational complexity. With these two facts in mind the authors have designed a platform which aims to help bridge the gap between formal verification and simulation. They present a temporal logic specification language which includes constructs for specifying system behavior at a high level of abstraction, and discuss its use in simulation and model checking."
1997,Combining Partial Order and Symmetry Reductions.,"Abstract
Partial order based reduction techniques to reduce time and memory in model-checking procedures are becoming quite popular. Partial order reduction techniques exploit the independence of actions. Symmetry based reduction techniques exploit the inherent structure of the system to reduce the state space explored during model checking. We provide an abstract framework for combining partial-order and symmetry reductions. We also present algorithms which exploit both reduction techniques simultaneously."
1997,Generalized Quantitative Temporal Reasoning: An Automata Theoretic Approach.,"Abstract
This paper proposes an expressive extension to Propositional Linear Temporal Logic dealing with real time correctness properties and gives an automata-theoretic model checking algorithm for the extension. The algorithm has been implemented and applied to examples."
1996,Scheduling workflows by enforcing intertask dependencies.,"Workflows are composite activities that can be used to support and automate multisystem applications involving humans, heterogeneous databases and legacy systems. The traditional atomic transaction model, successful for centralized and homogeneous applications, is not suitable for supporting such workflows. Intertask dependencies, which are conditions involving events and dependencies among workflow tasks, are used to specify the coordination requirements among the workflow tasks and are a central component of most workflow models. They form a basis for developing a uniform formal framework for workflows, which is a key contribution of this work. In this paper, we formalize intertask dependencies using temporal logic. This involves event attributes, which are needed to determine whether a dependency is enforceable and to properly schedule events. Each dependency is represented internally as a finite state automaton that captures the computations that satisfy the given dependency. Sets of automata are combined into a scheduler that produces global computations satisfying all relevant dependencies, thus enacting the given workflow. This algorithm is rigorously proved correct; it has been implemented.
"
1996,Symmetry and Model Checking.,"Abstract
We show how to exploit symmetry in model checking for concurrent systems containing many identical or isomorphic components. We focus in particular on those composed of many isomorphic processes. In many cases we are able to obtain significant, even exponential, savings in the complexity of model checking."
1996,Automatic Verification of Parameterized Synchronous Systems (Extended Abstract).,"Abstract
Systems with an arbitrary number of homogeneous processes occur in many applications. The Parameterized Model Checking Problem (PMCP) is to determine whether a temporal property is true of every size instance of the system. We consider systems formed by a synchronous parallel composition of a single control process with an arbitrary number of homogeneous user processes, and show that the PMCP is decidable for properties expressed in an indexed propositional temporal logic. While the problem is in general PSPACE-complete, our initial experimental results indicate that the method is usable in practice."
1996,Model Checking and the Mu-calculus.,"There is a growing recognition of the need to apply formal mathematical methods in the design of \high conndence"" computing systems. Such systems operate in safety critical contexts (e.g., air traf-c control systems) or where errors could have major adverse economic consequences (e.g., banking networks). The problem is especially acute in the design of many reactive systems which must exhibit correct ongoing behavior, yet are not amenable to thorough testing due to their inherently nondeterministic nature. One useful approach for specifying and reasoning about correctness of such systems is temporal logic model checking, which can provide an eecient and expressive tool for automatic veriication that a nite state system meets a correctness speciication formulated in temporal logic. We describe model checking algorithms and discuss their application. To do this, we focus attention on a particularly important type of temporal logic known as the Mu-calculus."
1996,Synthesis of Concurrent Systems for an Atomic Read / Atomic Write Model of Computation (Extended Abstract).,"Methods for mechanically synthesizing concurrent programs for temporal logic specifications have been proposed by Emerson and Clarke and by Manna and Wolper. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. A serious drawback of these methods in practice, however, is that they produce concurrent programs for models of computation that are often unrealistic, involving highly centralized system architecture (Manna and Wolper), processes with global information about the system state (Emerson and Clarke), or reactive modules that can read all of their inputs in one atomic step (Anuchitanukul and Manna, and Pnueli and Rosner). Even simple synchronization protocols based on atomic read/write primitives such as Peterson's solution to the mutual exclusion problem have remained outside the scope of practical mechanical synthesis methods. In this paper, we show how to mechanically synthesize in more realistic computational models solutions to synchronization problems. We illustrate the method by synthesizing Peterson's solution to the mutual exclusion problem."
1995,Modularity and Rule-Based Programming.,"Methods for mechanically synthesizing concurrent programs for temporal logic specifications have been proposed by Emerson and Clarke and by Manna and Wolper. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. A serious drawback of these methods in practice, however, is that they produce concurrent programs for models of computation that are often unrealistic, involving highly centralized system architecture (Manna and Wolper), processes with global information about the system state (Emerson and Clarke), or reactive modules that can read all of their inputs in one atomic step (Anuchitanukul and Manna, and Pnueli and Rosner). Even simple synchronization protocols based on atomic read/write primitives such as Peterson's solution to the mutual exclusion problem have remained outside the scope of practical mechanical synthesis methods. In this paper, we show how to mechanically synthesize in more realistic computational models solutions to synchronization problems. We illustrate the method by synthesizing Peterson's solution to the mutual exclusion problem."
1995,Automated Temporal Reasoning about Reactive Systems.,"Abstract
There is a growing need for reliable methods of designing correct reactive systems such as computer operating systems and air traffic control systems. It is widely agreed that certain formalisms such as temporal logic, when coupled with automated reasoning support, provide the most effective and reliable means of specifying and ensuring correct behavior of such systems. This paper discusses known complexity and expressiveness results for a number of such logics in common use and describes key technical tools for obtaining essentially optimal mechanical reasoning algorithms. However, the emphasis is on underlying intuitions and broad themes rather than technical intricacies."
1995,Methods for Mu-calculus Model Checking: A Tutorial (Abstract).,n/a
1995,Utilizing Symmetry when Model Checking under Fairness Assumptions: An Automata-theoretic Approach.,"Abstract
One useful technique for combating the state explosion problem is to exploit symmetry [ID93, CFJ93, ES93] when performing temporal logic model checking [CE81, CES86]. In [CFJ93] [ES93] it is shown how, using some basic notions of group theory, symmetry may be exploited for the full range of correctness properties expressible in the very expressive temporal logic CTL*. Surprisingly, while fairness properties are readily expressible in CTL*, these methods are not powerful enough to admit any amelioration of state explosion, when fairness assumptions are involved. We show that it is nonetheless possible to handle fairness efficiently by trading some group theory for automata theory. Our automata-theoretic approach [VW86] depends on detecting fair paths subtly encoded in a permutation annotated quotient structure, using a threaded structure to “physically” reflect coordinate permutations."
1995,Efficient Automation of Temporal Reasoning.,n/a
1995,Reasoning about Rings.,"The ring is a useful means of structuring concurrent processes. Processes communicate by passing a token in a fixed direction; the process that possesses the token is allowed to make certain moves. Usually, correctness properties are expected to hold irrespective of the size of the ring. We show that the problem of checking many useful correctness properties for rings of all sizes can be reduced to checking them on a ring of small size. The results do not depend on the processes being finite state. We illustrate our results on examples."
1994,A New Approach to Modularity in Rule-Based Programming.,"Abstract:
We describe a purely declarative method for introducing modularity into forward-chaining, rule-based languages and its embodiment in the Venus rule language. The method is enforced by the syntax of the language and includes the ability to parameterize the rule groups. Drawing from two of three Venus applications developed to date, we illustrate how this form of modularity contributes directly to the resolution of certain software engineering problems associated with rule languages.< >"
1993,Distributed Real-Time System Specification and Verification in APTL.,"In this article, we propose a language, Asynchronous Propositional Temporal Logic (APTL), for the specification and verification of distributed hard real-time sytems. APTL extends the logic TPTL by dealing explicitly with multiple local clocks. We propose a distributed-system model which permits definition of inequalities asserting the temporal precedence of local clock readings. We show the expressiveness of APTL through two nontrivial examples. Our logic can be used to specify and reason about such important properties as bounded clock rate drifting. We then give a 220(n) tableau-based decision procedure for determining APTL satisfiability, where n is the size (number of bits) of the input formula."
1993,On Model-Checking for Fragments of µ-Calculus.,"Abstract
In this paper we considered two different fragments of μ-calculus, logics L1 and L2. We gave model checking algorithms for logics L1 and L2 which are of complexity O(m2n) where m is the length of the formula and n is the size of the structure. We have shown that the logic L2 is as expressive as ECTL* given in [13]. In additions to these results, we have shown that the model checking problem for the μ-calculus is equivalent to the non-emptiness problem of parity tree automata.
It will be interesting to investigate if there is a model checking algorithm for the logics L1 and L2 which is only of complexity O(mn) instead of O(m2n. Of course, determining if the model checking problem for the full μ-calculus is in P or not, is also an open problem."
1993,Symmetry and Model Checking.,"Abstract
We show how to exploit symmetry in model checking for concurrent systems containing many identical or isomorphic components. We focus in particular on those composed of many isomorphic processes. In many cases we are able to obtain significant, even exponential, savings in the complexity of model checking."
1993,Symbolic Model Checking for Distributed Real-Time Systems.,"Abstract
In this paper, we examine the symbolic model checking problem for distributed real-time systems where time is represented by the real numbers and multiple clocks are allowed. A symbolic model checking algorithm is proposed. This algorithm handles timing constraints that are written in inequalities whose two sides refer to readings of the same local clock. The timing inequalities are used as triggers for transitions in Multiclock Continuously Timed Automaton (MCTA), a variation of the Timed Safety Automaton [11] which we propose as the specification language for distributed real-time systems. We also propose MTCTL, an extension of TCTL by the introduction of multiple local clocks, for specifying system behavior to be verified.
There are three major contributions of this paper. First, we give a symbolic model checking algorithm for Timed Safety Automata and TCTL which naturally makes use of the BDD approach of Bryant[4] and Burch et al[5], and avoids the complications in [11]. Second, we propose a unified approach for checking both real-time and state properties by treating inequalities as propositions that are governed by some axioms. This is not only a more elegant way to represent the finite structure of the state space, but is also more suitable for symbolic manipulation. Third, we introduce MTCTL and MCTA together as a new tool for specifying and reasoning about distributed real-time system behavior that allows for different granularities for local clocks and clock jitters."
1992,Efficient Temporal Satisfiability.,n/a
1992,Quantitative Temporal Reasoning.,"Abstract
A substantially large class of programs operate in distributed and real-time environments, and an integral part of their correctness specification requires the expression of time-critical properties that relate the occurrence of events of the system. We focus on the formal specification and reasoning about the correctness of such programs. We propose a system of temporal logic, RTCTL (Real-Time Computation Tree Logic), that allows the melding of qualitative temporal assertions together with real-time constraints to permit specification and reasoning at the twin levels of abstraction: qualitative and quantitative. We argue that many practically useful correctness properties of temporal systems, which need to express timing as an essential part of their functionality requirements, can be expressed in RTCTL. We develop a model-checking algorithm for RTCTL whose complexity is linear in the size of the RTCTL specification formula and in the size of the structure. We also present an essentially optimal, exponential time tableau-based decision procedure for the satisfiability of RTCTL formulae. Finally, we consider several variants and extensions of RTCTL for real-time reasoning."
1992,Formal Specification of Ssynchronous Distributed Real-Time Systems by APTL.,n/a
1991,"Tree Automata, Mu-Calculus and Determinacy (Extended Abstract).","Abstract:
It is shown that the propositional mu-calculus is equivalent in expressive power to finite automata on infinite trees. Since complementation is trivial in the mu-calculus, the equivalence provides a radically simplified, alternative proof of M.O. Rabin's (1989) complementation lemma for tree automata, which is the heart of one of the deepest decidability results. It is also shown how mu-calculus can be used to establish determinacy of infinite games used in earlier proofs of complementation lemma, and certain games used in the theory of online algorithms.< >"
1991,Real-Time and the Mu-Calculus (Preliminary Report).,"Abstract
We argue that the Mu-Calculus provides a conceptually advantageous framework for specifying and reasoning about Real-Time Systems. We show that mechanical reasoning can be done efficiently in a quantitative formulation of the Mu-Calculus. Our work also suggests a new complexity theory for reactive systems."
1990,Quantitative Temporal Reasoning.,"Abstract
A substantially large class of programs operate in distributed and real-time environments, and an integral part of their correctness specification requires the expression of time-critical properties that relate the occurrence of events of the system. We focus on the formal specification and reasoning about the correctness of such programs. We popose a system of temporal logic, RTCTL (Real-Time Computation Tree Logic), that allows the melding of qualitative temporal assertions together with real-time constraints to permit specification and reasoning at the twin levels of abstraction: qualitative and quantitative. We show that several practically useful correctness properties of temporal systems, which need to express timing as an essential part of their functionality requirements, can be expressed in RTCTL. We also develop a model-checking algorithm for RTCTL whose complexity is linear in the size of the RTCTL specification formula and in the size of the global state-space graph. Finally, we present an optimal, exponential time tableau-based decision procedure for the satisfiability of RTCTL formulae, which can be used as the basis of a technique to automate the synthesis of real-time programs from specifications."
1990,On the Limits of Efficient Temporal Decidability (Extended Abstract).,"Abstract:
An analysis is made of the contribution of the temporal operators alone to the complexity of deciding temporal logics by suppressing the role the usual Boolean connectives play in determining lower bounds on the complexity of their decision procedures. Several temporal logics are exhibited which can state many properties useful in describing temporal systems and which restrict combinations of temporal and Boolean operators so as to be decidable in low deterministic polynomial time. It is also shown that relaxing any of the constraints placed on the syntax of these logics results in intractability, thereby demonstrating that there is a fine line separating tractably decidable sets of temporal formulas from intractable ones.< >"
1990,A Decidable Temporal Logic to Reason About Many Processes.,"There has been much interest in decision procedures for testing satisfiability of formulas in various systems of temporal logic. This is due to the potential applications of such decision procedures to the mechanical synthesis of concurrent programs from their specifications. However, formulae of classical temporal logics can express specifications of only a fixed number of processes. Thus, their use in mechanical synthesis suffers from two limitations, viz., the state explosion problem and their inability to describe dynamic systems, ones in which the number of processes could vary to adapt to external demands. In this paper, we present an indexed temporal logic, Indexed Simplified Computation Tree Logic (Indexed SCTL), that can be used to specify programs with arbitrarily many similar processes. With a view to synthesizing such programs mechanically from specifications, we pose two new decision problems: almost always satisfiability and almost always unsatisfiability. We show that both these problems are decidable for Indexed SCTL, and, in fact, that every Indexed SCTL specification is either almost always satisfiable, i.e., it can be realized by a concurrent program provided that the number of constituent processes exceeds a certain value that depends on the specification (and is determined by our decision procedure), or is almost always unsatisfiable, i.e., no concurrent program with more than a certain number (which, again, is determined by the decision procedure) of processes can ever realize the specification. Finally, we show how our results could be used to automate the synthesis of a concurrent system that meets a desired Indexed SCTL specification which is almost always satisfiable. "
1989,An Automata Theoretic Decision Procedure for the Propositional Mu-Calculus.,"Abstract
The propositional mu-calculus is a propositional logic of programs which incorporates a least fixpoint operator and subsumes the propositional dynamic logic of Fischer and Ladner, the infinite looping construct of Streett, and the game logic of Parikh. We give an elementary time decision procedure, using a reduction to the emptiness problem for automata on infinite trees. A small model theorem is obtained as a corollary."
1989,On Simultaneously Determinizing and Complementing omega-Automata (Extended Abstract).,"Abstract:
The authors give a construction to determine and complement simultaneously a Buchi automaton in infinite strings, with an exponential blowup in states and a linear blowup in the number of pairs. An exponential lower bound is already known. The previous best construction was double exponential. The present result permits exponentially improved essentially optimal decision procedures for various modal logics of programs. It also gives exponentially improved conversions between various kinds of omega automata.< >"
1989,Efficient Temporal Reasoning.,"There has been much interest in decision procedures for testing satisfiability (or validity) of formulae in various systems of Temporal Logic. This is due to the potential applications of such decision procedures to mechanical reasoning about correctness of concurrent programs. We show that there exist Temporal Logics that are (i) decidable in polynomial time, and (ii) still useful in applications. One surprising corollary of our results is that the fragment of CTL (Computation Tree Logic) actually used by Emerson & Clarke [EC82] to synthesize concurrent programs from temporal specifications is decidable in polynomial time. Another is that the verification of many correctness properties of concurrent programs (such as in Owicki & Lamport [OL82]) can be efficiently automated. This demonstrates that many useful correctness properties can be expressed with a rather restricted syntax. Finally, our results provide insight into the relation between the structural (i.e., syntactic) complexity of temporal logics and the complexity of their decision problems."
1989,Synthesis of Concurrent Systems with Many Similar Sequential Processes.,"Methods for synthesizing concurrent programs from Temporal Logic specifications based on the use of a decision procedure for testing temporal satisfiability have been proposed by Emerson & Clarke [EC82] and Manna & Wolper [MW84]. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. One only has to formulate a precise problem specification; the synthesis method then mechanically constructs a correct solution. A serious drawback of these methods in practice, however, is that they suffer from the state explosion problem. To synthesize a concurrent system consisting of K sequential processes, each having N states in its local transition diagram, requires construction of the global product-machine having at least NK global states in general. This exponential growth in K makes it infeasible to synthesize systems composed of more than 2 or 3 processes. In this paper, we show how to synthesize concurrent systems consisting of many (i.e., a finite but arbitrarily large number K of) similar sequential processes. Our approach avoids construction of the global product-machine for K processes; instead, it constructs a two process product-machine for a single pair of generic sequential processes. The method is uniform in K, providing a simple template that can be instantiated for each process to yield a solution for any fixed K. The method is also illustrated on synchronization problems from the literature."
1988,The Complexity of Tree Automata and Logics of Programs (Extended Abstract).,"Abstract:
The computational complexity of testing nonemptiness of finite-state automata on infinite trees is investigated. It is shown that for tree automata with m states and n pairs nonemptiness can be tested in time O((mn)/sup 3n/), even though the problem is in general NP-complete. The nonemptiness algorithm is used to obtain exponentially improved, essentially tight upper bounds for numerous important modal logics of programs, interpreted with the usual semantics over structures generated by binary relations. For example, it is shown that satisfiability for the full branching time logic CTL* can be tested in deterministic double exponential time. It also follows that satisfiability for propositional dynamic logic with a repetition construct (PDL-delta) and for the propositional mu-calculus (L mu ) can be tested in deterministic single exponential time.< >"
1988,Branching time temporal logic.,"Abstract
Many important parallel computer programs exhibit ongoing behaviour that is characterized naturally in terms of infinite execution traces, which can be organized into “branching” trees, and which reflect the high degree of nondeterminism inherent in parallel computation. In this paper, we give a systematic account of Branching Time Temporal Logics, which provide a formal system for describing and reasoning about the correct behaviour of such programs. Several systems of branching time temporal logic that have appeared in the literature are presented, and significant related issues such as their axiomatizations, and decision procedures for their satisfiability and model checking problems are discussed. The applicability of their axiomatizations to formulate deductive systems of these temporal logics to reason about the correctness of concurrent programs is then described as is that of their decision procedures to the tasks of mechanical synthesis and verification. A comparison of the relative expressive power of these systems of branching time temporal logic is also presented, and their ability to specify important correctness properties of programs, including those that involve fairness, is discussed. Moreover, their expressiveness is related to both, the expressiveness of corresponding linear time temporal logics, as well as that of other standard formalisms such as the monadic second-order theory of many successors and finite-state tree automata. Finally, a comparison is undertaken between branching time temporal logics and linear time ones, particularly with respect to their adequacy for such applications as specifying and reasoning about the correctness of concurrent programs."
1987,Uniform Inevitability is Tree Automaton Ineffable.,"Abstract
In this short article we consider the limits of the expressive power of finite automata on infinite trees. We exhibit a surprisingly simple correctness property, uniform inevitability, which is not definable by any type of finite automaton on infinite trees."
1987,Modalities for Model Checking: Branching Time Logic Strikes Back.,"Abstract
We consider automatic verification of finite state concurrent programs. The global state graph of such a program can be viewed as a finite (Kripke) structure, and amodel checking algorithm can be given for determining if a given structure is a model of a specification expressed in a propositional temporal logic. In this paper, we present a unified approach for efficient model checking under a broad class of generalized fairness constraints in a branching time framework extending that of Clarke et al. (1983). Our method applies to any type of fairness expressed in a certain canonical form. Almost all ‘practical’ types of fairness from the literature, including the fundamental notions of impartiality, weak fairness, and strong fairness, can be succintly written in our canonical form. Moreover, our branching time approach can easily be adapted to handle types of fairness (such as fair reachability of a predicate) which cannot even be expressed in a linear temporal logic. We go on to argue that branching time logic is always better than linear time logic for model checking. We show that given any model checking algorithm for any system of linear time logic (in particular, for the usual system of linear time logic) there is a model checking algorithm of the same order of complexity (in both the structure and formula size) for the corresponding full branching time logic which trivially subsumes the linear time logic in expressive power (in particular, for the system of full branching time logic CTL*). We also consider an application of our work to the theory of finite automata on infinite strings."
1986,"""Sometimes"" and ""Not Never"" revisited: on branching versus linear time temporal logic.","The differences between and appropriateness of branching versus linear time temporal logic for reasoning about concurrent programs are studied. These issues have been previously considered by Lamport. To facilitate a careful examination of these issues, a language, CTL*, in which a universal or existential path quantifier can prefix an arbitrary linear time assertion, is defined. The expressive power of a number of sublanguages is then compared. CTL* is also related to the logics MPL of Abrahamson and PL of Harel, Kozen, and Parikh. The paper concludes with a comparison of the utility of branching and linear time temporal logics."
1986,Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications.,"We give an efficient procedure for verifying that a finite-state concurrent system meets a specification expressed in a (propositional, branching-time) temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global state graph for the concurrent system. We also show how this approach can be adapted to handle fairness. We argue that our technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite-state concurrent systems. Experimental results show that state machines with several hundred states can be checked in a matter of seconds."
1986,Efficient Model Checking in Fragments of the Propositional Mu-Calculus (Extended Abstract).,n/a
1986,Temporal Reasoning Under Generalized Fairness Constraints.,n/a
1985,Decision Procedures and Expressiveness in the Temporal Logic of Branching Time.,"Abstract
We consider the computation tree logic (CTL) proposed in (Sci. Comput. Programming 2 (1982), 241–260) which extends the unified branching time logic (UB) of (“Proc. Ann. ACM Sympos. Principles of Programming Languages, 1981,” pp. 164–176) by adding an until operator. It is established that CTL has the small model property by showing that any satisfiable CTL formulae is satisfiable in a small finite model obtained from the small “pseudomodel” resulting from the Fischer-Ladner quotient construction. Then an exponential time algorithm is given for deciding satisfiability in CTL, and the axiomatization of UB given in ibid. is extended to a complete axiomatization for CTL. Finally, the relative expressive power of a family of temporal logics obtained by extending or restricting the syntax of UB and CTL is studied."
1985,"Automata, Tableaux and Temporal Logics (Extended Abstract).",n/a
1985,Modalities for Model Checking: Branching Time Strikes Back.,n/a
1984,Deciding Full Branching Time Logic.,"In this paper the full branching time logic (CTL*) is studied. It has basic modalities consisting of a path quantifier, either A (“for all paths”) of E (“for some path”), followed by an arbitrary linear time assertion composed of unrestricted combinations of the usual linear temporal operators F (“sometime”), G (“always”), X (“nexttime”), and U (“until”). It is shown that the problem of determining if a CTL* formula is satisfiable in a structure generated by a binary relation is decidable in triple exponential time. The decision procedure exploits the special structure of the finite state ω-automata for linear temporal formulae which allows them to be determinized with only a single exponential blowup in size. Also the expressive power of tree automata is compared with that of CTL* augmented by quantified auxillary propositions."
1984,The Propositional Mu-Calculus is Elementary.,"Abstract
The propositional mu-calculus is a propositional logic of programs which incorporates a least fixpoint operator and subsumes the Propositional Dynamic Logic of Fischer and Ladner, the infinite looping construct of Streett, and the Game Logic of Parikh. We give an elementary time decision procedure, using a reduction to the emptiness problem for automata on infinite trees. A small model theorem is obtained as a corollary."
1984,Deciding Branching Time Logic.,"In this paper we study the full branching time logic (CTL*) in which a path quantifier, either A (“for all paths”) or E (ldquo;for some path”), prefixes an assertion composed of arbitrary combinations of the usual linear time operators F (“sometime”), G (“always”), X (“nexttime”), and U (“until”). We show that the problem of determining if a CTL* formula is satisfiable in structure generated by a binary relation is decidable in triple exponential time. The decision procedure exploits the special structure of the finite state ω-automata for linear temporal formulae which allows them to be determinized with only a single exponential blowup in size. We also compare the expressive power of tree automata with CTL* augmented by quantified auxillary propositions."
1983,Alternative Semantics for Temporal Logics.,"Abstract
The relationship between alternative underlying semantics for temporal logics is studied. A number of constraints on the allowable sets of computation paths can be built into a logic to try to ensure that the abstract computation path semantics of a concurrent program accurately reflects essential aspects of ‘real’ concurrent programs. Three such constraints are suffix closure (Lamport, 1980), fusion closure (Pratt, 1979) and limit closure (Abrahamson, 1980). Another common constraint is that the set of paths be R-generable, i.e., generated by some binary relation (Manna and Pnueli, 1979). We show that each of the first three constraints is independent of the others, and their conjunction is precisely equivalent to the fourth constraint."
1983,Deciding Branching Time Logic: A Triple Exponential Decision Procedure for CTL*.,"In this paper we study the full branching time logic (CTL*) in which a path quantifier, either A (for all paths-&-rdquo;) or E (-&-ldquo;for some path), prefixes an assertion composed of arbitrary combinations of the usual linear time operators F (sometime), G (always), X (nexttime), and U (until). We show that the problem of determining if a CTL* formula is satisfiable in structure generated by a binary relation is decidable in triple exponential time. The decision procedure exploits the special structure of the finite state ?-automata for linear temporal formulae which allows them to be determinized with only a single exponential blowup in size. We also compare the expressive power of tree automata with CTL* augmented by quantified auxillary propositions"
1983,Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications: A Practical Approach.,We give an efficient procedure for verifying that a finite state concurrent system meets a specification expressed in a (propositional) branching-time temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global transition graph for the concurrent system. We also show how the logic and our algorithm can be modified to handle fairness. We argue that this technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite state concurrent systems.
1983,"""Sometimes"" and ""Not Never"" Revisited: On Branching Versus Linear Time.","Temporal logic ([PR57], [PR67]) provides a formalism for describing the occurrence of events in time which is suitable for reasoning about concurrent programs (cf. [PN77]). In defining temporal logic, there are two possible views regarding the underlying nature of time. One is that time is linear: at each moment there is only one possible future. The other is that time has a branching, tree-like nature: at each moment, time may split into alternate courses representing different possible futures. Depending upon which view is chosen, we classify (cf. [RU71]) a system of temporal logic as either a linear time logic in which the semantics of the time structure is linear, or a system of branching time logic based on the semantics corresponding to a branching time structure. The modalities of a temporal logic system usually reflect the semantics regarding the nature of time. Thus,in a logic of linear time, temporal operators are provided for describing events along a single time path (cf. [GPSS80]). In contract, in a logic of branching time the operators reflect the branching nature of time by allowing quantification over possible futures cf. [AB80],[EC80]).
Some controversy has arisen in the computer science community regarding the differences between and appropriateness of branching versus linear time temporal logic. In a landmark paper [LA80] intended to ""clarify the logical foundations of the application of temporal logic to concurrent programs,"" Lamport addresses these issues. He defines a single language based on the temporal operators ""always"" and ""sometimes"". Two distinct interpretations for the language are given. In the first interpretation formulae make assertions about paths, whereas in the second interpretation they make assertions about states. Lamport associates the former with linear time and the latter with branching time (although it should be noted that in both cases the underlying time structures are branching). He then compares the expressive power of linear time and branching time logic. Based on his comparison and other arguments, he concludes that, while branching time logic is suitable for reasoning about nondeterministic programs, linear time logic is preferable for reasoning about concurrent programs.
In this paper, we re-examine Lamport's arguments and reach somewhat different conclusions. We first point out some technical difficulties with the formalism of [LA80]. For instance, the definition of expressive equivalence leads to paradoxical situations where satisfiable formulae are classified as equivalent to false. Moreover, the proofs of the results comparing expressive power do not apply in the case of structures generated by a binary relation like those used in the logics of [FL79] and [BMP81]. We give a more refined basis for comparing expressive power that avoids these technical difficulties. It does turn out that expressibility results corresponding to Lamport's still hold. However, it should be emphasized that these results apply only to the two particular systems that he defines. Sweeping conclusions regarding branching versus linear time logic in general are not justified on this basis.
We will argue that there are several different aspects to the problem of designing and reasoning about concurrent programs. While the specific modalities needed in a logic depend on the precise nature of the purpose for which it is intended, we can make some general observations regarding the choice between a system of branching or linear time. We believe that linear time logics are generally adequate for verifying the correctness of pre-existing concurrent programs. For verification purposes, we are typically interested in properties that hold of all computation paths. It is thus satisfactory to pick an arbitrary path and reason about it. However, there are applications where we need the ability to assert the existence of alternative computation paths as provided by a branching time logic. This arises from the nondeterminism - beyond that used to model concurrency - present in many concurrent programs. In order to give a complete specification of such a program, we must ensure that there are viable computation path a corresponding to the nondeterministic choices the program might make. (An example is given in section 6.) Neither of Lamport's systems is entirely adequate for such applications.
In order to examine these issues more carefully, we define a language, CTL*, in which a universal or existential path quantifier can prefix an arbitrary linear time assertion. CTL* is an extension of the Computation Tree Logic, CTL, defined in [CE81] and studied in [EH82]. This language subsumes both of Lamport's interpretations and allows us to compare branching with linear time. Moreover, the syntax of CTL* makes it clear which interpretation is intended.
The paper is organized as follows: In section 2 we summarize Lamport's approach and discuss its limitation. In section 3 we present the syntax and semantics of CTL*. We also define some natural sublanguages of CTL* and compare their expressive power in Section 4. In particular, we show that (cf. Theorem 4.1) a language substantially less expressive than CTL* still subsumes both of Lamport's interpretations. Section 5 then shows how CTL* can be embedded in MPL [AB80] and PL [HKP80]. Finally, section 6 concludes with a comparison of the utility of branching and linear time logic."
1982,Using Branching Time Temporal Logic to Synthesize Synchronization Skeletons.,"Abstract
We present a method of constructing concurrent programs in which the synchronization skeleton of the program is automatically synthesized from a (branching time) temporal logic specification. The synthesis method uses a decision procedure based on the finite model property of the logic to determine satisfiability of the specification formula f. If f is satisfiable, then a model for f with a finite number of states is constructed. The synchronization skeleton of a program meeting the specification can be read from this model. If f is unsatisfiable, the specification is inconsistent."
1982,Decision Procedures and Expressiveness in the Temporal Logic of Branching Time.,"In this paper we consider the Computation Tree Logic (CTL) proposed in [CE] which extends the Unified Branching Time Logic (UB) of [BMP] by adding an until operator. We establish that CTL has the small property by showing that any satisfiable CTL formulae is satisfiable in a small finite model obtained from a small -&-ldquo;pseudo-model-&-rdquo; resulting from the Fischer Ladner quotient construction. We then give an exponential time algorithm for deciding satisfiability in CTL, and extend the axiomatization of UB given in [BMP] to a complete axiomatization for CTL. Lastly, we study the relative expressive power of a family of temporal logics obtained by extending or restricting the syntax of UB and CTL."
1981,Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic.,"Abstract
We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.
We have also described a model checking algorithm which can be applied to mechanically verify that a finite state concurrent program meets a particular Temporal Logic specification. We believe that practical software tools based on this technique could be developed in the near future. Indeed, we have already programmed an experimental implementation of the model checker on the DEC 11/70 at Harvard.* Certain applications seem particularly suited to the model checker approach to verification: One example is the problem of verifying the correctness of existing network protocols many of which are coded as finite state machines. We encourage additional work in this area."
1980,Characterizing Correctness Properties of Parallel Programs Using Fixpoints.,"Abstract
We have shown that correctness properties of parallel programs can be described using computation trees and that from these descriptions fixpoint characterizations can be generated. We have also given conditions on the form of computation tree descriptions to ensure that a correctness property can be characterized using continuous fixpoints. A consequence is that a correctness property such as inevitability under fair scheduling can be characterized as the least fixpoint of a monotonic, noncontinuous transformer, but cannot be characterized using fixpoints of continuous transformers (nor as the greatest fixpoint of a monotonic transformer of any degree of complexity lower than fair inevitability itself). Hence, currently known proof rules are not applicable (see however [FS80]). We are now investigating whether useful proof rules can exist for correctness properties having only a monotonic, noncontinuous least fixpoint characterization. In addition, we are examining alternate notions of fairness which do have continuous fixpoint characterizations."

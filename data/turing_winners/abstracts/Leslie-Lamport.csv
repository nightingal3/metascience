2018,"If You're Not Writing a Program, Don't Use a Programming Language.","The need to handle large programs and to produce ecient compiled codeadds complexity to programming languages and limits their expressiveness.
Algorithms are not programs, and they can be expressed in a simpler and more expressive language. That language is the one used by almost every branch of science and engineering to precisely describe and reason about the objects they study: the language of mathematics. Math is useful for describing a more general class of algorithms than are studied in algorithm
courses."
2015,Who builds a house without drawing blueprints?,"Finding a better solution by thinking about the problem and its solution, rather than just thinking about the code.
"
2014,Coalescing: Syntactic Abstraction for Reasoning in First-Order Modal Logics.,We present a syntactic abstraction method to reason about first-order modal logics by using theorem provers for standard first-order logic and for propositional modal logic. 
2014,An incomplete history of concurrency chapter 1. 1965-1977.,"A personal view of the first dozen years of the modern field of concurrent and distributed computing, viewed from the perspective of 2014. Further chapters are left for others to write. "
2013,Adaptive Register Allocation with a Linear Number of Registers.,"Abstract
We give an adaptive algorithm in which processes use multi-writer multi-reader registers to acquire exclusive write access to their own single-writer, multi-reader registers. It is the first such algorithm that uses a number of registers linear in the number of participating processes. Previous adaptive algorithms require at least Œò(n 3/2) registers."
2012,TLA + Proofs.,"Abstract
TLA‚Äâ+‚Äâ is a specification language based on standard set theory and temporal logic that has constructs for hierarchical proofs. We describe how to write TLA‚Äâ+‚Äâ proofs and check them with TLAPS, the TLA‚Äâ+‚Äâ Proof System. We use Peterson‚Äôs mutual exclusion algorithm as a simple example and show how TLAPS and the Toolbox (an IDE for TLA‚Äâ+‚Äâ) help users to manage large, complex proofs."
2011,Euclid Writes an Algorithm: A Fairytale.,n/a
2011,Brief Announcement: Leaderless Byzantine Paxos.,"Abstract
The role of leader in an asynchronous Byzantine agreement algorithm is played by a virtual leader that is implemented using a synchronous Byzantine agreement algorithm."
2011,Byzantizing Paxos by Refinement.,"Abstract
We derive a
3f+1
3
process Byzantine Paxos consensus algorithm by Byzantizing a variant of the ordinary Paxos algorithm‚Äîthat is, by having
2f+1
2
nonfaulty processes emulate the ordinary Paxos algorithm despite the presence of f malicious processes. We have written a formal, machine-checked proof that the Byzantized algorithm implements the ordinary Paxos consensus algorithm under a suitable refinement mapping."
2010,The mailbox problem.,"Abstract
We propose and solve a synchronization problem called the mailbox problem, motivated by a particular type of interaction between a processor and an external device or between two threads. In this problem, a postman delivers letters to the mailbox of a home owner and uses a flag to signal a non-empty mailbox. The owner must remove all letters delivered to the mailbox and should not walk to the mailbox if it is empty. We present algorithms and an impossibility result for this problem."
2010,Reconfiguring a state machine.,"Reconfiguration means changing the set of processes executing a distributed system. We explain several methods for reconfiguring a system implemented using the state-machine approach, including some new ones. We discuss the relation between these methods and earlier reconfiguration algorithms--especially view changing in group communication.
"
2010,Computer Science and State Machines.,"Abstract
Computer science is largely about computation. Many kinds of computing devices have been described, some abstract and some very concrete. Among them are:
Automata, including Turing machines, Moore machines, Mealy machines, pushdown automata, and cellular automata.
Computer programs written in a programming language.
Algorithms written in natural language and pseudocode.
von Neumann computers.
BNF grammars.
Process algebras such as CCS.
Computer scientists collectively suffer from what I call the Whorfian syndrome the confusion of language with reality. Since these devices are described in different languages, they must all be different. In fact, they are all naturally described as state machines."
2010,Verifying Safety Properties with the TLA+ Proof System.,"Abstract
TLAPS, the TLA‚Äâ+‚Äâ proof system, is a platform for the development and mechanical verification of TLA‚Äâ+‚Äâ proofs. The TLA‚Äâ+‚Äâ proof language is declarative, and understanding proofs requires little background beyond elementary mathematics. The language supports hierarchical and non-linear proof construction and verification, and it is independent of any verification tool or strategy. Proofs are written in the same language as specifications; engineers do not have to translate their high-level designs into the language of a particular verification tool. A proof manager interprets a TLA‚Äâ+‚Äâ proof as a collection of proof obligations to be verified, which it sends to backend verifiers that include theorem provers, proof assistants, SMT solvers, and decision procedures.
The first public release of TLAPS is available from [1], distributed with a BSD-like license. It handles almost all the non-temporal part of TLA‚Äâ+‚Äâ as well as the temporal reasoning needed to prove standard safety properties, in particular invariance and step simulation, but not liveness properties. Intuitively, a safety property asserts what is permitted to happen; a liveness property asserts what must happen; for a more formal overview, see [3,10]."
2010,The TLA+ Proof System: Building a Heterogeneous Verification Platform.,"Abstract
Model checking has proved to be an efficient technique for finding subtle bugs in concurrent and distributed algorithms and systems. However, it is usually limited to the analysis of small instances of such systems, due to the problem of state space explosion. When model checking finds no more errors, one can attempt to verify the correctness of a model using theorem proving, which also requires efficient tool support."
2009,Teaching concurrency.,n/a
2009,The PlusCal Algorithm Language.,"Abstract
Algorithms are different from programs and should not be described with programming languages. The only simple alternative to programming languages has been pseudo-code. PlusCal is an algorithm language that can be used right now to replace pseudo-code, for both sequential and concurrent algorithms. It is based on the TLA‚Äâ+‚Äâ specification language, and a PlusCal algorithm is automatically translated to a TLA‚Äâ+‚Äâ specification that can be checked with the TLC model checker and reasoned about formally."
2009,"TLA+: Whence, Wherefore, and Whither.",n/a
2009,Vertical paxos and primary-backup replication.,"We introduce a class of Paxos algorithms called Vertical Paxos, in which reconfiguration can occur in the middle of reaching agreement on an individual state-machine command. Vertical Paxos algorithms use an auxiliary configuration master that facilitates agreement on reconfiguration. A special case of these algorithms leads to traditional primary-backup protocols. We show how primary-backup systems in current use can be viewed, and shown to be correct, as instances of Vertical Paxos algorithms."
2008,Implementing dataflow with threads.,"Abstract
A general algorithm is presented for implementing dataflow computations with multiple threads that communicate using only reads and writes of shared memory."
2008,A TLA+ Proof System.,"We describe an extension to the TLA+ specification language with constructs for writing proofs and a proof environment, called the Proof Manager (PM), to checks those proofs. The language and the PM support the incremental development and checking of hierarchically structured proofs. The PM translates a proof into a set of independent proof obligations and calls upon a collection of back-end provers to verify them. Different provers can be used to verify different obligations. The currently supported back-ends are the tableau prover Zenon and Isabelle/TLA+, an axiomatisation of TLA+ in Isabelle/Pure. The proof obligations for a complete TLA+ proof can also be used to certify the theorem in Isabelle/TLA+."
2008,The Mailbox Problem.,"Abstract
We propose and solve a synchronization problem called the mailbox problem, motivated by the interaction between devices and processor in a computer. In this problem, a postman delivers letters to the mailbox of a housewife and uses a flag to signal a non-empty mailbox. The wife must remove all letters delivered to the mailbox and should not walk to the mailbox if it is empty. We present algorithms and an impossibility result for this problem."
2007,Formal specification of a Web services protocol.,"Abstract
We describe a use of formal methods to specify and check a Web Services protocol. The Web Services Atomic Transaction protocol was specified in TLA+ and checked with the TLC model checker. A modest effort revealed oversights that caused unanticipated behaviors of the protocol; these were corrected by clarifications and changes to the protocol."
2007,"DISC 20th Anniversary: Invited Talk Time, Clocks, and the Ordering of My Ideas About Distributed Systems.","Abstract
A guided tour through the labyrinth of my thoughts, from the Bakery Algorithm to arbiter-free marked graphs. This exercise in egotism is by invitation of the DISC 20th Anniversary Committee. I take no responsibility for the choice of topic."
2006,Fast Paxos.,"Abstract
As used in practice, traditional consensus algorithms require three message delays before any process can learn the chosen value. Fast Paxos is an extension of the classic Paxos algorithm that allows the value to be learned in two message delays. How and why the algorithm works are explained informally, and a TLA+ specification of the algorithm appears as an appendix."
2006,Lower bounds for asynchronous consensus.,"Abstract
Impossibility results and best-case lower bounds are proved for the number of message delays and the number of processes required to reach agreement in an asynchronous consensus algorithm that tolerates non-Byzantine failures. General algorithms exist that achieve these lower bounds in the normal case, when the response time of non-faulty processes and the transmission delay of messages they send to one another are bounded. Our theorems allow algorithms to do better in certain exceptional cases, and such algorithms are presented. Two of these exceptional algorithms may be of practical interest."
2006,Consensus on transaction commit.,"The distributed transaction commit problem requires reaching agreement on whether a transaction is committed or aborted. The classic Two-Phase Commit protocol blocks if the coordinator fails. Fault-tolerant consensus algorithms also reach agreement, but do not block whenever any majority of the processes are working. The Paxos Commit algorithm runs a Paxos consensus algorithm on the commit/abort decision of each participant to obtain a transaction commit protocol that uses 2F + 1 coordinators and makes progress if at least F + 1 of them are working properly. Paxos Commit has the same stable-storage write delay, and can be implemented to have the same message delay in the fault-free case as Two-Phase Commit, but it uses more messages. The classic Two-Phase Commit algorithm is obtained as the special F = 0 case of the Paxos Commit algorithm.
"
2006,The +CAL Algorithm Language.,"Abstract
Algorithms are different from programs and should not be described with programming languages. For example, algorithms are usually best described in terms of mathematical objects like sets and graphs instead of the primitive objects like bytes and integers provided by programming languages. Until now, the only simple alternative to programming languages has been pseudo-code.
+CAL is an algorithm language based on TLA+. A +CAL algorithm is automatically translated to a TLA+ specification that can be checked with the TLC model checker or reasoned about formally. +CAL makes pseudo-code obsolete."
2006,The +CAL Algorithm Language.,"Abstract:
Summary form only given. Algorithms are different from programs and should not be described with programming languages. For example, algorithms are usually best described in terms of mathematical objects like sets and graphs instead of the primitive objects like bytes and integers provided by programming languages. +CAL is an algorithm language based on TLA+. A +CAL algorithm is translated to a TLA+ specification that can then be checked with the TLC model checker"
2006,Checking a Multithreaded Algorithm with +CAL.,"Abstract
A colleague told me about a multithreaded algorithm that was later reported to have a bug. I rewrote the algorithm in the ‚Äâ+‚Äâ cal algorithm language, ran the TLC model checker on it, and found the error. Programs are not released without being tested; why should algorithms be published without being model checked?"
2005,Real-Time Model Checking Is Really Simple.,"Abstract
It is easy to write and verify real-time specifications with existing languages and methods; one just represents time as an ordinary variable and expresses timing requirements with special timer variables. The resulting specifications can be verified with an ordinary model checker. This basic idea and some less obvious details are explained, and results are presented for two examples."
2005,How Fast Can Eventual Synchrony Lead to Consensus?.,"Abstract:
It is well known that the consensus problem can be solved in a distributed system if, after some time T/sub S/, no process fails and there is some upper bound /spl delta/ on how long it takes to deliver a message. We know of no existing algorithm that guarantees consensus among N processes before time T/sub S/+O(N/spl delta/). We show that consensus can be achieved by time T/sub S/+O(/spl delta/)."
2004,Formal Specification of a Web Services Protocol.,"Abstract
We describe a use of formal methods to specify and check a Web Services protocol. The Web Services Atomic Transaction protocol was specified in TLA+ and checked with the TLC model checker. A modest effort revealed oversights that caused unanticipated behaviors of the protocol; these were corrected by clarifications and changes to the protocol."
2004,Recent Discoveries from Paxos.,n/a
2004,Cheap Paxos.,"Abstract:
Asynchronous algorithms for implementing a fault-tolerant distributed system, which can make progress despite the failure of any F processors, require 2F + 1 processors. Cheap Paxos, a variant of the Paxos algorithm, guarantees liveness under the additional assumption that the set of nonfaulty processors does not ""jump around"" too fast, but uses only F + 1 main processors that actually execute the system and F auxiliary processors that are used only to handle the failure of a main processor. The auxiliary processors take part in reconfiguring the system to remove the failed processor, after which they can remain idle until another main processor fails."
2003,Disk Paxos.,"Abstract.
We present an algorithm, called Disk Paxos, for implementing a reliable distributed system with a network of processors and disks. Like the original Paxos algorithm, Disk Paxos maintains consistency in the presence of arbitrary non-Byzantine faults. Progress can be guaranteed as long as a majority of the disks are available, even if all processors but one have failed."
2003,Arbitration-free synchronization.,"Abstract.
Implementing traditional forms of multiprocess synchronization requires a hardware arbiter. Here, we consider what kind of synchronization is achievable without arbitration. Several kinds of simple arbiter-free registers are defined and shown to have equal power, and the class of synchronization problems solvable with such registers is characterized. More powerful forms of arbiter-free communication primitives are described. However, the problem of characterizing the most general form of arbiter-free synchronization remains unsolved."
2003,Checking Cache-Coherence Protocols with TLA+.,"Abstract
We have a great deal of experience using the specification language TLA+ and its model checker TLC to analyze protocols designed at Digital and Compaq (both now part of HP). The tools and techniques we have developed apply equally well to software and hardware designs. In this paper, we describe our experience using TLA+ and TLC to verify cache-coherence protocols."
2003,Lower Bounds for Asynchronous Consensus.,"Abstract
Most fault-tolerant algorithms are designed assuming that out of n components, no more than t can be faulty. For example, solutions to the Consensus problem are usually developed assuming no more than t of the n processes are faulty, where ‚Äúbeing faulty‚Äù is specialized by a failure model. We call this the t of n assumption (also known as threshold model). It is a convenient assumption to make. For example, bounds are easily expressed as a function of t: if processes can fail only by crashing, then the Consensus problem is solvable when t < n if the system is synchronous and when t < 2n if the system is asynchronous extended with a failure detector of the class ‚óäW. [5.5], [5.1]"
2002,High-Level Specifications: Lessons from Industry.,"Abstract
We explain the rationale behind the design of the TLA‚Äâ+‚Äâ specification language, and we describe our experience using it and the TLC model checker in industrial applications‚Äìincluding the verification of multiprocessor memory designs at Intel. Based on this experience, we challenge some conventional wisdom about high-level specifications."
2002,"Paxos Made Simple, Fast, and Byzantine.",n/a
2002,Specifying and verifying systems with TLA+.,"TLA+ is a high-level specification language that has been used to specify and check the correctness of several hardware protocols. We expect that it can also be used to specify and check concurrent algorithms and protocols for software systems.
"
2000,Fairness and hyperfairness.,"The notion of fairness in trace-based formalisms is examined. It is argued that, in general, fairness means machine closure. The notion of hyperfairness introduced by Attie, Francez, and Grumberg is generalized to arbitrary action systems. Also examined are the fairness criteria proposed by Apt, Francez, and Katz.
"
2000,When does a correct mutual exclusion algorithm guarantee mutual exclusion?,"Mutual exclusion is usually defined to mean that two processes are not in their critical section at the same time. Something Dan Scales said during a conversation made me suddenly realize that conventional mutual exclusion algorithms do not satisfy that property. I then conjectured how that property could be satisfied, and Perl and Weihl proved that my conjecture was correct. This paper explains why mutual exclusion had not previously been achieved, and how to achieve itñall in less than five pages.
"
2000,Distributed algorithms in TLA (abstract).,"TLA (the temporal logic of actions) is a simple logic for describing and reasoning about concurrent systems. It provides a uniform way of specifying algorithms and their correctness properties, as well as rules for proving that one specification satisfies another. TLA+ is a formal specification language based on TLA, and TLC is a model checker for TLA+ specifications. TLA+ and TLC have been used to specify and check high-level descriptions of real, complex systems. Because TLA+ provides the full power of ordinary mathematics, it permits simple, straightforward specifications of the kinds of algorithms presented at PODC.

This tutorial will try to convince you to describe your algorithms in TLA+. You will then be able to check them with TLC and use TLA to prove their correctness as formally or informally as you want. (However, TLA proofs do have one disadvantage that is mentioned below.) The tutorial will describe TLA+ through examples and demonstrate how to use TLC. No knowledge of TLA is assumed.

TLA does have the following disadvantages:

It can describe only a real algorithm, not a vague, incomplete sketch of an algorithm.
You can specify an algorithm's correctness condition in TLA only if you understand what the algorithm is supposed to do.
TLA makes it harder to cover gaps in a proof with handwaving.
Some researchers may find these drawbacks insurmountable."
2000,Disk Paxos.,"Abstract
We present an algorithm, called Disk Paxos, for implementing a reliable distributed system with a network of processors and disks. Like the original Paxos algorithm, Disk Paxos maintains consistency in the presence of arbitrary non-Byzantine faults. Progress can be guaranteed as long as a majority of the disks are available, even if all processors but one have failed."
1999,Lazy Caching in TLA.,"Summary.
We address the problem, proposed by Gerth, of verifying that a simplified version of the lazy caching algorithm of Afek, Brown, and Merritt is sequentially consistent. We specify the algorithm and sequential consistency in TLA
+
+
, a formal specification language based on TLA (the Temporal Logic of Actions). We then describe how to construct and check a formal TLA correctness proof."
1999,Should your specification language be typed.,"Most specification languages have a type system. Type systems are hard to get right, and getting them wrong can lead to inconsistencies. Set theory can serve as the basis for a specification language without types. This possibility, which has been widely overlooked, offers many advantages. Untyped set theory is simple and is more flexible than any simple typed formalism. Polymorphism, overloading, and subtyping can make a type system more powerful, but at the cost of increased somplexity, and such refinements can never attain the flexibility of having no types at all. Typed formalisms have advantages, too, stemming from the power of mechanical type checking. While types serve little purpose in hand proofs, they do help with mechanized proofs. In the absence of verificaiton, type checking can catch errors in specifications. It may be possible to have the best of both worlds by adding typing annotations to an untyped specification language.

We consider only specification languages, not programming languages."
1999,Model Checking TLA+ Specifications.,"Abstract
TLA+ is a specification language for concurrent and reactive systems that combines the temporal logic TLA with full first-order logic and ZF set theory. TLC is a new model checker for debugging a TLA+ specification by checking invariance properties of a finite-state model of the specification. It accepts a subclass of TLA+ specifications that should include most descriptions of real system designs. It has been used by engineers to find errors in the cache coherence protocol for a new Compaq multiprocessor. We describe TLA+ specifications and their TLC models, how TLC works, and our experience using it."
1999,Cache Coherence Verification with TLA+.,"Abstract
We used the specification language TLA+ to analyze the correctness of two cache-coherence protocols for shared-memory multiprocessors based on two generations (EV6 and EV7) of the Alpha processor. A memory model defines the relationship between the values written by one processor and the values read by another, and a cache-coherence protocol manipulates the caches to preserve this relationship. The cache-coherence protocol is a fundamental component of any shared-memory multiprocessor design. Proving that the coherence protocol implements the memory model is a high-leverage application of formal methods. The analysis of the first protocol was largely a research project, but the analysis of the second protocol was a part of the engineers‚Äô own verification process."
1998,Proving Possibility Properties.,"Abstract
A method is described for proving ‚Äúalways possibly‚Äù properties of specifications in formalisms with linear-time trace semantics. It is shown to be relatively complete for TLA (Temporal Logic of Actions) specifications."
1998,The Part-Time Parliament.,"Recent archaeological discoveries on the island of Paxos reveal that the parliament functioned despite the peripatetic propensity of its part-time legislators. The legislators maintained consistent copies of the parliamentary record, despite their frequent forays from the chamber and the forgetfulness of their messengers. The Paxon parliament's protocol provides a new way of implementing the state machine approach to the design of distributed systems.
"
1998,Reduction in TLA.,"Abstract
Reduction theorems allow one to deduce properties of a concurrent system specification from properties of a simpler, coarser-grained version called the reduced specification. We present reduction theorems based upon a more precise relation between the original and reduced specifications than earlier ones, permitting the use of reduction to reason about a larger class of properties. In particular, we present reduction theorems that handle general liveness properties."
1997,How to Make a Correct Multiprocess Program Execute Correctly on a Multiprocessor.,"Abstract:
A multiprocess program executing on a modern multiprocessor must issue explicit commands to synchronize memory accesses. A method is proposed for deriving the necessary commands from a correctness proof of the underlying algorithm in a formalism based on temporal relations among operation executions."
1997,Processes are in the Eye of the Beholder.,"Abstract
A two-process algorithm is shown to be equivalent to an N-process one, illustrating the insubstantiality of processes. A formal equivalence proof (in TLA the Temporal Logic of Actions) is sketched."
1997,Composition: A Way to Make Proofs Harder.,"Abstract
Compositional reasoning about a system means writing its specification as the parallel composition of components and reasoning separately about each component. When distracting language issues are removed and the underlying mathematics is revealed, compositional reasoning is seen to be of little use."
1996,Managing Proofs (Abstract).,"Abstract
A well-designed proof is a hierarchically structured collection of assumptions and statements. To check the proof with almost any current theorem prover, one must first eliminate the structure and encode the assumptions and statements in the idiosynchratic logic of the prover. One must then check and debug the proof with the particular set of algorithms the prover happens to implement, using an interface that provides an extremely myopic view of the proof. Some people believe that this process can be made wonderful by providing a screen interface that displays typeset formulas and replaces some typing with mouse clicks. In this talk, I propose a more drastic change."
1995,Conjoining Specifications.,"We show how to specify components of concurrent systems. The specification of a system is the conjunction of its components' specifications. Properties of the system are proved by reasoning about its components. We consider both the decomposition of a given system into parts, and the composition of given parts to form a system.
"
1995,TLA in Pictures.,"Abstract:
Predicate-action diagrams, which are similar to standard state-transition diagrams, are precisely defined as formulas of TLA (the Temporal Logic of Actions). We explain how these diagrams can be used to describe aspects of a specification-and those descriptions then proved correct-even when the complete specification cannot be written as a diagram. We also use the diagrams to illustrate proofs.< >"
1994,How to Write a Long Formula (Short Communication).,"Standard mathematical notation works well for short formulas, but not for the longer ones often written by computer scientists. Notations are proposed to make one or two-page formulas easier to read and reason about.
"
1994,The Temporal Logic of Actions.,"The temporal logic of actions (TLA) is a logic for specifying and reasoning about concurrent systems. Systems and their properties are represented in the same logic, so the assertion that a system meets its specification and the assertion that one system implements another are both expressed by logical implication. TLA is very simple; its syntax and complete formal semantics are summarized in about a page. Yet, TLA is not just a logician's toy; it is extremely powerful, both in principle and in practice. This report introduces TLA and describes how it is used to specify and verify concurrent algorithms. The use of TLA to specify and reason about open systems will be described elsewhere.
"
1994,An Old-Fashined Recipe for Real-Time.,"Traditional methods for specifying and reasoning about concurrent systems work for real-time systems. Using TLA (the temporal logic of actions), we illustrate how they work with the examples of a queue and of a mutual-exclusion protocol. In general, two problems must be addressed: avoiding the real-time programming version of Zeno's paradox, and coping with circularities when composing real-time assumption/guarantee specifications. Their solutions rest on properties of machine closure and realizability."
1994,The RPC-Memory Specification Problem - Problem Statement.,n/a
1994,A TLA Solution to the RPC-Memory Specification Problem.,"Abstract
We present a complete solution to the Broy-Lamport specification problem. Our specifications are written in TLA+, a formal language based on TLA. We give the high levels of structured proofs and sketch the lower levels, which will appear in full elsewhere."
1994,TLA in Pictures.,"Predicate-action diagrams, which are similar to standard state-transition diagrams, are precisely defined as formulas of TLA (the Temporal Logic of Actions). We explain how these diagrams can be used to describe aspects of a specification-and those descriptions then proved correct-even when the complete specification cannot be written as a diagram. We also use the diagrams to illustrate proofs. > "
1994,How good is your specification method?,Formal methods abound for specifying concurrent systems. Proponents of a method usually talk about what it does and ignore what it canít do. I will present and explain desiderata for a specification method. 
1994,Specifying and Verifying Fault-Tolerant Systems.,"Abstract
We formally specify a well known solution to the Byzantine generals problem and give a rigorous, hierarchically structured proof of its correctness. We demonstrate that this is an engineering exercise, requiring no new scientific ideas."
1994,Open Systems in TLA.,"We describe a method for writing assumption/guarantee specifications of concurrent systems. We also provide a proof rule for reasoning about the composition of these systems. Specifications are written in TLA (the Temporal Logic of Actions), and all reasoning is performed within the logic. Our proof rule handles internal variables and both safety and liveness properties. "
1994,Decomposing Specifications of Concurrent Systems.,"Large systems are built from smaller parts. We present a method for deducing properties of a system by reasoning about its components. We show how to represent an individual component ?i by a formula Si so that the parallel composition usually denoted cobegin ?1 ? . . . ??n coend is represented by the formula S1 ? . . . ? Sn. Composition is conjunction. We reduce composition to conjunction not for the sake of elegance, but because it is the best way we know to prove properties of composite systems. Rigorous reasoning requires logic, and hence a language of logical formulas. It does not require a conventional programming language for describing systems. We find it most convenient to regard programs and circuit descriptions as low-level specifications, and to represent them in the same logic used for higher-level specifications. The logic we use is TLA, the Temporal Logic of Actions [14]. We do not discuss here the important problem of translating from a low-level TLA specification to an implementation in a conventional language. The idea of representing concurrent programs and their specifications as formulas in a temporal logic was first proposed by Pnueli [17]. It was later observed that, if specifications allow ìstutteringî steps that leave the state unchanged, then Sl ? Sh asserts that Sl implements Sh [12]. Hence, proving that a lower-level specification implements a higherlevel one was reduced to proving a formula in the logic. Still later, it was noticed that the formula ?x : S specifies the same system as S except with the variable x hidden [1,13], and variable hiding became logical quantification. The idea of composition as conjunction has also been suggested [5,6,20], but our method for reducing composition to conjunction is new. "
1994,TLZ.,"Abstract
A Z schema can specify a functional system‚Äîone that produces an output in response to an input. For example, a simple text editor is a functional system; it can be specified by a Z schema that describes the effect of each keystroke on the screen. A reactive system interacts with its environment in a more complex fashion. Adding an interrupt key, which allows the user to stop a long operation before it completes, turns a simple text editor into a reactive system. Concurrent and distributed systems are usually best viewed as reactive systems. Z by itself is inadequate for specifying reactive systems."
1993,Composing Specifications.,"A rigorous modular specification method requires a proof rule asserting that if each component behaves correctly in isolation, then it behaves correctly in concert with other components. Such a rule is subtle because a component need behave correctly only when its environment does, and each component is part of the others' environments. We examine the precise distinction between a system and its environment, and provide the requisite proof rule when modules are specified with safety and liveness properties.
"
1993,Verification of a Multiplier: 64 Bits and Beyond.,"Abstract
Verifying a 64-bit multiplier has a computational complexity that puts it beyond the grasp of current finite-state algorithms, including those based upon homomorphic reduction, the induction principle, and bdd fixed-point algorithms. Theorem proving, while not bound by the same computational constraints, may not be feasible for routinely coping with the complex, low-level details of a real multiplier. We show how to verify such a multiplier by applying COSPAN, a model-checking algorithm, to verify local properties of the complex low-level circuit, and using TLP, a theorem prover based on the Temporal Logic of Actions, to prove that these properties imply the correctness of the multiplier. Both verification steps are automated, and we plan to mechanize the translation between the languages of TLP and COSPAN."
1993,Verification and Specifications of Concurrent Programs.,"Abstract
I explore the history of, and lessons learned from, eighteen years of assertional methods for specifying and verifying concurrent programs. I then propose a Utopian future in which mathematics prevails."
1992,Critique of the Lake Arrowhead Three.,"For a number of years, I was a member of a committee that planned an annual workshop at Lake Arrowhead, in southern California. I was finally pressured into organizing a workshop myself. I got Brent Hailpern to be chairman of a workshop on specification and verification of concurrent systems. A large part of the conference was devoted to a challenge problem of specifying sequential consistency. This was a problem that, at the time, I found difficult. (I later learned how to write the simple, elegant specification that appears in [126].)

Among the presentations at the workshop session on the challenge problem, there were only two serious attempts at solving the problem. (As an organizer, I felt that I shouldnít present my own solution.) After a long period of review and revision, these two and a third, subsequently-written solution, appeared in a special issue of Distributed Computing. This note is a critique of the three solutions that I wrote for the special issue."
1992,Computer-Hindered Verification (Humans Can Do It Too).,n/a
1992,Mechanical Verification of Concurrent Systems with TLA.,"Abstract
We describe an initial version of a system for mechanically checking the correctness proof of a concurrent system. Input to the system consists of the correctness properties, expressed in TLA (the temporal logic of actions), and their proofs, written in a humanly readable, hierarchically structured form. The system uses a mechanical verifier to check each step of the proof, translating the step's assertion into a theorem in the verifier's logic and its proof into instructions for the verifier. Checking is now done by LP (the Larch Prover), using two different translations‚Äîone for action reasoning and one for temporal reasoning. The use of additional mechanical verifiers is planned. Our immediate goal is a practical system for mechanically checking proofs of behavioral properties of a concurrent system; we assume ordinary properties of the data structures used by the system."
1992,Hybrid Systems in TLA+.,"Abstract
TLA+ is a general purpose, formal specification language based on the Temporal Logic of Actions, with no built-in primitives for specifying real-time properties. Here, we use TLA+ to define operators for specifying the temporal behavior of physical components obeying integral equations of evolution. These operators, together with previously defined operators for describing timing constraints, are used to specify a toy gas burner introduced by Ravn, Rischel, and Hansen. The burner is specified at three levels of abstraction, each of the two lower-level specifications implementing the next higher-level one. Correctness proofs are sketched."
1992,Mechanical Verification of Concurrent Systems with TLA.,"We describe an initial version of a system for mechanically checking the correctness proof of a concurrent system. Input to the system consists of the correctness properties, expressed in TLA (the temporal logic of actions), and their proofs, written in a humanly readable, hierarchically structured form. The system uses a mechanical verifier to check each step of the proof, translating the step's assertion into a theorem in the verifier's logic and its proof into instructions for the verifier. Checking is now done by LP (the Larch Prover), using two different translationsóone for action reasoning and one for temporal reasoning. The use of additional mechanical verifiers is planned. Our immediate goal is a practical system for mechanically checking proofs of behavioral properties of a concurrent system; we assume ordinary properties of the data structures used by the system."
1991,"Preserving Liveness: Comments on ""Safety and Liveness from a Methodological Point of View"".","The anomaly is that a liveness property, which should constrain only infinite behavior, can implicitly rule out some finite behaviors. We agree that most reasonable specifications will be written in the form recommended by Dederichs and Weber. As observed by Abadi and Lamport [1], who called specifications having this form machine closed, one tries to write liveness properties that ì[do] not rule out any finite behavior.î As pointed out by Apt, Francez, and Katz [3], who defined a fairness condition for a programming language to be feasible if it produces machine-closed specifications for all programs, feasibility is necessary to ìprevent a scheduler from ëpainting itself into a cornerí î."
1991,The Existence of Refinement Mappings.,"Abstract
Refinement mappings are used to prove that a lower-level specification correctly implements a higher-level one. We consider specifications consisting of a state machine (which may be infinite- state) that specifies safety requirements, and an arbitrary supplementary property that specifies liveness requirements. A refinement mapping from a lower-level specification S1 to a higher-level one S2 is a mapping from S1's state space to S2's state space. It maps steps of S1's state machine to steps of S2's state machine and maps behaviors allowed by S1 to behaviors allowed by S2. We show that, under reasonable assumptions about the specification, if S1 implements S2, then by adding auxiliary variables to S1 we can guarantee the existence of a refinement mapping. This provides a completeness result for a practical, hierarchical specification method."
1991,An Old-Fashioned Recipe for Real Time.,"Abstract
Traditional methods for specifying and reasoning about concurrent systems work for real-time systems. However, two problems arise: the real-time programming version of Zeno's paradox, and circularity in composing real-time assumption/guarantee specifications. Their solutions rest on properties of machine closure and realizability. TLA (the temporal logic of actions) provides a formal framework for the exposition."
1990,A Theorem on Atomicity in Distributed Algorithms.,"Abstract
Reasoning about a distributed algorithm is simplified if we can ignore the time needed to send and deliver messages and can instead pretend that a process sends a collection of messages as a single atomic action, with the messages delivered instantaneously as part of the action. A theorem is derived that proves the validity of such reasoning for a large class of algorithms. It generalizes and corrects a well-known folk theorem about when an operation in a multiprocess program can be considered atomic."
1990,Concurrent Reading and Writing of Clocks.,"As an exercise in synchronization without mutual exclusion, algorithms are developed to implement both a monotonic and a cyclic multiple-word clock that is updated by one process and read by one or more other processes.
"
1990,win and sin: Predicate Transformers for Concurrency.,The weakest liberal precondition and strongest postcondition predicate transformers are generalized to the weakest invariant and strongest invariant. These new predicate transformers are useful for reasoning about concurrent programs containing operations in which the grain of atomicity is unspecified. They can also be used to replace behavioural arguments with more rigorous assertional ones.
1989,A Simple Approach to Specifying Concurrent Systems.,"In the transition axiom method, safety properties of a concurrent system
can be specified by programs; liveness properties are specified by assertions
in a simple temporal logic. The method is described with some simple
examples, and its logical foundation is informally explored through a careful
examination of what it means to implement a specification. Language issues
and other practical details are largely ignored."
1989,Realizable and Unrealizable Specifications of Reactive Systems.,n/a
1989,Composing Specifications.,"Abstract
A rigorous modular specification method requires a proof rule asserting that if each component behaves correctly in isolation, then it behaves correctly in concert with other components. Such a rule is subtle if a component need behave correctly only when its environment does, since each component is part of the others' environments. We examine the precise distinction between a system and its environment, and provide the requisite proof rule when modules are specified with safety and liveness properties."
1988,Control Predicates are Better than Dummy Variables for Reasoning about Program Control.,"When explicit control predicates rather than dummy variables are used, the Owicki-Gries method for proving safety properties of concurrent programs can be strengthened, making it easier to construct the required program annotations.
"
1988,While Waiting for the Millennium: Formal Specification and Verficiation of Concurrent Systems Now (Abstract).,n/a
1988,The Existence of Refinement Mappings.,"Abstract:
Refinement mappings are used to prove that a lower-level specification correctly implements a higher-level one. The authors consider specifications consisting of a state machine (which may be infinite-state) that specifies safety requirements and an arbitrary supplementary property that specifies liveness requirements. A refinement mapping from a lower-level specification S/sub 1/ to higher-level one S/sub 2/ is a mapping from S/sub 1/'s state space to S/sub 2/'s state space that maps steps of S/sub 1/'s state machine steps to steps of S/sub 2/'s state machine and maps behaviors allowed by S/sub 1/ to behaviors allowed by S/sub 2/. It is shown that under reasonable assumptions about the specifications, if S/sub 1/ implements S/sub 2/, then by adding auxiliary variables to S/sub 1/ one can guarantee the existence of a refinement mapping. This provides a completeness result for a practical hierarchical specification method.< >"
1988,A Lattice-Structured Proof of a Minimum Spanning.,"Highly-optimized concurrent algorithms are often hard to prove correct because they have no natural decomposition into separately provable parts. This paper presents a proof technique for the modular verification of such non-modular algorithms. It generalizes existing verification techniques based on a totally-ordered hierarchy of refinements to allow a partiallyordered hierarchy-that is: a lattice of different views of the algorithm. The technique is applied to the well-known distributed minimum spanning tree algorithm of Gallager, Humblet and Spira, which has until recently lacked a rigorous proof."
1987,A Fast Mutual Exclusion Algorithm.,"A new solution to the mutual exclusion problem is presented that, in the absence of contention, requires only seven memory accesses. It assumes atomic reads and atomic writes to shared registers.
"
1986,On Interprocess Communication. Part I: Basic Formalism.,"Abstract
A formalism for specifying and reasoning about concurrent systems is described. Unlike more conventional formalisms, it is not based upon atomic actions. A definition of what it means for one system to implement a higher-level system is given and justified. In Part II, the formalism is used to specify several classes of interprocess communication mechanisms and to prove the correctness of algorithms for implementing them."
1986,On Interprocess Communication. Part II: Algorithms.,"Abstract
Interprocess communication is studied without assuming any lower-level communication primitives. Three classes of communication registers are considered, and several constructions are given for implementing one class of register with a weaker class. The formalism developed in Part I is used in proving the correctness of these constructions."
1986,The mutual exclusion problem: part I - a theory of interprocess communication.,"A novel formal theory of concurrent systems that does not assume any atomic operations is introduced. The execution of a concurrent program is modeled as an abstract set of operation executions with two temporal ordering relations: ìprecedenceî and ìcan causally affectî. A primitive interprocess communication mechanism is then defined. In Part II, the mutual exclusion is expressed precisely in terms of this model, and solutions using the communication mechanism are given.
"
1986,The mutual exclusion problem: partII - statement and solutions.,"Interprocess communication is studied without assuming any lower-level communication primitives. Three classes of communication registers are considered, and several constructions are given for implementing one class of register with a weaker class. The formalism developed in Part I is used in proving the correctness of these constructions.
"
1986,Byzantine Clock Synchronization.,"An informal description is given of three fault-tolerant clock-synchronization algorithms. These algorithms work in the presence of arbitrary kinds of failure, including ""two-faced"" clocks. Two of the algorithms are derived from Byzantine Generals solutions.
"
1985,Synchronizing Clocks in the Presence of Faults.,"Algorithms are described for maintaining clock synchrony in a distributed multiprocess system where each process has its own clock. These algorithms work in the presence of arbitrary clock or process failures, including ìtwo-faced clocksî that present different values to different processes. Two of the algorithms require that fewer than one-third of the processes be faulty. A third algorithm works if fewer than half the processes are faulty, but requires digital signatures.
"
1985,"Solved Problems, Unsolved Problems and Non-Problems in Concurrency.","This is an edited transcript of a talk given at last year's conference. To preserve the flavor of the talk and the questions, I have done very little editing---mostly eliminating superfluous words and phrases, correcting especially atrocious grammar, and making the obvious changes needed when replacing slides by figures. The tape recorder was not functioning for the first few minutes, so I had to recreate the beginning of the talk.
"
1985,Distributed Snapshots: Determining Global States of Distributed Systems.,"This paper presents an algorithm by which a process in a distributed system determines a global state of the system during a computation. Many problems in distributed systems can be cast in terms of the problem of detecting global states. For instance, the global state detection algorithm helps to solve an important class of problems: stable property detection. A stable property is one that persists: once a stable property becomes true it remains true thereafter. Examples of stable properties are ìcomputation has terminated,î ì the system is deadlockedî and ìall tokens in a token ring have disappeared.î The stable property detection problem is that of devising algorithms to detect a given stable property. Global state detection can also be used for checkpointing.
"
1985,What It Means for a Concurrent Program to Satisfy a Specification: Why No One Has Specified Priority.,"The formal correspondence between an implementation and its specification is examined. It is shown that existing specifications that claim to describe priority are either vacuous or else too restrictive to be implemented in some reasonable situations. This is illustrated with a precisely formulated problem of specifying a first-come-first-served mutual exclusion algorithm, which it is claimed cannot be solved by existing methods.
"
1985,Constraints: A Uniform Approach to Aliasing and Typing.,"A constraint is a relation among program variables that is maintained throughout execution. Type declarations and a very general form of aliasing can be expressed as constraints. A proof system based upon the interpretation of Hoare triples as temporal logic formulas is given for reasoning about programs with constraints. The proof system is shown to be sound and relatively complete, and example program proofs are given.
"
1984,Using Time Instead of Timeout for Fault-Tolerant Distributed Systems.,"A general method is described for implementing a distributed system with any desired degree of fault-tolerance. Instead of relying upon explicit timeouts, processes execute a simple clock-driven algorithm. Reliable clock synchronization and a solution to the Byzantine Generals Problem are assumed."
1984,"The ""Hoare Logic"" of CSP, and All That.","Generalized Hoare logic is a formal logical system for deriving invariance properties of programs. It provides a uniform way to describe a variety of methods for reasoning about concurrent programs, including noninterference, satisfaction, and cooperation proofs. The authors describe a simple meta-rule of the generalized Hoare logic-the decomposition principle-show how all these methods can be derived using it. "
1984,Basic Concepts.,n/a
1984,Formal Foundation for Specification and Verification.,n/a
1984,Paradigms for Distributed Programs.,n/a
1984,Byzantine Clock Synchronization.,"An informal description is given of three fault-tolerant clock-synchronization algorithms. These algorithms work in the presence of arbitrary kinds of failure, including ìtwo-facedî clocks. Two of the algorithms are derived from Byzantine Generals solutions.
"
1983,The Weak Byzantine Generals Problem.,"The Byzantine Generals Problem requires processes to reach agreement upon a value even though some of them may fad. It is weakened by allowing them to agree upon an ""incorrect"" value if a failure occurs. The transaction eormmt problem for a distributed database Js a special case of the weaker problem. It is shown that, like the original Byzantine Generals Problem, the weak version can be solved only ff fewer than one-third of the processes may fad. Unlike the onginal problem, an approximate solution exists that can tolerate arbaranly many failures."
1983,Specifying Concurrent Program Modules.,"A method for specifying program modules in a concurrent program is described. It is based upon temporal logic, but uses new kinds of temporal assertions to make the specifications simpler and easier to understand. The semantics of the specifications is described informally, and a sequence of examples are given culminating in a specification of three modules comprising the alternating-bit communication protocol. A formal semantics is given in the appendix. "
1983,Problems from the Workshop on the Analysis of Concurrent Systems.,n/a
1983,What Good is Temporal Logic?,"Temporal logic is a formal system for specifying and reasoning about concurrent programs. It provides a uniform framework for describing a system at any level of abstraction, thereby supporting hierarchical specification and verification."
1983,Reasoning About Nonatomic Operations.,"A method is presented that permits assertional reasoning about a concurrent program even though the atomicity of the elementary operations is left unspecified. It is based upon a generalization of the dynamic logic operator [?]. The method is illustrated by verifying the mutual exclusion property for a two-process version of the bakery algorithm.
"
1982,An Assertional Correctness Proof of a Distributed Algorithm.,"Abstract
Using ordinary assertional methods for concurrent program verification, we prove the correctness of a distributed algorithm for maintaining message-routing tables in a network with communication lines that can fail. This shows that assertional reasoning about global states works well for distributed as well as nondistributed algorithms."
1982,The Byzantine Generals Problem.,"Reliable computer systems must handle malfunctioning components that give conflicting information to different parts of the system. This situation can be expressed abstractly in terms of a group of generals of the Byzantine army camped with their troops around an enemy city. Communicating only by messenger, the generals must agree upon a common battle plan. However, one or more of them may be traitors who will try to confuse the others. The problem is to find an algorithm to ensure that the loyal generals will reach agreement. It is shown that, using only oral messages, this problem is solvable if and only if more than two-thirds of the generals are loyal; so a single traitor can confound two loyal generals. With unforgeable written messages, the problem is solvable for any number of generals and possible traitors. Applications of the solutions to reliable computer systems are then discussed."
1982,Proving Liveness Properties of Concurrent Programs.,"A liveness property asserts that program execution eventually reaches some desirable state. While termination has been studied extensively, many other liveness properties are important for concurrent programs. A formal proof method, based on temporal logic, for deriving liveness properties is presented. It allows a rigorous formulation of simple informal arguments. How to reason with temporal logic and how to use safety (invariance) properties in proving liveness is shown. The method is illustrated using, first, a simple programming language without synchronization primitives, then one with semaphores. However, it is applicable to any programming language."
1981,Password Authentification with Insecure Communication.,"A method of user password authentication is described which is secure even if an intruder can read the system's data, and can tamper with or eavesdrop on the communication between the user and the system. The method assumes a secure one-way encryption function and can be implemented with a microcomputer in the user's terminal.
"
1981,TIMESETS -- A New Method for Temporal Reasoning about Programs.,n/a
1981,Program Logics and Program Verification (position paper).,n/a
1980,The 'Hoare Logic' of Concurrent Programs.,"Hoare's logical system for specifying and proving partial correctness properties of sequential programs is generalized to concurrent programs. The basic idea is to define the assertion {P} S {Q} to mean that if execution is begun anywhere in S with P true, then P will remain true until S terminates, and Q will be true if and when S terminates. The predicates P and Q may depend upon program control locations as well as upon the values of variables. A system of inference rules and axiom schemas is given, and a formal correctness proof for a simple program is outlined. We show that by specifying certain requirements for the unimplemented parts, correctness properties can be proved without completely implementing the program. The relation to Pnueli's temporal logic formalism is also discussed.
"
1980,Reaching Agreement in the Presence of Faults.,"The problem addressed here concerns a set of isolated processors, some unknown subset of which may be faulty, that communicate only by means of two-party messages. Each nonfaulty processor has a private value of information that must be communicated to each other nonfaulty processor. Nonfaulty processors always communicate honestly, whereas faulty processors may lie. The problem is to devise an algorithm in which processors communicate their own values and relay values received from others that allows each nonfaulty processor to infer a value for each other processor. The value inferred for a nonfaulty processor must be that processor's private value, and the value inferred for a faulty one must be consistent with the corresponding value inferred by each other nonfaulty processor.
It is shown that the problem is solvable for, and only for, n ? 3m + 1, where m is the number of faulty processors and n is the total number. It is also shown that if faulty processors can refuse to pass on information but cannot falsely relay information, the problem is solvable for arbitrary n ? m ? 0. This weaker assumption can be approximated in practice using cryptographic methods."
1980,"""Sometime"" is Sometimes ""Not Never"" - On the Temporal Logic of Programs.","Pnueli [15] has recently introduced the idea of using temporal logic [18] as the logical basis for proving correctness properties of concurrent programs. This has permitted an elegant unifying formulation of previous proof methods. In this paper, we attempt to clarify the logical foundations of the application of temporal logic to concurrent programs. In doing so, we will also clarify the relation between concurrency and nondeterminism, and identify some problems for further research.In this paper, we consider logics containing the temporal operators ""henceforth"" (or ""always"") and ""eventually"" (or ""sometime""). We define the semantics of such a temporal logic in terms of an underlying model that abstracts the fundamental concepts common to almost all the models of computation which have been used. We are concerned mainly with the semantics of temporal logic, and will not discuss in any detail the actual rules for deducing theorems.We will describe two different temporal logics for reasoning about a computational model. The same formulas appear in both logics, but they are interpreted differently. The two interpretations correspond to two different ways of viewing time: as a continually branching set of possibilities, or as a single linear sequence of actual events. The temporal concepts of ""sometime"" and ""not never"" (""not always not"") are equivalent in the theory of linear time, but not in the theory of branching time -- hence, our title. We will argue that the logic of linear time is better for reasoning about concurrent programs, and the logic of branching time is better for reasoning about nondeterministic programs.The logic of linear time was used by Pnueli in [15], while the logic of branching time seems to be the one used by most computer scientists for reasoning about temporal concepts. We have found this to cause some confusion among our colleagues, so one of our goals has been to clarify the formal foundations of Pnueli's work.The following section gives an intuitive discussion of temporal logic, and Section 3 formally defines the semantics of the two temporal logics. In Section 4, we prove that the two temporal logics are not equivalent, and discuss their differences. Section 5 discusses the problems of validity and completeness for the temporal logics. In Section 6, we show that there are some important properties of the computational model that cannot be expressed with the temporal operators ""henceforth"" and ""eventually"", and define more general operators.
"
1979,On the Proof of Correctness of a Calendar Program.,"A formal specification is given for a simple calendar program, and the derivation and proof of correctness of the program are sketched. The specification is easy to understand, and its correctness is manifest to humans."
1979,How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs.,"Abstract:
Many large sequential computers execute operations in a different order than is specified by the program. A correct execution is achieved if the results produced are the same as would be produced by executing the program steps in order. For a multiprocessor computer, such a correct execution by each processor does not guarantee the correct execution of the entire program. Additional conditions are given which do guarantee that a computer correctly executes multiprocess programs."
1979,A New Approach to Proving the Correctness of Multiprocess Programs.,"A new, nonassertional approach to proving multiprocess program correctness is described by proving the correctness of a new algorithm to solve the mutual exclusion problem. The algorithm is an improved version of the bakery algorithm. It is specified and proved correct without being decomposed into indivisible, atomic operations. This allows two different implementations for a conventional, nondistributed system. Moreover, the approach provides a sufficiently general specification of the algorithm to allow nontrivial implementations for a distributed system as well.
"
1978,"Time, Clocks, and the Ordering of Events in a Distributed System.","The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become."
1978,On-the-Fly Garbage Collection: An Exercise in Cooperation.,"As an example of cooperation between sequential processes with very little mutual interference despite frequent manipulations of a large shared data space, a technique is developed which allows nearly all of the activity needed for garbage detection and collection to be performed by an additional processor operating concurrently with the processor devoted to the computation proper. Exclusion and synchronization constraints have been kept as weak as could be achieved; the severe complexities engendered by doing so are illustrated.
"
1978,The Implementation of Reliable Distributed Multiprocess Systems.,"Abstract
A method is described for implementing any system by a network of processes so it continues to function properly despite the failure or malfunction of individual processes and communication arcs; where ‚Äúmalfunction‚Äù means doing something incorrectly, and ‚Äúfailure‚Äù means doing nothing. The system is defined in terms of a sequential ‚Äúuser machine‚Äù, and a precise correctness condition for the implementation of this user machine is given. An algorithm to implement the user machine in the absence of malfunctioning, and a rigorous proof of its correctness, are given for a network of three processes with perfect clocks. The generalization to an arbitrary network of processes with imperfect clocks is described. It is briefly indicated how malfunctioning can be handled by adding redundant checking to the implementation and including error detection and correction mechanisms in the user machine."
1978,The specification and proof of correctness of interactive programs.,"Abstract
A method of specifying interactive programs by production rules is described, and the Floyd-Hoare assertional method is modified to permit one to prove that a program correctly implements its specification. A program to accept and format typed input is formally specified, and its implementation with a TECO program is proved correct."
1977,Concurrent Reading and Writing.,"The problem of sharing data among asynchronous processes is considered. It is assumed that only one process at a time can modify the data, but concurrent reading and writing is permitted. Two general theorems are proved, and some algorithms are presented to illustrate their use. These include a solution to the general problem in which a read is repeated if it might have obtained an incorrect result, and two techniques for transmitting messages between processes. These solutions do not assume any synchronizing mechanism other than data which can be written by one process and read by other processes.
"
1977,Proving the Correctness of Multiprocess Programs.,"Abstract:
The inductive assertion method is generalized to permit formal, machine-verifiable proofs of correctness for multiprocess programs. Individual processes are represented by ordinary flowcharts, and no special synchronization mechanisms are assumed, so the method can be applied to a large class of multiprocess programs. A correctness proof can be designed together with the program by a hierarchical process of stepwise refinement, making the method practical for larger programs. The resulting proofs tend to be natural formalizations of the informal proofs that are now used."
1976,The Synchronization of Independent Processes.,"This paper considers the problem of programming a multiple process system so that it continues to operate despite the failure of individual processes. A powerful synchronizing primitive is defined, and it is used to solve some sample problems. An algorithm is then given which implements this primitive under very weak assumptions about the nature of interprocess communication, and a careful informal proof of its correctness is given.
"
1975,Multiple Byte Processing with Full-Word Instructions.,"A method is described which allows parallel processing of packed data items using only ordinary full-word computer instructions, even though the processing requires operations whose execution is contingent upon the value of a datum. It provides a useful technique for processing small data items such as alphanumeric characters.
"
1975,On-the-fly garbage collection: an exercise in cooperation.,"Abstract
A technique is presented which allows nearly all of the garbage detection and collection activity to be performed by an additional processor, operating concurrently with the processor carrying out the computation proper. Exclusion and synchronization contraints between the processors have been kept weak."
1974,The Parallel Execution of DO Loops.,"Methods are developed for the parallel execution of different iterations of a DO loop. Both asynchronous multiprocessor computers and array computers are considered. Practical application to the design of compilers for such computers is discussed.
"
1974,A New Solution of Dijkstra's Concurrent Programming Problem.,"A simple solution to the mutual exclusion problem is presented which allows the system to continue to operate despite the failure of any individual component.
"
1974,The Hyperplane Method for an Array Computer.,"Abstract
Techniques are described for implementing the hyperplane method for an array computer with a limited form of memory-processor interconnection, such as the Illiac IV. A new pipelined hyperplane method is introduced. It is useful for compiling a convergent iterative computation, if the computation is programmed with a non-deterministic end of loop test."

2012,Programming Languages - Past Achievements and Future Challenges.,"The design of programming languages and their compile-time and run-time implementation are closely related, and are dependent on the underlying computational model. In the 1960s, 70s, and 80s many languages were designed, and many implementation strategies and computational models were explored. Since then, the commercial world has largely settled on a few legacy languages. Meanwhile, both the capabilities of computing systems and the ways in which they are used have changed dramatically. The panelists will summarize the lessons they have learned about language design, and also what has not been learned. They will consider how those lessons can be applied to the myriad application domains, architectural frameworks, user needs, and economic considerations that exist today, and will speculate about the future."
2010,Computer Science: A Historical Perspective and a Current Assessment.,"Abstract
We begin with a brief review of the early years of Computer Science. This period was dominated by large, remote computers and the struggle to master the complex problems of programming. The remedy was found in programming languages providing suitable abstractions and programming models. Outstanding was the language Algol 60, designed by an international committee, and intended as a publication language for algorithms. The early period ends with the advent of the microcomputer in the mid 1970s, bringing computing into homes and schools. The outstanding computer was the Alto, the first personal computer with substantial computing power. It changed the world of computing."
2008,A Brief History of Software Engineering.,"Abstract:
This personal perspective on the art of programming begins with a look at the state of programming from about 1960, and it follows programming's development through the present day. The article examines key contributions to the field of software engineering and identifies major obstacles, which persist even today."
2007,Modula-2 and Oberon.,"This is an account of the development of the languages Modula-2 and Oberon. Together with their ancestors ALGOL 60 and Pascal they form a family called Algol-like languages. Pascal (1970) reflected the ideas of structured programming, Modula-2 (1979) added those of modular system design, and Oberon (1988) catered to the object-oriented style. Thus they mirror the essential programming paradigms of the past decades. Here the major language properties are outlined, followed by an account of the respective implementation efforts. The conditions and the environments in which the languages were created are elucidated. We point out that simplicity of design was the most essential guiding principle. Clarity of concepts, economy of features, efficiency and reliability of implementations were its consequences."
2006,"Good Ideas, through the Looking Glass.","Abstract:
Computing's history has been driven by many good and original ideas, but a few turned out to be less brilliant than they first appeared. In many cases, changes in the technological environment reduced their importance. Often, commercial factors also influenced a good idea's importance. Some ideas simply turned out to be less effective and glorious when reviewed in retrospect or after proper analysis. Others were reincarnations of ideas invented earlier and then forgotten, perhaps because they were ahead of their time, perhaps because they had not exemplified current fashions and trends. And some ideas were reinvented, although they had already been found wanting in their first incarnation. Given that thorough self-critique is the hallmark of any subject claiming to be a science, computing science cannot help but benefit from a retrospective analysis and evaluation. This led author to the idea of collecting good ideas that looked less than brilliant in retrospect."
2003,Hardware/software co-design then and now.,"Abstract
Hardware/software co-design recently became a field of research and a method of development both important and fashionable. We show that it is a technique already used some decades ago, and discuss its various aspects, forms and benefits. At the same time, the advent of programmable devices is increasingly blurring the distinction between hardware and software, and thereby seems to render co-design an obvious, unavoidable strategy.
This paper is dedicated to Wlad Turski, my old colleague and faithful friend in Warsaw since the times when ‚ÄúEastern Europe‚Äù still belonged to a different world."
2003,The Essence of Programming Languages.,"Abstract
Only a few years after the invention of the first programming languages, the subject flourished and a whole flurry of languages appeared. Soon programmers had to make their choices among available languages. How were they selected; were there any criteria of selection, of language quality? What is truly essential in a programming language? In spite of the convergence to a few, wide-spread, popular languages in recent years, these questions remain relevant, and the search for a ‚Äúbetter‚Äù language continues among programmers."
2001,Embedded Systems and Real-Time Programming.,"Abstract
Although computers have been employed for decades to control machinery and entire laboratories, the term embedded system has received renewed attention and is about to establish itself as a discipline of its own. We therefore try to identify its characteristics and peculiarities. The most outstanding single item is the role of time. The addition of timing conditions to all other specifications of a system causes real-time programming to appear as a particularly difficult and challenging subject. We ask how the rapidly growing demands can be met, and emphasize that reliability must be guaranteed in view of the potentially disastrous consequences of failures upon the controlled equipment and its environment."
2000,From Programming Language Design to Computer Construction.,"From NELIAC (via ALGOL 60) to Euler and ALGOL W, to Pascal and Modula-2, and ultimately Lilith, Wirth's search for an appropriate formalism for systems programming yields intriguing insights and surprising results. "
2000,The Development of Procedural Programming Languages: Personal Contributions and Perspectives.,"Abstract
I became involved in the design of a successor of Algol 60 in the years 1962-67. The result was Algol-W (66), and later the Algol-style Pascal (70), Modula-2 (79), and Oberon (88). In turn, they introduced the concepts of data structuring and typing, modular decomposition and separate compilation, and object-orientation. In this talk, we summarize these developments and recount some of the influences and events that determined the design and implementation of these languages. In the early 60s, CS was much influenced and concentrated around programming languages. Various programming paradigms emerged; we focus on the procedural branch, directed toward system programming and forming the backbone of engineering and data processing methods and tools. I conclude with some remarks about how the gap between methods taught and methods practiced in software design might be narrowed."
1998,Hardware Compilation: Translating Programs into Circuits.,"Abstract:
Automatically translating a program specified in a programming language into a digital circuit is an idea of long standing interest. Thus far, the concept has appeared to be an uneconomical method of largely academic, but hardly practical interest. It has therefore not been pursued with vigor and consequently has remained an idealist's dream. With the increasing use of hardware description languages, however, it has become evident that hardware and software design share several traits. Hardware description languages let circuit specifications assume textual forms like programs, replacing traditional circuit diagrams with text. Increased interest in hardware compilation is largely due to the advent of large scale programmable devices. These devices can be configured on the fly, and hence be used to directly represent circuits generated through a hardware compiler. The author argues that it is now conceivable that parts of a program could be compiled into instruction sequences for a conventional processor and other parts could be compiled into circuits to be loaded onto programmable gate arrays. He advocates the development of a single language that could compile parts of a program into instruction sequences for a conventional processor and other parts into circuits for programmable gate arrays. The author points out what is better left to software and what is best implemented in hardware (namely, parallelism). The goal is to achieve a better understanding of the several important aspects that hardware and software design share, which may well be expressed in a common notation."
1996,Tasks versus Threads: An Alternative Multiprocessing Paradigm.,"An alternative to threads is presented as a paradigm for single-processor multi-tasking systems. It avoids complex and hidden mechanisms for process scheduling, and is therefore particularly suitable for real-time systems requiring fast response times, and for small systems in general. The essence of the alternative is to base processes (called tasks) on subroutines instead of coroutines. Tasks are classified according to their priority. A task may preempt, i.e. temporarily suspend, any task of lower priority. However, apart from temporary suspension, tasks run to completion. As a consequence, such a system operates with a single workspace (stack), on which workspaces of interrupted tasks are stacked. This makes the system's use of storage highly economical and efficient. We present an implementation of this concept requiring a few changes only to the basic Oberon system."
1996,"The Language Lola, FPGAs and PLDs in Teaching Digital Circuit Design.","Abstract
A language for describing digital circuits is presented, which is both simple and powerful enough for use in both practice and education. A system is described which transforms program texts into fusemaps for PLDs or into configurations of FPGAs. These devices are used in laboratory exercises to test the designed circuits ranging from simple assignments to processor architectures and communication controllers."
1995,A Plea for Lean Software.,"Abstract:
Software's girth has surpassed its functionality, largely because hardware advances make this possible. The way to streamline software lies in disciplined methodologies and a return to the essentials. The paper discusses some causes of ""fat software"" and considers the Oberon system whose primary goal was to show that software can be developed with a fraction of the memory capacity and processor power usually required, without sacrificing flexibility, functionality, or user convenience.< >"
1994,A Laboratory for a Digital Design Course Using FPGAs.,"Abstract
In our digital design laboratory we have replaced the traditional wired circuit modules by workstations equipped with an extension board containing a single FPGA. This hardware is supplemented with a set of software tools consisting of a compiler for the circuit specification language Lola, a graphical layout editor for design entry, and a checker to verify conformity of a layout with its specification in Lola. The new laboratory has been used with considerable success in digital design courses for computer science students. Not only is this solution much cheaper than collections of modules to be wired, but it also allows for more substantial and challenging exercises."
1993,Recollections about the Development of Pascal.,"Pascal was defined in 1970 and, after a slow start, became one of the most widely used languages in introductory programming courses. This article first summarises the events leading to Pascal's design and implementation, and then proceeds with a discussion of some of the language's merits and deficiencies. In the last part, developments that followed its release are recounted. Its influence chiefly derived from its being a vehicle for structured programming and a basis for further development of languages and for experiments in program verification."
1991,Differences between Oberon and Oberon-2.,"Oberonñ2 is a true extension of Oberon [1]. This paper summarizes the extensions and tries to shed some light on the motivations behind them. By that we hope to make it easier for the reader to classify Oberonñ2. For details the reader is referred to the language report. One important goal for Oberonñ2 was to make objectñoriented programming easier without sacrificing the conceptual simplicity of Oberon. After three years of using Oberon and its experimental offspring Object Oberon [2] we merged our experiences into a single refined version of Oberon. The new features of Oberonñ2 are typeñbound procedures, readñonly export of variables and record fields, open arrays as pointer base types, and a with statement with variants. The for statement is reintroduced after having been eliminated in the step from Modulañ2 to Oberon. Oberonñ2 is the result of many discussions among all members of the Institute for Computer Systems at ETH. It is particularly influenced by the ideas of Jurg Gutknecht and Josef Templ."
1991,The Programming Language Oberon-2.,"Oberonñ2 is a generalñpurpose language in the tradition of Oberon and Modulañ2. Its most important features are block structure, modularity, separate compilation, static typing with strong type checking (also across module boundaries), and type extension with typeñbound procedures. Type extension makes Oberonñ2 an objectñoriented language. An object is a variable of an abstract data type consisting of private data (its state) and procedures that operate on this data. Abstract data types are declared as extensible records. Oberonñ2 covers most terms of objectñoriented languages by the established vocabulary of imperative languages in order to minimize the number of notions for similar concepts. This report is not intended as a programmerís tutorial. It is intentionally kept concise. Its function is to serve as a reference for programmers, implementors, and manual writers. What remains unsaid is mostly left so intentionally, either because it can be derived from stated rules of the language, or because it would require to commit the definition when a general commitment appears as unwise. Appendix A defines some terms that are used to express the type checking rules of Oberonñ2. Where they appear in the text, they are written in italics to indicate their special meaning (e.g. the same type)."
1990,Ceres-Net: A Low-cost Computer Network.,"This paper describes a local?area network, its hardware and software structure, and its protocol. The principal objective was to minimize the complexity of hardware and software, yet to offer an adequate functionality and performance for a system of up to 30 workstations with local file stores. The primary benefit of the achieved simple structure and low?overhead protocol is the system's reliability.
"
1989,The Oberon System.,"In this paper we describe an operating system for a workstation designed and implemented by the authors within two and a half years. It includes memory management and module loader, a file system, a viewer system, editors for text and graphics, a compiler, a server interface and various tools. The primary motivation was to demonstrate the feasibility of a small, yet highly flexible and powerful, system, a system that is a (decimal) order of magnitude smaller than commonly used operating systems. This is possible due to regularity of concepts and concentration on the essential. The benefits are not only fewer resources needed, but elegance and generality of concepts resulting in transparency and convenience of use and increased reliability. A corner-stone of this approach is genuine extensibility, which is achieved by a new language, in particular by a facility called type extension. It allows for the integration of variables (objects) of a new, extended type in structures of elements of an existing base type."
1989,Designing a System from Scratch.,n/a
1988,From Modula to Oberon.,"The programming language Oberon is the result of a concentrated effort to increase the power of Modula?2 and simultaneously to reduce its complexity. Several features were eliminated, and a few were added in order to increase the expressive power and flexibility of the language. This paper describes and motivates the changes. The language is defined in a concise report1.
"
1988,The Programming Language Oberon.,"This is the defining report of the programming language Oberon.
"
1988,Type Extensions.,"Software systems represent a hierarchy of modules. Client modules contain sets of procedures that extend the capabilities of imported modules. This concept of extension is here applied to data types. Extended types are related to their ancestor in terms of a hierarchy. Variables of an extended type are compatible with variables of the ancestor type. This scheme is expressed by three language constructs only: the declaration of extended record types, the type test, and the type guard. The facility of extended types, which closely resembles the class concept, is defined in rigorous and concise terms, and an efficient implementation is presented."
1987,Hardware Architectures for Programming Languages and Programming Languages for Hardware Architectures.,"Programming Languages and Operating Systems introduce abstractions which allow the programmer to ignore details of an implementation. Support of an abstraction must not only concentrate on promoting the efficiency of an implementation, but also on providing the necessary guards against violations of the abstractions. In the frantic drive for efficiency the second goal has been neglected. There are indications that recent designs which are claimed to be both simple and powerful, achieve efficiency by shifting the complex issues of code generation and of appropriate guards onto compilers.Complexity has become the common hallmark of software as well as hardware designs. It cannot be mastered by the common practices of testing and simulation. Hardware design may profit from developments in programming methodology by adopting proof techniques similar to those used in programming."
1986,Microprocessor Architectures: A Comparison Based on Code Generation by Compiler.,"By carefully tuning computer and compiler, it is possible to avoid the otherwise inevitable compromises between complex compiling algorithms and less-than-optimal compiled code, where the key to performance appears to lie neither in sophisticated nor drastically reduced architectures, but in the key concepts of regularity and completeness."
1985,From Programming Language Design to Computer Construction.,"From NELIAC (via ALGOL 60) to Euler and ALGOL W, to Pascal and Modula-2, and ultimately Lilith, Wirth's search for an appropriate formalism for systems programming yields intriguing insights and surprising results."
1983,Program Development by Stepwise Refinement (Reprint).,"The creative activity of programming - to be distinguished from coding - is usually taught by examples serving to exhibit certain techniques. It is here considered as a sequence of design decisions concerning the decomposition of tasks into subtasks and of data into data structures. The process of successive refinement of specifications is illustrated by a short but nontrivial example, from which a number of conclusions are drawn regarding the art and the instruction of programming."
1981,LILITH: A personal computer for the software engineer.,"Abstract
The personal work station offers significant advantages over the large-scale, central computing facility accessed via a terminal. Among them are availability, reliability, simplicity of operation, and a high bandwidth to the user. Modern technology allows to build systems for high-level language programming with significant computing power for a reasonable price.
At the Institut fur Informatik of ETH we have designed and built such a personal computer tailored to the language Modula-2. This paper is a report on this project which encompasses language design, development of a compiler and a single-user operating system, design of an architecture suitable for compiling and yielding a high density of code, and the development and construction of the hardware. 20 Lilith computers are now in use at ETH.
A principal theme is that the requirements of software engineering influence the design of the language, and that its facilities are reflected by the architecture of the computer and the structure of the hardware. The module structure is used to exemplify this theme. That the hardware should be designed according to the programming language, instead of vice-versa, is particularly relevant in view of the trend towards VLSI technology."
1981,Lilith: A Personal Computer for the Software Engineer.,"The personal work station offers significant advantages over the large-scale, central computing facility accessed via a terminal. Among them are availability, reliability, simplicity of operation, and a high bandwidth to the user. Modern technology allows to build systems for high-level language programming with significant computing power for a reasonable price. At the Institut fur Informatik of ETH we have designed and built such a personal computer tailored to the language Modula-2. This paper is a report on this project which encompasses language design, development of a compiler and a single-user operating system, design of an architecture suitable for compiling and yielding a high density of code, and the development and construction of the hardware. 20 Lilith computers are now in use at ETH. A principal theme is that the requirements of software engineering influence the design of the language, and that its facilities are reflected by the architecture of the computer and the structure of the hardware. The module structure is used to exemplify this theme. That the hardware should be designed according to the programming language, instead of vice-versa, is particularly relevant in view of the trend towards VLSI technology."
1981,Pascal-S: A Subset and its Implementation.,"Pascal-S is a subset of the programming language Pascal selected for introductory programming courses. This report describes an implementation that is especially designed to provide comprehensive and transparent error diagnostics and economical service for large numbers of small jobs. The system consists of a compiler and an interpreter and is defined as a single, self-contained Pascal program. This machine-independent formulation in a high-level language facilitates its construction and is a prerequisite for easy portability."
1979,The Module: A System Structuring Facility in High-Level Programming Languages.,"Abstract
The key to successful programming is finding the ""right"" structure of data and program. A programming language concept called module is presented here as a means to partition systems effectively. The module allows to encapsulate local details and to specify explicitly those elements that are part of the interface between modules.
Modules as presented here are part of the language Modula-2. Problems of separate compilation and of splitting a module into definition (interface) and implementation parts are discussed."
1979,A Personal Computer Based on a High-Level Language.,"Considerations of economy have in the past led to the so-called timesharing of large computers. The premise of such systems is to project to each user the image of the entire computer being at his own exclusive disposal. This requires str ingent measures of protection on programs and data of the individual part icipants against misbehaviour of programs and malfunctions of hardware. These measures, called overhead, are not only extensive, but also expensive. "
1979,A Personal Computer Designed for Use with a High-Level Language.,"Considerations of economy have in the past led to the so-called timesharing of large computers. The premise of such systems is to project to each user the image of the entire computer being at his own exclusive disposal. This requires str ingent measures of protection on programs and data of the individual part icipants against misbehaviour of programs and malfunctions of hardware. These measures, called overhead, are not only extensive, but also expensive. "
1977,Toward a Discipline of Real-Time Programming.,"Programming is divided into three major categories with increasing complexity of reasoning in program validation: sequential programming, multiprogramming, and real-time programming. By adhering to a strict programming discipline and by using a suitable high-level language molded after this discipline, the complexity of reasoning about concurrency and execution time constraints may be drastically reduced. This may be the only practical way to make real-time systems analytically verifiable and ultimately reliable. A possible discipline is outlined and expressed in terms of the language Modula."
1977,What Can We Do about the Unnecessary Diversity of Notation for Syntactic Definitions?,"The population of programming languages is steadily growing, and there is no end of this growth in sight. Many language definitions appear in journals, many are found in technical reports, and perhaps an even greater number remains confined to proprietory circles. After frequent exposure to these definitions, one cannot fail to notice the lack of ‚Äúcommon denominators.‚Äù The only widely accepted fact is that the language structure is defined by a syntax. But even notation for syntactic description eludes any commonly agreed standard form, although the underlying ancestor is invariably the Backus-Naur Form of the Algol 60 report. As variations are often only slight, they become annoying for their very lack of an apparent motivation."
1977,Modula: a Language for Modular Multiprogramming.,"This paper defines a language called Modula, which is intended primarily for programming dedicated computer systems, including process control systems on smaller machines. The language is largely based on Pascal, but in addition to conventional block structure it introduces a so?called module structure. A module is a set of procedures, data types and variables, where the programmer has precise control over the names that are imported from and exported to the environment. Modula includes general multiprocessing facilities, namely processes, interface modules and signals. It also allows the specification of facilities that represent a computer's specific peripheral devices. Those given in this paper pertain to the PDP?11."
1977,The Use of Modula.,"Three sample programs are developed and explained with the purpose of demonstrating the use of the programming language Modula. The examples concentrate on the uses of modules, concurrent processes and synchronizing signals. In particular, they all focus on the problems of operating peripheral devices. The concurrency of their driver processes has to occur in real time. The devices include a typewriter, a card reader, a line printer, a disk, a terminal with tape cassettes and a graphical display unit. The three programs are listed in full.
"
1977,Design and Implementation of Modula.,"This paper gives an account of some design decisions made during the development of the programming language Modula. It explains the essential characteristics of its implementation on the PDP?11 computer, in particular its run?time administration of processes and the mechanism of signalling. The paper ends with some comments on the suitability of the PDP?11 for this high?level multiprogramming language.
"
1975,An Assessment of the Programming Language Pascal.,"Abstract:
The programming language Pascal is assessed in the light of `reliable programming' and with the background of five years of experience with the language. Some features are selected to point out remaining problems, either inherent or specific, from which some guidelines for the design of choice of languages for reliable programming are derived. Among the discussed features are the concept of data type, the sequential file structure and the type union."
1974,On the Composition of Well-Structured Programs.,"A professional programmer's know-how used to consist of the mastery of a set of techniques applicable to specific problems and to some specific computer. With the increase of computer power, the programmers' tasks grew more complex, and hence the need for a systematic approach became evident. Recently, the subject of programming methods, generally applicable rules and patterns of development, received considerable attention. ""Structured programming"" is the formulation of programs as hierarchical, nested structures of statements and objects of computation. We give brief examples of structured programs, show the essence of this approach, discuss its relationship with program verification, and comment on the role of structured languages."
1974,On the Design of Programming Languages.,n/a
1973,An Axiomatic Definition of the Programming Language PASCAL.,The axiomatic definition method proposed in reference [5] is extended and applied to define the meaning of the programming language PASCAL [1]. The whole language is covered with the exception of real arithmetic and go to statements. 
1971,The Programming Language Pascal.,"A programming language called Pascal is described which was developed on the basis ofALGOL 60. Compared toALGOL 60, its range of applicability is considerably increased due to a variety of data structuring facilities. In view of its intended usage both as a convenient basis to teach programming and as an efficient tool to write large programs, emphasis was placed on keeping the number of fundamental concepts reasonably small, on a simple and systematic language structure, and on efficient implementability. A one-pass compiler has been constructed for the CDC 6000 computer family; it is expressed entirely in terms of Pascal itself.
"
1971,Program Development by Stepwise Refinement.,The creative activity of programming - to be distinguished from coding - is usually taught by examples serving to exhibit certain techniques. It is here considered as a sequence of design decisions concerning the decomposition of tasks into subtasks and o
1971,The Design of a PASCAL Compiler.,"The development of a compiler for the programming language PASCAL1 is described in some detail. Design decisions concerning the layout of program and data, the organization of the compiler including its syntax analyser, and the over?all approach to the project are discussed. The compiler is written in its own language and was implemented for the CDC 6000 computer family. The reader is expected to be familiar with Reference 1.
"
1969,"On multiprogramming, machine coding, and computer organization.","The author feels that the interrupt feature which is available in most modern computers is a potent source of programming pitfalls and errors, and that it therefore may heavily contribute to the unreliability of programs making use of it. A programming scheme is presented which avoids the concept of the interrupt and permits the specification of concurrent (or pseudoconcurrent) activities in a supposedly more perspicuous manner. It is intended to serve as a basis for the construction of operating systems, which are prime examples of programs with concurrent activities. The scheme includes a set of basic instructions for the generation, termination, and synchronization of parallel processes. A set of routines representing these instructions and thereby simulating a hypothetical machine organization has been implemented and tested on the IBM System/360. Two programs using these instructions, written in PL360, are presented."
1968,"PL360, a Programming Language for the 360 Computers.","A programming language for the IBM 360 computers and aspects of its implementation are described. The language, called PL360, provides the facilities of a symbolic machine language, but displays a structure defined by a recursive syntax. PL360 was designed to improve the readability of programs which must take into account specific characteristics and limitations of a particular computer. It represents an attempt to further the state of the art of programming by encouraging and even forcing the programmer to improve his style of exposition and his principles and discipline in program organization. Because of its inherent simplicity, the language is particularly well suited for tutorial purposes. The attempt to present a computer as a systematically organized entity is also hoped to be of interest to designers of future computers."
1966,EULER: a generalization of ALGOL and it formal definition: Part 1.,"A method for defining programming languages is developed which introduces a rigorous relationship between structure and meaning. The structure of a language is defined by a phrase structure syntax, the meaning in terms of the effects which the execution of a sequence of interpretation rules exerts upon a fixed set of variables, called the Environment. There exists a one-to-one correspondence between syntactic rules and interpretation rules, and the sequence of corresponding syntactic reductions which constitute a parse. The individual interpretation rules are explained in terms of an elementary and obvious algorithmic notation. A constructive method for evaluating a text is provided, and for certain decidable classes of languages their unambiguity is proved. As an example, a generalization of ALGOL is described in full detail to demonstrate that concepts like block-structure, procedures, parameters, etc can be defined adequately and precisely by this method."
1966,"EULER: a generalization of ALGOL, and its formal definition: Part II.","In this section the algorithmic language EULER is described first informally and then formally by its syntax and semantics. An attempt has been made to generalize and extend some of the concepts of ALGOL, thus creating a language which is simpler and yet more flexible than ALGOL 60. A second objective in developing this language was to show that a useful programming language which can be processed with reasonable efficiency can be defined in rigorous formality."
1966,"A note on ""Program structures for parallel processing"".",n/a
1966,A contribution to the development of ALGOL.,"A programming language similar in many respects to ALGOL 60, but incorporating a large number of improvements based on six years' experience with that language, is described in detail. Part I consists of an introduction to the new language and a summary of the changes made to ALGOL 60, together with a discussion of the motives behind the revisions. Part II is a rigorous definition of the proposed language. Part III describes a set of proposed standard procedures to be used with the language, including facilities for input/output."
1965,Algorithm 249: outreal N [15].,n/a
1965,Automatic grading programs.,"Two ALGOL grader programs are presented for the computer evaluation of student ALGOL programs. One is for a beginner's program; it furnishes random data and checks answers. The other provides a searching test of the reliability and efficiency of an integration procedure. There is a statement of the essential properties of a computer system, in order that grader programs can be effectively used."
1965,Algorithm 265: find precedence functions [L2].,n/a
1964,Certification of algorithm 146: Multiple integration.,n/a
1963,A syntactic description of BC NELIAC.,n/a
1963,A generalization of ALGOL.,n/a

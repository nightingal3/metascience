2019,From Real-time Logic to Timed Automata.,"We show how to construct temporal testers for the logic MITL, a prominent linear-time logic for real-time systems. A temporal tester is a transducer that inputs a signal holding the Boolean value of atomic propositions and outputs the truth value of a formula along time. Here we consider testers over continuous-time Boolean signals that use clock variables to enforce duration constraints, as in timed automata. We first rewrite the MITL formula into a ‚Äúsimple‚Äù formula using a limited set of temporal modalities. We then build testers for these specific modalities and show how to compose testers for simple formulae into complex ones. Temporal testers can be turned into acceptors, yielding a compositional translation from MITL to timed automata. This construction is much simpler than previously known and remains asymptotically optimal. It supports both past and future operators and can easily be extended."
2012,"Low dimensional hybrid systems - decidable, undecidable, don't know.","Even though many attempts have been made to define the boundary between decidable and undecidable hybrid systems, the affair is far from being resolved. More and more low dimensional systems are being shown to be undecidable with respect to reachability, and many open problems in between are being discovered. In this paper, we present various two-dimensional hybrid systems for which the reachability problem is undecidable. We show their undecidability by simulating Minsky machines. Their proximity to the decidability frontier is understood by inspecting the most parsimonious constraints necessary to make reachability over these automata decidable. We also show that for other two-dimensional systems, the reachability question remains unanswered, by proving that it is as hard as the reachability problem for piecewise affine maps on the real line, which is a well known open problem.
"
2012,Verification of multi-linked heaps.,"We define the class of single-parent heap systems, which rely on a singly-linked heap in order to model destructive updates on tree structures. This encoding has the advantage of relying on a relatively simple theory of linked lists in order to support abstraction computation. To facilitate the application of this encoding, we provide a program transformation that, given a program operating on a multi-linked heap without sharing, transforms it into one over a single-parent heap. It is then possible to apply shape analysis by predicate and ranking abstraction. The technique has been successfully applied on examples with lists (reversal and bubble sort) and trees with of fixed arity (balancing of, and insertion into, a binary sort tree).
"
2012,Synthesis of Reactive(1) designs.,"We address the problem of automatically synthesizing digital designs from linear-time specifications. We consider various classes of specifications that can be synthesized with effort quadratic in the number of states of the reactive system, where we measure effort in symbolic steps. The synthesis algorithm is based on a novel type of game called General Reactivity of rank 1 (gr(1)), with a winning condition of the form  is a Boolean combination of atomic propositions. We show symbolic algorithms to solve this game, to build a winning strategy and several ways to optimize the winning strategy and to extract a system from it. We also show how to use gr(1) games to solve the synthesis of ltl specifications in many interesting cases. As empirical evidence to the generality and efficiency of our approach we include a significant case study. We describe the formal specifications and the synthesis process applied to a bus arbiter, which is a realistic industrial hardware specification of modest size.
"
2012,Once and for all.,"It has long been known that past-time operators add no expressive power to linear temporal logics. In this paper, we consider the extension of branching temporal logics with past-time operators. Two possible views regarding the nature of past in a branching-time model induce two different such extensions. In the first view, past is branching and each moment in time may have several possible futures and several possible pasts. In the second view, past is linear and each moment in time may have several possible futures and a unique past. Both views assume that past is finite. We discuss the practice of these extensions as specification languages, characterize their expressive power, and examine the complexity of their model-checking and satisfiability problems.
"
2012,Effective Synthesis of Asynchronous Systems from GR(1) Specifications.,"Abstract
We consider automatic synthesis from linear temporal logic specifications for asynchronous systems. We aim the produced reactive systems to be used as software in a multi-threaded environment. We extend previous reduction of asynchronous synthesis to synchronous synthesis to the setting of multiple input and multiple output variables. Much like synthesis for synchronous designs, this solution is not practical as it requires determinization of automata on infinite words and solution of complicated games. We follow advances in synthesis of synchronous designs, which restrict the handled specifications but achieve scalability and efficiency. We propose a heuristic that, in some cases, maintains scalability for asynchronous synthesis. Our heuristic can prove that specifications are realizable and extract designs. This is done by a reduction to synchronous synthesis that is inspired by the theoretical reduction."
2010,Towards Component Based Design of Hybrid Systems: Safety and Stability.,"Abstract
We propose a library based incremental design methodology for constructing hybrid controllers from a component library of models of hybrid controllers, such that global safety and stability properties are preserved. To this end, we propose hybrid interface specifications of components characterizing plant regions for which safety and stability properties are guaranteed, as well as exception mechanisms allowing safe and stability-preserving transfer of control whenever the plant evolves towards the boundary of controllable dynamics. We then propose a composition operator for constructing hybrid automata from a library of such pre-characterized components supported by compositional and automatable proofs of hybrid interface specifications."
2010,Proving the Refuted: Symbolic Model Checkers as Proof Generators.,"Abstract
The paper presents an automatic method to derive a deductive proof of response properties from symbolic model checking. The method is based on a new proof rule for response properties that deals directly with compassion (strong fairness). The method can be applied to infinite-state systems. In particular, model checking of response of (predicate- and ranking-) abstracted heap programs is automatically transformed into a deductive proof for the concrete heap system. All examples presented in the paper were run in tlv."
2010,Temporal Verification of Reactive Systems: Response.,"Abstract
Nearly twenty years ago, Amir and I (ZM) decided to write a series of three volumes summarizing the state of the art (at that time) on the verification of Reactive Systems using Temporal Logic techniques."
2010,Jtlv: A Framework for Developing Verification Algorithms.,"Abstract
Jtlv is a computer-aided verification scripting environment offering state-of-the-art Integrated Developer Environment for algorithmic verification applications. Jtlv may be viewed as a new, and much enhanced Tlv [18], with Java rather than Tlv-basic as the scripting language. JTLV attaches its internal parsers as an Eclipse editor, and facilitates a rich, common, and abstract verification developer environment that is implemented as an Eclipse plugin."
2010,Revisiting Synthesis of GR(1) Specifications.,"Abstract
The last few years have seen a rising interest in the problem of synthesizing systems from temporal logic specifications. One major contributor to this is the recent work of Piterman et al., which showed how polynomial time synthesis could be achieved for a class of LTL specifications that is large enough and expressive enough to cover an extensive number of complex, real-world, applications (despite a known doubly-exponential time lower bound for general LTL formulae). That approach has already been used extensively for the synthesis of various applications and as basis for further theoretical work on synthesis.
Here, we expose a fundamental flaw in the initial processing of specifications in that paper and demonstrate how it may produce incorrect results, declaring that specifications could not be synthesized when, in fact, they could. We then identify a class of specifications for which this initial processing is sound and complete. Thus, giving an insight to the reason that this problem arises in the first place. We also show that it can be easily checked whether specifications belong to the sound and complete class by using the same synthesis techniques. Finally, we show in the cases that specifications do not fall into this category how to modify them so that their processing is, indeed, both sound and complete."
2009,Controller Synthesis from LSC Requirements.,"Abstract
Live Sequence Charts (LSCs) is a visual requirements language for specifying reactive system behavior. When modeling and designing open reactive systems, it is often essential to have a guarantee that the requirements can be satisfied under all possible circumstances. We apply results in the area of controller synthesis to a subset of the LSC language to decide the realizability of LSC requirements. If realizable, we show how to generate system responses that are guaranteed to satisfy the requirements. We discuss one particular implementation of this result which is formulated as an extension of smart play-out, a method for direct execution of scenario-based requirements."
2009,Synthesis of programs from temporal property specifications.,"Abstract:
The paper investigates a development process for reactive programs, in which the program is automatically generated (synthesized) from a high-level temporal specification. The method is based on previous results that proposed a similar synthesis method for the automatic construction of hardware designs from their temporal specifications. Thus, the work reported here can be viewed as a generalization of existing methods for the synthesis of synchronous reactive systems into the synthesis of asynchronous systems. In the synchronous case it was possible to identify a restricted subclass of formulas and present an algorithm that solves the synthesis problem for these restricted specifications in polynomial time. Here the results are less definitive in the sense that we can offer some heuristics that may provide polynomial-time solutions only in some of the cases."
2008,A Sound and Complete Deductive System for CTL* Verification.,"The paper presents a compositional approach to the verification of CTL* properties over reactive systems. Both symbolic model-checking (SMC) and deductive verification are considered. Both methods are based on two decomposition principles. A general state formula is decomposed into basic state formulas which are CTL* formulas with no embedded path quantifiers. To deal with arbitrary basic state formulas, we introduce another reduction principle which replaces each basic path formula, i.e., path formulas whose principal operator is temporal and which contain no embedded temporal operators or path quantifiers, by a newly introduced boolean variable which is added to the system. Thus, both the algorithmic and the deductive methods are based on two statification transformations which successively replace temporal formulas by assertions which contain no path quantifiers or temporal operators. Performing these decompositions repeatedly, we remain with basic assertional formulas, i.e., formulas of the form Efp and Afp for some assertion p. In the model-checking method we present a single symbolic algorithm to verify both universal and existential basic assertional properties. In the deductive method we present a small set of proof rules and show that this set is sound and relatively complete for verifying universal and existential basic assertional properties over reactive systems. Together with two proof rules for the decompositions, we obtain a sound and relatively complete proof system for arbitrary CTL* properties. Interestingly, the deductive approach for CTL* presented here, offers a viable new approach to the deductive verification of arbitrary LTL formulas.
The paper corrects a previous preliminary version of a deductive system for CTL*, in which some of the rules were unsound. The correction is based on the introduction of a new type of temporal testers which are guaranteed to be non blocking. That is, when composed with a deadlock-free system, which is a key operation in the verification process, the resulting composed system is guaranteed to remain deadlock free.
"
2008,Using Abstraction to Verify Arbitrary Temporal Properties.,"Abstract:
Summary form only given. It is a known fact that finitary state abstraction methods (i.e. methods in which the abstract domain is finite), such as predicate abstraction, are inadequate for verifying general liveness properties or even termination of sequential programs. In this talk we will present an abstraction approach called ranking abstraction which is sound and complete for verifying all temporally specified properties, including all liveness properties. We will start by presenting a general simple framework for state abstraction emphasizing that, in order to get soundness, it is necessary to apply an over-approximating abstraction to the system and an under-approximating abstraction to the (temporal) property. We show that finitary version of this abstraction are complete for verifying all safety properties. We also show examples of simple programs whose termination provably cannot be established by finitary abstraction. We then consider abstraction approaches to the verification of deadlock freedom, presenting some sufficient conditions guaranteeing that deadlock freedom is inherited from the concrete to the abstract. Finally, we introduce the method of ranking abstraction and illustrate its application to the verification of termination and more general liveness properties. In this presentation we emphasize the similarity between predicate abstraction and its extension into ranking abstraction. In particular, the fact that the user does not have to provide a full ranking function but only to specify the ingredients from which such a function can be constructed. We also sketch how abstraction refinement can be applied to ranking abstraction, thus opening the way to a CEGAR-like methodology. Time permitting, we will present a brief comparison between ranking abstraction and the methods of transition abstraction developed by Podelski, Rybalchenko, and Cook which underly the Terminator system. The talk is based on results obtained through joint research with I....
(View more)"
2008,"Checking Temporal Properties of Discrete, Timed and Continuous Behaviors.","Abstract
We survey some of the problems associated with checking whether a given behavior (a sequence, a Boolean signal or a continuous signal) satisfies a property specified in an appropriate temporal logic and describe two such monitoring algorithms for the real-time logic MITL."
2008,Mechanical Verification of Transactional Memories with Non-transactional Memory Accesses.,"Abstract
Transactional memory is a programming abstraction intended to simplify the synchronization of conflicting memory accesses (by concurrent threads) without the difficulties associated with locks. In a previous work we presented a formal framework for proving that a transactional memory implementation satisfies its specifications and provided with model checking verification of some using small instantiations. This paper extends the previous work to capture non-transactional accesses to memory, which occurs, for example, when using legacy code. We provide a mechanical proof of the soundness of the verification method, as well as a mechanical verification of a version of the popular tcc implementation that includes non-transactional memory accesses. The verification is performed by the deductive temporal checker tlpvs."
2008,Discriminative Model Checking.,"Abstract
Model checking typically compares a system description with a formal specification, and returns either a counterexample or an affirmation of compatibility between the two descriptions. Counterexamples provide evidence to the existence of an error, but it can still be very difficult to understand what is the cause for that error. We propose a model checking methodology which uses two levels of specification. Under this methodology, we group executions as good and bad with respect to satisfying a base LTL specification. We use an analysis specification, in CTL‚Äâ‚àó‚Äâ style, quantifying over the good and bad executions. This specification allows checking not only whether the base specification holds or fails to hold in a system, but also how it does so. We propose a model checking algorithm in the style of the standard CTL‚Äâ‚àó‚Äâ decision procedure. This framework can be used for comparing between good and bad executions in a system and outside it, providing assistance in locating the design or programming errors."
2008,CoVaC: Compiler Validation by Program Analysis of the Cross-Product.,"Abstract
The paper presents a deductive framework for proving program equivalence and its application to automatic verification of transformations performed by optimizing compilers. To leverage existing program analysis techniques, we reduce the equivalence checking problem to analysis of one system ‚Äì a cross-product of the two input programs. We show how the approach can be effectively used for checking equivalence of consonant (i.e., structurally similar) programs. Finally, we report on the prototype tool that applies the developed methodology to verify that a compiler optimization run preserves the program semantics. Unlike existing frameworks, CoVaC accommodates absence of compiler annotations and handles most of the classical intraprocedural optimizations such as constant folding, reassociation, common subexpression elimination, code motion, dead code elimination, branch optimizations, and others."
2008,Program analysis for compiler validation.,"Translation Validation is an approach of ensuring compilation correctness in which each compiler run is followed by a validation pass that proves that the target code produced by the compiler is a correct translation (implementation) of the source code. It has been previously shown that the problem of translation validation can be reduced to checking if a single system - the corss-product of the source and target, satisfies a specific property. In this paper, we show how to adapt the existing program analysis techniques in the setting of translation validation. In addition, we present a novel invariant generation algorithm which strengthens our analysis when the input programs contain dynamically allocated data structures. Finally, we report on the prototype tool that applies the developed methodology to verification of the LLVM compiler. The tool handles many of the classical intraprocedural compiler optimizations such as constant folding, reassociation, common subexpression elimination, code motion, dead code elimination, and others."
2008,On the Merits of Temporal Testers.,"Abstract
The paper discusses the merits of temporal testers, which can serve as a compositional basis for automata construction corresponding to temporal formulas in the context of ltl, psl, and mitl logics. Temporal testers can be viewed as (non-deterministic) transducers that, at any point, output a boolean value which is 1 iff the corresponding temporal formula holds starting at the current position.
The main advantage of testers, compared to acceptors (such asB√ºchi automata) is their compositionality. Namely, a tester for a compound formula can be constructed out of the testers for its sub-formulas. Besides providing the construction of testers for formulas specified in ltl, psl, and mitl, the paper also presents a general overview of the tester methodology, and highlights some of the unique features and applications of transducers including compositional deductive verification of ltl properties."
2008,All You Need Is Compassion.,"Abstract
The paper presents a new deductive rule for verifying response properties under the assumption of compassion (strong fairness) requirements. It improves on previous rules in that the premises of the new rule are all first order. We prove that the rule is sound, and present a constructive completeness proof for the case of finite-state systems. For the general case, we present a sketch of a relative completeness proof. We report about the implementation of the rule in PVS and illustrate its application on some simple but non-trivial examples."
2007,"Specify, Compile, Run: Hardware from PSL.","We propose to use a formal specification language as a high-level hardware description language. Formal languages allow for compact, unambiguous representations and yield designs that are correct by construction. The idea of automatic synthesis from specifications is old, but used to be completely impractical. Recently, great strides towards efficient synthesis from specifications have been made. In this paper we extend these recent methods to generate compact circuits and we show their practicality by synthesizing a generalized buffer and an arbiter for ARM's AMBA AHB bus from specifications given in PSL. These are the first industrial examples that have been synthesized automatically from their specifications.
"
2007,Modular Ranking Abstraction.,"Predicate abstraction has become one of the most successful methodologies for proving safety properties of programs. Recently, several abstraction methodologies have been proposed for proving liveness properties. This paper studies ""ranking abstraction"" where a program is augmented by a non-constraining progress monitor based on a set of ranking functions, and further abstracted by predicate-abstraction, to allow for automatic verification of progress properties. Unlike many liveness methodologies, the augmentation does not require a complete ranking function that is expected to decrease with each helpful step. Rather, adequate user-provided inputs are component rankings from which a complete ranking function may be automatically formed. The premise of the paper is an analogy between the methods of ranking abstraction and predicate abstraction, one ingredient of which is refinement: When predicate abstraction fails, one can refine it. When ranking abstraction fails, one must determine whether the predicate abstraction, or the ranking abstraction, needs be refined. The paper presents strategies for determining which case is at hand, and methods for performing the apporpriate refinements. The other part of the analogy is that of automatically deriving deductive proof constructs: Predicate abstraction is often used to derive program invariants for proving safety properties as a boolean combination of the given predicates. Deductive proof of progress properties requires well-founded ranking functions in addition to invariants. We show how the constructs necessary for a deductive proof of an arbitrary LTL formula can be automatically extracted from a successful application of the ranking abstraction method.


"
2007,On Synthesizing Controllers from Bounded-Response Properties.,"Abstract
In this paper we propose a complete chain for synthesizing controllers from high-level specifications. From real-time properties expressed in the logic mtl we generate, under bounded-variability assumptions, deterministic timed automata to which we apply safety synthesis algorithms to derive a controller that satisfies the properties by construction. Some preliminary experimental results are reported."
2007,Interactive presentation: Automatic hardware synthesis from specifications: a case study.,"We propose to use a formal specification language as a high-level hardware description language. Formal languages allow for compact, unambiguous representations and yield designs that are correct by construction. The idea of automatic synthesis from specifications is old, but used to be completely impractical. Recently, great strides towards efficient synthesis from specifications have been made. In this paper we extend these recent methods to generate compact circuits and we show their practicality by synthesizing an arbiter for ARM's AMBA AHB bus and a generalized-buffer from specifications given in PSL. These are the first industrial examples that have been synthesized automatically from their specifications."
2007,Verifying Correctness of Transactional Memories.,"Abstract:
We show how to verify the correctness of transactional memory implementations with a model checker. We show how to specify transactional memory in terms of the admissible interchange of transaction operations, and give proof rules for showing that an implementation satisfies this specification. This notion of an admissible interchange is a key to our ability to use a model checker, and lets us capture the various notions of transaction conflict as characterized by Scott. We demonstrate our work using the TLC model checker to verify several well-known implementations described abstractly in the TLA+ specification language."
2007,Synthesizing reactive systems from LSC requirements using the play-engine.,"Live Sequence Charts (LSCs) is a scenario-based language for modeling object-based reactive systems with liveness properties. A tool called the Play-Engine allows users to create LSC requirements using a point-and-click interface and generate executable traces using features called play-out and smart play-out. Finite executable trace fragments called super-steps are generated by smart play-out in response to user inputs. Each super-step is guaranteed not to violate the LSC requirements, provided one exists. However, non-violation is not guaranteed beyond each individual super-step. In this work, we demonstrate a powerful extension to smart play-out which produces only traces that are guaranteed not to violate the LSC requirements, provided the requirements are realizable. Using this method, we may synthesize correct executable programs directly from LSC requirements."
2007,"""Don't Care"" Modeling: A Logical Framework for Developing Predictive System Models.","Abstract
Analysis of biological data often requires an understanding of components of pathways and/or networks and their mutual dependency relationships. Such systems are often analyzed and understood from datasets made up of the states of the relevant components and a set of discrete outcomes or results. The analysis of these systems can be assisted by models that are consistent with the available data while being maximally predictive for untested conditions. Here, we present a method to construct such models for these types of systems. To maximize predictive capability, we introduce a set of ‚Äúdon‚Äôt care‚Äù (dc) Boolean variables that must be assigned values in order to obtain a concrete model. When a dc variable is set to 1, this indicates that the information from the corresponding component does not contribute to the observed result. Intuitively, more dc variables that are set to 1 maximizes both the potential predictive capability as well as the possibility of obtaining an inconsistent model. We thus formulate our problem as maximizing the number of dc variables that are set to 1, while retaining a model solution that is consistent and can explain all the given known data. This amounts to solving a quantified Boolean formula (QBF) with three levels of quantifier alternations, with a maximization goal for the dc variables. We have developed a prototype implementation to support our new modeling approach and are applying our method to part of a classical system in developmental biology describing fate specification of vulval precursor cells in the C. elegans nematode. Our work indicates that biological instances can serve as challenging and complex benchmarks for the formal-methods research community."
2007,Shape Analysis of Single-Parent Heaps.,"Abstract
We define the class of single-parent heap systems, which rely on a singly-linked heap in order to model destructive updates on tree structures. This encoding has the advantage of relying on a relatively simple theory of linked lists in order to support abstraction computation. To facilitate the application of this encoding, we provide a program transformation that, given a program operating on a multi-linked heap without sharing, transforms it into one over a single-parent heap. It is then possible to apply shape analysis by predicate and ranking abstraction as in [3]. The technique has been successfully applied on examples with trees of fixed arity (balancing of and insertion into a binary sort tree)."
2006,Reduced Functional Consistency of Uninterpreted Functions.,"A reduction of Equality Logic with Uninterpreted Functions (EUF) to Equality Logic with Ackermann's method suffers from a quadratic growth in the number of functional consistency constraints (constraints of the form x=y?F(x)=F(y)). We propose a framework in which syntactic characteristics of function instances (their signature) is used for guessing which constraints will possibly be needed for the proof. This framework can be either combined in an abstraction-refinement loop, or, in some cases, be used without refinement iterations. The framework is suitable for equivalence verification problems, which is one of the typical uses of Uninterpreted Functions. It enabled us to verify dozens of verification conditions resulting from Translation Validation that we could not prove otherwise.
"
2006,Monitoring Interfaces for Faults.,"We consider the problem of a module interacting with an external interface (environment) where the interaction is expected to satisfy some system specification ?. While we have the full implementation details of the module, we are only given a partial external specification for the interface. The interface specification being partial (incomplete) means that the interface displays only a strict subset of the behaviors allowed by the interface specification.
Based on the assumption that interface specifications are typically incomplete, we address the question of whether we can tighten the interface specification into a strategy, consistent with the given partial specification, that will guarantee that all possible interactions resulting from possible behaviors of the module will satisfy the system specification ?. We refer to such a tighter specification as ?-guaranteeing specification. Rather than verifying whether the interface, which is often an off-the-shelf component, satisfies the tighter specification, the paper proposes a construction of a run-time monitor which continuously checks the existence of a ?-guaranteeing interface.
We view the module and the external interface as players in a 2-player game. The interface has a winning strategy if it can guarantee that no matter what the module does, the overall specification ? is met. The problem of incomplete specifications is resolved by allowing the interface to follow any strategy consistent with the interface specification. Our approach essentially combines traditional run-time monitoring and static analysis. This allows going beyond the focus of traditional run-time monitoring tools ñ error detection in the execution trace, towards the focus of the static analysis ñ bug detection in the programs.
"
2006,Model Checking with Strong Fairness.,"In this paper we present a coherent framework for symbolic model checking of linear-time temporal logic (LTL) properties over finite state reactive systems, taking full fairness constraints into consideration. We use the computational model of a fair discrete system (FDS) which takes into account both justice (weak fairness) and compassion (strong fairness). The approach presented here reduces the model-checking problem into the question of whether a given FDS is feasible (i.e. has at least one computation).
The contribution of the paper is twofold: On the methodological level, it presents a direct self-contained exposition of full LTL symbolic model checking without resorting to reductions to either ?-calculus or CTL. On the technical level, it extends previous methods by dealing with compassion at the algorithmic level instead of either adding it to the specification, or transforming compassion to justice.
Finally, we extend CTL? with past operators, and show that the basic symbolic feasibility algorithm presented here, can be used to model check an arbitrary CTL? formula over an FDS with full fairness constraints.
"
2006,Liveness with invisible ranking.,"The method of invisible invariants was developed originally in order to verify safety properties of parameterized systems in a fully automatic manner. The method is based on (1) a project&generalize heuristic to generate auxiliary constructs for parameterized systems and (2) a small-model theorem, implying that it is sufficient to check the validity of logical assertions of a certain syntactic form on small instantiations of a parameterized system. The approach can be generalized to any deductive proof rule that (1) requires auxiliary constructs that can be generated by project&generalize, and (2) the premises resulting when using the constructs are of the form covered by the small-model theorem.
The method of invisible ranking, presented here, generalizes the approach to liveness properties of parameterized systems. Starting with a proof rule and cases where the method can be applied almost ìas is,î the paper progresses to develop deductive proof rules for liveness and extend the small-model theorem to cover many intricate families of parameterized systems.
"
2006,PSL Model Checking and Run-Time Verification Via Testers.,"Abstract
The paper introduces the construct of temporal testers as a compositional basis for the construction of automata corresponding to temporal formulas in the PSL logic. Temporal testers can be viewed as (non-deterministic) transducers that, at any point, output a boolean value which is 1 iff the corresponding temporal formula holds starting at the current position.
The main advantage of testers, compared to acceptors (such as B√ºchi automata) is that they are compositional. Namely, a tester for a compound formula can be constructed out of the testers for its sub-formulas. In this paper, we extend the application of the testers method from LTL to the logic PSL.
Besides providing the construction of testers for PSL, we indicate how the symbolic representation of the testers can be directly utilized for efficient model checking and run-time monitoring"
2006,From MITL to Timed Automata.,"Abstract
We show how to transform formulae written in the real-time temporal logic MITL into timed automata that recognize their satisfying models. This compositional construction is much simpler than previously known and can be easily implemented."
2006,Liveness by Invisible Invariants.,"Abstract
The method of Invisible Invariants was developed in order to verify safety properties of parametrized systems in a fully automatic manner. In this paper, we apply the method of invisible invariant to ‚Äúbounded response‚Äù properties, i.e., liveness properties of the type p \Rightarrow \diamondsuit q that are bounded ‚Äì once a p-state is reached, it takes a bounded number of rounds (where a round is a sequence of steps in which each process has been given a chance to proceed) to reach a q-state ‚Äì thus, they are essentially safety properties.
With a ‚Äúliveness monitor‚Äù that observes certain behavior of a system, establishing ‚Äúbounded response‚Äù properties over the system is reduced to the verification of invariant properties.
It is often the case that the inductive invariants for systems with ‚Äúliveness monitors‚Äù contain assertions of a certain form that the original method of invisible invariant is not able to generate, nor to check inductiveness. To accommodate invariants of such forms, we extend the techniques used for invariant generation, as well as the small model theorem for validity check."
2006,Invisible Safety of Distributed Protocols.,"Abstract
The method of ‚ÄúInvisible Invariants‚Äù has been applied successfully to protocols that assume a ‚Äúsymmetric‚Äù underlying topology, be it cliques, stars, or rings. In this paper we show how the method can be applied to proving safety properties of distributed protocols running under arbitrary topologies. Many safety properties of such protocols have reachability predicates, which, at first glance, are beyond the scope of the Invisible Invariants method. To overcome this difficulty, we present a technique, called ‚Äúcoloring,‚Äù that allows, in many instances, to replace the second order reachability predicates by first order predicates, resulting in properties that are amenable to Invisible Invariants.We demonstrate our techniques on several distributed protocols, including a variant on Luby‚Äôs Maximal Independent Set protocol, the Leader Election protocol used in the IEEE 1394 (Firewire) distributed bus protocol, and various distributed spanning tree algorithms. All examples have been tested using the symbolic model checker tlv."
2006,Faster Solutions of Rabin and Streett Games.,"Abstract:
In this paper we improve the complexity of solving Rabin and Streett games to approximately the square root of previous bounds. We introduce direct Rabin and Streett ranking that are a sound and complete way to characterize the winning sets in the respective games. By computing directly and explicitly the ranking we can solve such games in time O(mn k+1 kk!) and space O(nk) for Rabin and O(nkk!) for Streett where n is the number of states, m the number of transitions, and k the number of pairs in the winning condition. In order to prove completeness of the ranking method we give a recursive fixpoint characterization of the winning regions in these games. We then show that by keeping intermediate values during the fixpoint evaluation, we can solve such games symbolically in time O(n k+1 k!) and space O(n k+1 k!). These results improve on the current bounds of O(mn 2k k!) time in the case of direct (symbolic) solution or O(m(nk 2 k!) k ) in the case of reduction to parity games"
2006,Ranking Abstraction of Recursive Programs.,"Abstract
We present a method for model-checking of safety and liveness properties over procedural programs, by combining state and ranking abstractions with procedure summarization. Our abstraction is an augmented finitary abstraction [KP00,BPZ05], meaning that a concrete procedural program is first augmented with a well founded ranking function, and then abstracted by a finitary state abstraction. This results in a procedural abstract program with strong fairness requirements which is then reduced to a finite-state fair discrete system (fds) using procedure summarization. This fds is then model checked for the property."
2006,Synthesis of Reactive(1) Designs.,"Abstract
We consider the problem of synthesizing digital designs from their ltl specification. In spite of the theoretical double exponential lower bound for the general case, we show that for many expressive specifications of hardware designs the problem can be solved in time N 3, where N is the size of the state space of the design. We describe the context of the problem, as part of the Prosyd European Project which aims to provide a property-based development flow for hardware designs. Within this project, synthesis plays an important role, first in order to check whether a given specification is realizable, and then for synthesizing part of the developed system."
2005,Validating More Loop Optimizations.,"Translation validation is a technique for ensuring that a translator, such as a compiler, produces correct results. Because complete verification of the translator itself is often infeasible, translation validation advocates coupling the verification task with the translation task, so that each run of the translator produces verification conditions which, if valid, prove the correctness of the translation. In previous work, the translation validation approach was used to give a framework for proving the correctness of a variety of compiler optimizations, with a recent focus on loop transformations. However, some of these ideas were preliminary and had not been implemented. Additionally, there were examples of common loop transformations which could not be handled by our previous approaches.
This paper addresses these issues. We introduce a new rule Reduce for loop reduction transformations, and we generalize our previous rule Validate so that it can handle more transformations involving loops. We then describe how all of this (including some previous theoretical work) is implemented in our compiler validation tool TVOC.
"
2005,Translation and Run-Time Validation of Loop Transformations.,"This paper presents new approaches to the validation of loop optimizations that compilers use to obtain the highest performance from modern architectures. Rather than verify the compiler, the approach of translation validation performs a validation check after every run of the compiler, producing a formal proof that the produced target code is a correct implementation of the source code.
As part of an active and ongoing research project on translation validation, we have previously described approaches for validating optimizations that preserve the loop structure of the code and have presented a simulation-based general technique for validating such optimizations. In this paper, for more aggressive optimizations that alter the loop structure of the codeósuch as distribution, fusion, tiling, and interchangeówe present a set of permutation ruleswhich establish that the transformed code satisfies all the implied data dependencies necessary for the validity of the considered transformation. We describe the extensions to our tool voc-64 which are required to validate these structure-modifying optimizations.
This paper also discusses preliminary work on run-time validation of speculative loop optimizations. This involves using run-time tests to ensure the correctness of loop optimizations whose correctness cannot be guaranteed at compile time. Unlike compiler validation, run-time validation must not only determine when an optimization has generated incorrect code, but also recover from the optimization without aborting the program or producing an incorrect result. This technique has been applied to several loop optimizations, including loop interchange and loop tiling, and appears to be quite promising.
"
2005,Bridging the gap between fair simulation and trace inclusion.,"The paper considers the problem of checking abstraction between two finite-state fair discrete systems. In automata-theoretic terms this is trace inclusion between two nondeterministic Streett automata. We propose to reduce this problem to an algorithm for checking fair simulation between two generalized B¸chi automata. For solving this question we present a new triply nested ?-calculus formula which can be implemented by symbolic methods. We then show that every trace inclusion of this type can be solved by fair simulation, provided we augment the concrete system (the contained automaton) by an appropriate ënon-constrainingí automaton. This establishes that fair simulation offers a complete method for checking trace inclusion for finite-state systems. We illustrate the feasibility of the approach by algorithmically checking abstraction between finite state systems whose abstraction could only be verified by deductive methods up to now.
"
2005,A discrete-time UML semantics for concurrency and communication in safety-critical applications.,"We define a subset krtUML of UML which is rich enough to express such modelling entities of UML, used in real-time applications, as active objects, dynamic object creation and destruction, dynamically changing communication topologies, combinations of synchronous and asynchronous communication, and shared memory usage through object attributes. We define a formal interleaving semantics for this kernel language by associating with each model M?krtUML a symbolic transition system STS(M). We briefly outline how to compile models of industrial systems making use of generalisation hierarchies, weak and strong aggregation, and hierarchical state-machines into krtUML. The main aim of the paper is to provide an executable semantics for krtUML suitable for the formal verification of temporal model properties with existing model-checking tools.
"
2005,A compositional approach to CTL* verification.,"The paper presents a compositional approach to the verification of CTL properties over reactive systems. Both symbolic model-checking (SMC) and deductive verification are considered. Both methods are based on two decomposition principles. A general state formula is decomposed into basic state formulas which are CTL formulas with no embedded path quantifiers. To deal with arbitrary basic state formulas, we introduce another reduction principle which replaces each basic path formula, i.e., path formulas whose principal operator is temporal and which contain no embedded temporal operators or path quantifiers, by a newly introduced boolean variable which is added to the system. Thus, both the algorithmic and the deductive methods are based on two statification transformations which successively replace temporal formulas by assertions which contain no path quantifiers or temporal operators. Performing these decompositions repeatedly, we remain with basic assertional formulas, i.e., formulas of the form  and  for some assertion . In the model-checking method we present a single symbolic algorithm to verify both universal and existential basic assertional properties. In the deductive method we present a small set of proof rules and show that this set is sound and relatively complete for verifying universal and existential basic assertional properties over reactive systems. Together with two proof rules for the decompositions, we obtain a sound and relatively complete proof system for arbitrary CTL properties. Interestingly, the deductive approach for CTL presented here, offers a viable new approach to the deductive verification of arbitrary LTL formulas."
2005,"Ranking Abstraction as a Companion to Predicate Abstraction, .","Abstract
Predicate abstraction has become one of the most successful methodologies for proving safety properties of programs. Unfortunately, it cannot be used for verifying all liveness properties. In order to handle liveness properties, we introduce the method of ranking abstraction. This method augments the analyzed system by a ‚Äúprogress monitor‚Äù which observes whether a given ranking function decreases or increases at any step of the program. The fact that the ranking function ranges over a well-founded domain is expressed by a compassion (strong fairness) requirement, which states that a function over a well-founded domain cannot decrease infinitely many times without also increasing infinitely many times. In analogy to predicate abstraction which uses a predicate base \mathcal{P} = {P 1, ..., P m } consisting of a set of predicates, we augment the program with a ranking coreŒî = {Œ¥ 1,...,Œ¥ n } consisting of several ranking components. The augmented system is then abstracted using standard predicate abstraction, but retaining all the compassion requirements. The abstracted augmented system is then model checked for an arbitrary ltl property. The ranking abstraction method is shown to be sound and (relatively) complete for proving all ltl properties, including safety and liveness.
In the presented talk we focus on the strong analogy between predicate abstraction and ranking abstraction. Predicate abstraction can be viewed as a process which determines the best inductive invariant which can be formed as a boolean combination of the predicate base. In a similar way, ranking abstraction can be viewed as a search for the best well-founded global ranking function which can be formed as a lexicographic combination of the ranking components included in the ranking core Œî. In the talk, we present an algorithm for an explicit construction of such a global ranking function. Another important element of the predicate abstraction methodology is that of abstraction refinement by which, a coarse abstraction can be refined by analyzing a spurious counterexample. We show that ranking abstraction also possesses an analogous refinement process. We discuss how a spurious counter example can lead to a refinement of either the current predicate base or ranking core.
The talk is based on results obtained through joint research with I. Balaban, Y. Kesten, and L.D. Zuck."
2005,Synthesis Revisited: Generating Statechart Models from Scenario-Based Requirements.,"Abstract
Constructing a program from a specification is a long-known general and fundamental problem. Besides its theoretical interest, this question also has practical implications, since finding good synthesis algorithms could bring about a major improvement in the reliable development of complex systems. In this paper we describe a methodology for synthesizing statechart models from scenario-based requirements. The requirements are given in the language of live sequence charts (LSCs), and may be played in directly from the GUI, and the resulting statecharts are of the object-oriented variant, as adopted in the UML. We have implemented our algorithms as part of the Play-Engine tool and the generated statechart model can then be executed using existing UML case tools."
2005,Verification of Procedural Programs.,n/a
2005,TVOC: A Translation Validator for Optimizing Compilers.,"Abstract
We describe a tool called TVOC, that uses the translation validation approach to check the validity of compiler optimizations: for a given source program, TVOC proves the equivalence of the source code and the target code produced by running the compiler. There are two phases to the verification process: the first phase verifies loop transformations using the proof rule permute; the second phase verifies structure-preserving optimizations using the proof rule Validate. Verification conditions are validated using the automatic theorem prover CVC Lite."
2005,IIV: An Invisible Invariant Verifier.,"Abstract
This paper describes the Invisible Invariant Verifier (IIV)-an automatic tool for the generation of inductive invariants, based on the work in [4, 1, 2, 6]. The inputs to IIV are a parameterized system and an invariance property p, and the output of IIV is ‚Äúsuccess‚Äù if it finds an inductive invariant that strengthens p and ‚Äúfail‚Äù otherwise. IIV can be run from http://eeyore.cs.nyu.edu/servlets/iiv.ss."
2005,"Real Time Temporal Logic: Past, Present, Future.","Abstract
This paper attempts to improve our understanding of timed languages and their relation to timed automata. We start by giving a constructive proof of the folk theorem stating that timed languages specified by the past fragment of mitl, can be accepted by deterministic timed automata. On the other hand we provide a proof that certain languages expressed in the future fragment of mitl are not deterministic, and analyze the reason for this asymmetry."
2005,Ranking Abstraction as Companion to Predicate Abstraction.,"Abstract
Predicate abstraction has become one of the most successful methodologies for proving safety properties of programs. Recently, several abstraction methodologies have been proposed for proving liveness properties. This paper studies ‚Äúranking abstraction‚Äù where a program is augmented by a nonconstraining progress monitor, and further abstracted by predicate-abstraction, to allow for automatic verification of progress properties. Unlike most liveness methodologies, the augmentation does not require a complete ranking function that is expected to decrease with each step. Rather, the inputs are component rankings from which a complete ranking function may be formed.
The premise of the paper is an analogy between the methods of ranking abstraction and predicate abstraction, one ingredient of which is refinement: When predicate abstraction fails, one can refine it. When ranking abstraction fails, one must determine whether the predicate abstraction, or the ranking abstraction, need be refined. The paper presents strategies for determining which case is at hand.
The other part of the analogy is that of automatically deriving deductive proof constructs: Predicate abstraction is often used to derive program invariants for proving safety properties as a boolean combination of the given predicates. Deductive proof of progress properties requires well-founded ranking functions instead of invariants. We show how to obtain concrete global ranking functions from abstract programs.
We demonstrate the various methods on examples with nested loops, including a bubble sort algorithm on linked lists."
2005,Refining the Undecidability Frontier of Hybrid Automata.,"Abstract
Reachability becomes undecidable in hybrid automata (HA) that can simulate a Turing (TM) or Minsky (MM) machine. Asarin and Schneider have shown that, between the decidable 2-dim Piecewise Constant Derivative (PCD) class and the undecidable 3-dim PCD class, there lies the ‚Äúopen‚Äù class 2-dim Hierarchical PCD (HPCD). This class was shown to be equivalent to the class of 1-dim Piecewise Affine Maps (PAM). In this paper, we first explore 2-dim HPCD‚Äôs proximity to decidability, by showing that they are equivalent to 2-dim PCDs with translational resets, and to HPCDs without resets. A hierarchy of intermediates also equivalent to the HPCD class is presented, revealing semblance to timed and initialized rectangular automata. We then explore the proximity to the undecidability frontier. We show that 2-dim HPCDs with zeno executions or integer-checks can simulate the 2-counter MM. We conclude by retreating HPCDs as PAMs, to derive a simple over-approximating algorithm for reachability. This also defines a decidable subclass 1-dim Onto PAM (oPAM). The novel non-trivial transformation of 2-dim HPCDs into ‚Äúalmost decidable‚Äù systems, is likely to pave the way for approximate reachability algorithms, and the characterization of decidable subclasses. It is hoped that these ideas eventually coalesce into a complete understanding of the reachability problem for the class 2-dim HPCD (1-dim PAM)."
2005,Separating Fairness and Well-Foundedness for the Analysis of Fair Discrete Systems.,"Abstract
Fair discrete systems (FDSs) are a computational model of concurrent programs where fairness assumptions are specified in terms of sets of states. The analysis of fair discrete systems involves a non-trivial interplay between fairness and well-foundedness (ranking functions). This interplay has been an obstacle for automation. The contribution of this paper is a new analysis of temporal properties of FDSs. The analysis uses a domain of binary relations over states labeled by sets of indices of fairness requirements. The use of labeled relations separates the reasoning on well-foundedness and fairness."
2005,Temporal Logic for Scenario-Based Specifications.,"Abstract
We provide semantics for the powerful scenario-based language of live sequence charts (LSCs). We show how the semantics of live sequence charts can be captured using temporal logic. This is done by studying various subsets of the LSC language and providing an explicit translation into temporal logic. We show how a kernel subset of the LSC language (which omits variables, for example) can be embedded within the temporal logic CTL*. For this kernel subset the embedding is a strict inclusion. We show that existential charts can be expressed using the branching temporal logic CTL while universal charts are in the intersection of linear temporal logic and branching temporal logic LTL ‚à© CTL. Since our translations are efficient, the work described here may be used in the development of tools for analyzing and executing scenario-based requirements and for verifying systems against such requirements."
2005,Abstraction for Liveness.,"Abstract
Unlike model checking which is restricted to finite-state systems, there are two methods which can be applied for the verification of arbitrary infinite-state systems. These are the methods of deductive verification and finitary abstraction (FA). Finitary abstraction is the process which provides an abstraction mapping, mapping a potentially infinite-state system into a finite-state one. After obtaining the finite-state abstraction, we may apply model checking in order to verify the property.
In the talk, we will explore some of the relations between the methods of finitary abstraction and deductive verification. One important connection is the recent proof that finitary abstraction is as powerful as deductive verification, thus establishing the completeness (and universality) of the finitary abstraction method. In order to obtain this result, it was necessary to extend the procedure by allowing augmentation of the verified system with auxiliary variables prior to the application of abstraction. With this extension, it is possible to transform the phenomenon of well-founded descent which is essential for proofs of liveness properties into fairness properties of the finite abstracted system.
Since the proof of completeness of the FA method builds upon the proof of completeness of deductive verification, one may get the false impression that, while being as powerful as deductive verification, FA is not much easier to apply. The focus of the talk is aimed at dispelling this false impression, in particular for the case of liveness properties.
We consider first the case of predicate abstraction, which is a special case of FA. We can view predicate abstraction as an effort to find an inductive assertion, where the user does not know the full form of the assertion but can identify a set of atomic formulas under the conjecture that there exists a useful inductive assertion which is some boolean combination of these atomic formulas. In this case, we let the model checker find for us the correct (and best) boolean combination that yields an inductive assertion. In analogy with this view, we will consider the ‚Äúaugmented finitary abstraction‚Äù approach as a situation that the user finds it difficult to formulate a full ranking function, as required by deductive verification, but can identify some components of such a ranking function. In that case, we let the model checker arrange and combine these components into a full liveness proof. In both cases, the method relies on the superior ability of model checkers to exhaustively analyze all the combinations of a finite (but possibly large) set of components.
This is work is based on collaboration with Ittai Balaban, Yonit Kesten, and Lenore Zuck."
2005,Shape Analysis by Predicate Abstraction.,"Abstract
The paper presents an approach for shape analysis based on predicate abstraction. Using a predicate base that involves reachability relations between program variables pointing into the heap, we are able to analyze functional properties of programs with destructive heap updates, such as list reversal and various in-place list sorts. The approach allows verification of both safety and liveness properties. The abstraction we use does not require any abstract representation of the heap nodes (e.g. abstract shapes), only reachability relations between the program variables.
The computation of the abstract transition relation is precise and automatic yet does not require the use of a theorem prover. Instead, we use a small model theorem to identify a truncated (small) finite-state version of the program whose abstraction is identical to the abstraction of the unbounded-heap version of the same program. The abstraction of the finite-state version is then computed by BDD techniques.
For proving liveness properties, we augment the original system by a well-founded ranking function, which is abstracted together with the system. Well-foundedness is then abstracted into strong fairness (compassion). We show that, for a restricted class of programs that still includes many interesting cases, the small model theorem can be applied to this joint abstraction.
Independently of the application to shape-analysis examples, we demonstrate the utility of the ranking abstraction method and its advantages over the direct use of ranking functions in a deductive verification of the same property."
2004,Model checking and abstraction to the aid of parameterized systems (a survey).,"Parameterized systems are systems that involve numerous instantiations of the same finite-state module, and depend on a parameter which defines their size. Examples of parameterized systems include sensor systems, telecommunication protocols, bus protocols, cache coherence protocols, and many other protocols that underly current state-of-the-art systems. Formal verification of parameterized systems is known to be undecidable (Inform. Process. Lett. 22 (6)) and thus cannot be automated. Recent research has shown that it is often the case that a combination of methodologies allows to reduce the problem of verification of a parameterized system into the problem of verification of a finite-state system, that can be automatically verified.
This paper describes several recent methodologies, based on model checking and abstraction. We start with the method of invisible auxiliary assertions that combines a small-model theorem with heuristics to automatically generate auxiliary constructs used in proofs of correctness of parameterized systems. We also describe the method of counter abstraction that offers simple liveness proofs for many parameterized systems, and discuss novel methodologies of using counter abstraction to automatically verify that probabilistic parameterized system satisfy their temporal specifications with probability 1.
"
2004,Validating the Translation of an Industrial Optimizing Compiler.,"Abstract
The paper presents an approach to the translation validation of an optimizing compiler which translates synchronous C programs into machine code programs. Being synchronous means that both source and target programs are loop free. This enables representation of each of these programs by a single state transformer, and verification of the translation correctness is based on comparison of the source and target state transformers. The approach has been implemented on a tool called MCVT which is also described."
2004,Range Allocation for Separation Logic.,"Abstract
Separation Logic consists of a Boolean combination of predicates of the form v i ‚â• v j + c where c is a constant and v i ,v j are variables of some ordered infinite type like real or integer. Any equality or inequality can be expressed in this logic. We propose a decision procedure for Separation Logic based on allocating small domains (ranges) to the formula‚Äôs variables that are sufficient for preserving satisfiability. Given a Separation Logic formula œÜ, our procedure constructs the inequalities graph of œÜ, based on œÜ‚Äôs predicates. This graph represents an abstraction of the formula, as there are many formulas with the same set of predicates. Our procedure then analyzes this graph and allocates a range to each variable that is adequate for all of these formulas. This approach of finding small finite ranges and enumerating them symbolically is both theoretically and empirically more efficient than methods based on case-splitting or reduction to Propositional Logic. Experimental results show that the state-space (that is, the number of assignments that need to be enumerated) allocated by our procedure is frequently exponentially smaller than previous methods."
2004,On Recognizable Timed Languages.,"Abstract
In this work we generalize the fundamental notion of recognizability from untimed to timed languages. The essence of our definition is the existence of a right-morphism from the monoid of timed words into a bounded subset of itself. We show that the recognizable languages are exactly those accepted by deterministic timed automata and argue that this is, perhaps, the right class of timed languages, and that the closure of untimed regular languages under projection is a positive accident that cannot be expected to hold beyond the finite-state case."
2004,Smart Play-Out Extended: Time and Forbidden Elements.,"Abstract:
Smart play-out is a powerful technique for executing live sequence charts (LSCs). It uses verification techniques to help run a program, rather than to prove properties thereof. We extend smart play-out to cover a larger set of the LSC language features and to deal more efficiently with larger models. The extensions cover two key features of the rich version of LSCs, namely, time and forbidden elements. The former is crucial for systems with time constraints and/or time-driven behavior, and the latter allows specifying invariants and contracts on behavior. Forbidden elements can also help reduce the state space considered, thus enabling smart play-out to handle larger models."
2004,Liveness with Incomprehensible Ranking.,"Abstract
The methods of Invisible Invariants and Invisible Ranking were developed originally in order to verify temporal properties of parameterized systems in a fully automatic manner. These methods are based on an instantiate-project-and-generalize heuristic for the automatic generation of auxiliary constructs and a small model property implying that it is sufficient to check validity of a deductive rule premises using these constructs on small instantiations of the system. The previous version of the method of Invisible Ranking was restricted to cases where the helpful assertions and ranking functions for a process depended only on the local state of this process and not on any neighboring process, which seriously restricted the applicability of the method, and often required the introduction of auxiliary variables.
In this paper we extend the method of Invisible Ranking to cases where the helpful assertions and ranking functions of a process may also refer to other processes. We first develop an enhanced version of the small model property, making it applicable to assertions that refer both to processes and their immediate neighbors. This enables us to apply the Invisible Ranking method to parameterized systems with ring topologies. For cases where the auxiliary assertions refer to all processes, we develop a novel proof rule which simplifies the selection of the next helpful transition, and enables the validation of the premises possible under the (old) small model theorem."
2004,Deductive Verification of UML Models in TLPVS.,"Abstract
In recent years, UML has been applied to the development of reactive safety-critical systems, in which the quality of the developed software is a key factor. In this paper we present an approach for the deductive verification of such systems using the PVS interactive theorem prover. Using a PVS specification of a UML kernel language semantics, we generate a formal representation of the UML model. This representation is then verified using tlpvs, our PVS-based implementation of linear temporal logic and some of its proof rules. We apply our method by verifying two examples, demonstrating the feasibility of our approach on models with unbounded event queues, object creation, and variables of unbounded domain. We define a notion of fairness for UML systems, allowing us to verify both safety and liveness properties."
2004,Liveness with Invisible Ranking.,"Abstract
The method of Invisible Invariants was developed originally in order to verify safety properties of parameterized systems fully automatically. Roughly speaking, the method is based on a small model property that implies it is sufficient to prove some properties on small instantiations of the system, and on a heuristic that generates candidate invariants. Liveness properties usually require well founded ranking, and do not fall within the scope of the small model theorem. In this paper we develop novel proof rules for liveness properties, all of whose proof obligations are of the correct form to be handled by the small model theorem. We then develop abstraction and generalization techniques that allow for fully automatic verification of liveness properties of parameterized systems. We demonstrate the application of the method on several examples."
2003,VOC: A Methodology for the Translation Validation of OptimizingCompilers.,"There is a growing awareness, both in industry and academia, of the crucial role of formally verifying the translation from high-level source-code into low-level object code that is typically performed by an optimizing compiler. Formally verifying an optimizing compiler, as one would verify any other large program, is not feasible due to its size, ongoing evolution and modification, and, possibly, proprietary considerations. Translation validation is a novel approach that offers an alternative to the verification of translators in general and compilers in particular: Rather than verifying the compiler itself, one constructs a validation tool which, after every run of the compiler, formally confirms that the target code produced in the run is a correct translation of the source program. The paper presents voc, a methodology for the translation validation of optimizing compilers. We distinguish between structure preserving optimizations, for which we establish a simulation relation between the source and target code based on computational induction, and structure modifying optimizations, for which we develop specialized permutation rules. The paper also describes voc-64 - a prototype translation validator tool that automatically produces verification conditions for the global optimizations of the SGI Pro-64 compiler."
2003,TLPVS: A PVS-Based LTL Verification System.,"Abstract
In this paper we present our pvs implementation of a linear temporal logic verification system. The system includes a set of theories defining a temporal logic, a number of proof rules for proving soundness and response properties, and strategies which aid in conducting the proofs. In addition to implementing a framework for existing rules, we have also derived new methods which are particularly useful in a deductive ltl system. A distributed rank rule for the verification of response properties in parameterized systems is presented, and a methodology is detailed for reducing compassion requirements to justice requirements (strong fairness to weak fairness). Special attention has been paid to the verification of unbounded systems ‚Äî systems in which the number of processes is unbounded ‚Äî and our verification rules are appropriate to such systems."
2003,Bridging the Gap between Fair Simulation and Trace Inclusion.,"Abstract
The paper considers the problem of checking abstraction between two finite-state fair discrete systems. In automata-theoretic terms this is trace inclusion between two Streett automata. We propose to reduce this problem to an algorithm for checking fair simulation between two generalized B√ºchi automata. For solving this question we present a new triply nested Œº-calculus formula which can be implemented by symbolic methods.
We then show that every trace inclusion of this type can be solved by fair simulation, provided we augment the concrete system (the contained automaton) by appropriate auxiliary variables. This establishes that fair simulation offers a complete method for checking trace inclusion. We illustrate the feasibility of the approach by algorithmically checking abstraction between finite state systems whose abstraction could only be verified by deductive methods up to now."
2003,The ROBDD Size of Simple CNF Formulas.,"Abstract
Reduced Ordered Binary Decision diagrams (ROBDDs) are nowadays one of the most common dynamic data structures for Boolean functions. Among the many areas of application are verification, model checking, and computer aided design. In the last few years, SAT checkers, based on the CNF representation of Boolean functions are getting more and more attention as an alternative to the ROBDD based methods. We show the difference between the CNF representation and the ROBDD representation in one of the most degenerate cases ‚Äì random monotone 2CNF formulas. We examine this model and give almost matching lower and upper bounds for the ROBDD size in different cases, and show that as soon as the formulas are non-trivial the ROBDD size becomes exponential, thus showing perhaps one of the most fundamental advantages of SAT solvers over ROBDDs."
2003,Formal Modeling of C. elegans Development: A Scenario-Based Approach.,"Abstract
We present preliminary results of a new approach to the formal modeling of biological phenomena. The approach stems from the conceptual compatibility of the methods and logic of data collection and analysis in the field of developmental genetics with the languages, methods and tools of scenario-based reactive system design. In particular, we use the recently developed methodology consisting of the language of live sequence charts with the play-in/play-out process, to model the well-characterized process of cell fate acquisition during C. elegans vulval development."
2003,Parameterized Verification by Probabilistic Abstraction.,"Abstract
The paper studies automatic verification of liveness properties with probability 1 over parameterized programs that include probabilistic transitions, and proposes two novel approaches to the problem. The first approach is based on a Planner that occasionally determines the outcome of a finite sequence of ‚Äúrandom‚Äùchoices, while the other random choices are performed non-deterministically.Using a Planner, a probabilistic protocol can be treated just like a non-probabilistic one and verified as such. The second approach is based on Œ≥-fairness, a notion of fairness that is sound and complete for verifying simple temporal properties (whose only temporal operators are ‚ãÑand ‚ñ°) over finite-state systems.The paper presents a symbolic model checker based on Œ≥-fairness.We then show how the network invariant approach can be adapted to accommodate probabilistic protocols. The utility of the Planner approach is demonstrated on a probabilistic mutual exclusion protocol. The utility of the approach of Œ≥-fairness with network invariants is demonstrated on Lehman and Rabin's Courteous Philosophers algorithm."
2003,Smart play-out.,"We describe ""smart play-out"", a new method for executing and analyzing scenario based behavior, which is part of the Play-In/Play-Out methodology and the Play-Engine tool. Behavior is ""played in"" directly from the system's GUI, and as this is being done the Play-Engine continuously constructs Live Sequence Charts (LSCs), a powerful extension of sequence diagrams. Later, behavior can be ""played out"" freely from the GUI, and the tool executes the LSCs directly, thus driving the system's behavior. An inherent difficulty in constructing a ``play-out"" mechanism is how to resolve the nondeterminism allowed by the LSC specification in order to obtain an executable model. Smart play-out, is a recent strengthening of the play-out mechanism, which addresses this problem by using powerful verification methods, mainly model-checking, to execute and analyze the LSCs, helping the execution to avoid deadlocks and violations. Thus, smart play-out utilizes verification techniques to run programs, rather than to verify a program with respect to given requirements, as in traditional verification approaches. The ideas appear to be relevant in various stages of system development, including requirements specification and analysis, implementation and testing."
2003,Model-Checking and Abstraction to the Aid of Parameterized Systems.,"Abstract
Parameterized systems are systems that involve numerous instantiations of the same finite-state module. Examples of parameterized systems include tele-communication protocols, bus protocols, cache coherence protocols, and many other protocols that underly current state-of-the-art systems. Formal verification of parameterized systems is known to be undecidable [AK86] and thus cannot be automated. Recent research has shown that in many cases it is possible to use abstraction methods to generate a finite-state systems from a parameterized systems. The finite-state system can then be model-checked. If successful, it is possible to conclude that the original parameterized system satisfies its requirements. Otherwise, it is often the case that the counter-example produced by the model checker can indicate an error in the original parameterized system. This combined technique allows for automatic verification of parameterized systems."
2002,TimeC: A Time Constraint Language for ILP Processor Compilation.,"Enabled by RISC technologies, low-cost commodity microprocessors are performing at ever increasing levels, significantly via instruction level parallelism (ILP). This in turn increases the opportunities for their use in a variety of day-to-day applications ranging from the simple control of appliances such as microwave ovens, to sophisticated systems for cabin control in modern aircraft. Indeed, ìembeddedî applications such as these represent segments in the computer industry with great potential for growth. However, this growth is currently impeded by the lack of robust optimizing compiler technologies that support the assured, rapid and inexpensive prototyping of real-time software in the context of microprocessors with ILP. In this paper we describe a novel notation, TimeC, for specifying timing constraints in programs, independent of the base language being used to develop the embedded application; TimeC specifications are language independent and can be instrumented into imperative and object-oriented languages non-intrusively. As we will show, the program synthesis problem that arise out of Time_tract specifications, a subset of TimeC, are always ìtractable.î In contrast, a range of specification mechanisms proposed earlier yield substantially intractable synthesis questions, thereby limiting their potential utility. We will compare the tractability and related expressive power issues between TimeC and some of the extant mechanisms for specifying properties of timed programs.
"
2002,VOC: A Translation Validator for Optimizing Compilers.,"There is a growing awareness, both in industry and academia, of the crucial role of formally verifying the translation from high-level source-code into low-level object code that is typically performed by an optimizing compiler. Formally verifying an optimizing compiler, as one would verify any other large program, is not feasible due to its size, ongoing evolution and modification, and, possibly, proprietary considerations. Translation validation is a novel approach that offers an alternative to the verification of translators in general and compilers in particular: Rather than verifying the compiler itself, one constructs a validation tool which, after every run of the compiler, formally confirms that the target code produced in the run is a correct translation of the source program. The paper presents voc, a methodology for the translation validation of optimizing compilers. We distinguish between structure preserving optimizations, for which we establish a simulation relation between the source and target code based on computational induction, and structure modifying optimizations, for which we develop specialized permutation rules. The paper also describes voc-64 - a prototype translation validator tool that automatically produces verification conditions for the global optimizations of the SGI Pro-64 compiler."
2002,Translation and Run-Time Validation of Optimized Code.,"The paper presents approaches to the validation of optimizing compilers. The emphasis is on aggressive and architecture-targeted optimizations which try to obtain the highest performance from modern architectures, in particular EPIC-like micro-processors. Rather than verify the compiler, the approach of translation validation performs a validation check after every run of the compiler, producing a formal proof that the produced target code is a correct implementation of the source code.
First we survey the standard approach to validation of optimizations which preserve the loop structure of the code (though they may move code in and out of loops and radically modify individual statements), present a simulation-based general technique for validating such optimizations, and describe a tool, VOC-64, which implements these technique. For more aggressive optimizations which, typically, alter the loop structure of the code, such as loop distribution and fusion, loop tiling, and loop interchanges, we present a set of permutation rules which establish that the transformed code satisfies all the implied data dependencies necessary for the validity of the considered transformation. We describe the necessary extensions to the VOC-64 in order to validate these structure-modifying optimizations.
Finally, the paper discusses preliminary work on run-time validation of speculative loop optimizations, that involves using run-time tests to ensure the correctness of loop optimizations which neither the compiler nor compiler-validation techniques can guarantee the correctness of. Unlike compiler validation, run-time validation has not only the task of determining when an optimization has generated incorrect code, but also has the task of recovering from the optimization without aborting the program or producing an incorrect result. This technique has been applied to several loop optimizations, including loop interchange, loop tiling, and software pipelining and appears to be quite promising.
"
2002,The Small Model Property: How Small Can It Be?,"Efficient decision procedures for equality logic (quantifier-free predicate calculus+the equality sign) are of major importance when proving logical equivalence between systems. We introduce an efficient decision procedure for the theory of equality based on finite instantiations. The main idea is to analyze the structure of the formula and compute accordingly a small domain to each variable such that the formula is satisfiable iff it can be satisfied over these domains. We show how the problem of finding these small domains can be reduced to an interesting graph theoretic problem. This method enabled us to verify formulas containing hundreds of integer and floating point variables that could not be efficiently handled with previously known techniques.
"
2002,Complete Proof System for QPTL.,"The paper presents an axiomatic system for quantified propositional temporal logic (QPTL), which is propositional temporal logic equipped with quantification over propositions (Boolean variables). The advantages of this extended temporal logic is that its expressive power is strictly higher than that of the unquantified version (PTL) and is equal to that of S1S, as well as that of ??automata. Another important application of QPTL is its use for formulating and verifying refinement relations between reactive systems. In fact, the completeness proof is based on the reduction of a QPTL formula into a B¸chi automaton, and performing equivalence transformations on this automaton, formally justifying these transformations as a bi?directional refinement.
"
2002,Validating software pipelining optimizations.,"The paper presents a method for translation validation of a specific optimization, software pipelining optimization, used to increase the instruction level parallelism in EPIC type of architectures. Using a methodology as in [15] to establish simulation relation between source and target based on computational induction, we describe an algorithm that automatically produces a set of decidable proof obligations. The paper also describes SPV, a prototype translation validator that automatically produces verification conditions for software pipelining optimizations of the SGI Pro-64 compiler. These verification conditions are further checked automatically by the CVC [12] checker."
2002,"Liveness with (0, 1, infty)-Counter Abstraction.","Abstract
We introduce the (0, 1, ‚àû) -counter abstraction method by which a parameterized system of unbounded size is abstracted into a finite-state system. Assuming that each process in the parameterized system is finite-state, the abstract variables are limited counters which count, for each local states of a process, the number of processes which currently are in local state s. The counters are saturated at 2, which means that Œ∫(s) = 2 whenever 2 or more processes are at state s. The emphasis of the paper is on the derivation of an adequate and sound set of fairness requirements (both weak and strong) that enable proofs of liveness properties of the abstract system, from which we can safely conclude a corresponding liveness property of the original parameterized system. We illustrate the method on few parameterized systems, including Szymanski‚Äôs Algorithm for mutual exclusion. The method is also extended to deal with parameterized systems whose processes may have infinitely many local states, such as the Bakery Algorithm, by choosing few ‚Äúinteresting‚Äù state assertions and (0, 1, ‚àû)-counting the number of processes satisfying them."
2002,A Deductive Proof System for CTL.,"Abstract
The paper presents a sound and (relatively) complete deductive proof system for the verification of CTL* properties over possibly infinite-state reactive systems. The proof system is based on a set of proof rules for the verification of basic CTL* formulas, namely CTL* formulas with no embedded path quantifiers. We first show how to decompose the proof of a general (non-basic) CTL* formula into proofs of basic CTL* formulas. We then present proof rules for some of the most useful basic ctl formulas, then present a methodology for transforming an arbitrary basic formula into one of these special cases."
2002,Network Invariants in Action.,"Abstract
The paper presents the method of network invariants for verifying a wide spectrum of LTL properties, including liveness, of parameterized systems. This method can be applied to establish the validity of the property over a system S(n) for every value of the parameter n. The application of the method requires checking abstraction relations between two finite-state systems. We present a proof rule, based on the method of Abstraction Mapping by Abadi and Lamport, which has been implemented on the tlv modelc hecker and incorporates both history and prophecy variables. The effectiveness of the network invariant method is illustrated on several examples, including a deterministic and probabilistic versions of the dining-philosophers problem."
2002,Embedded Systems: Challenges in Specification and Verification.,"Abstract
In this position paper, we mention some of the challenges in specification and verification which are raised by the emerging discipline of embedded systems. The main proposition of the paper is that a feasible solution to the problem of effective, reliable, and dependable construction of embedded systems can be provided by a seamless development process based on a formal specification of the required system, which proceeds by the activities of verification and analysis of the specification at very early stages of the design, and then followed by automatic code generation, preceded if necessary by code distribution and allocation.
As a prototype example of such a development process, we quote some experiences from the Sacres project and its follow-up Safeair. Necessary extensions to these preliminary experiments are discussed and evaluated."
2002,Smart Play-out of Behavioral Requirements.,"Abstract
We describe a methodology for executing scenario-based requirements of reactive systems, focusing on ‚Äúplaying-out‚Äù the behavior using formal verification techniques for driving the execution. The methodology is implemented in full in our play-engine too. The approach appears to be useful in many stages in the development of reactive systems, and might also pave the way to systems that are constructed directly from their requirements, without the need for intra-object or intra-component modeling or coding."
2002,Understanding UML: A Formal Semantics of Concurrency and Communication in Real-Time UML.,"Abstract
We define a subset krtUML of UML which is rich enough to express all behavioural modelling entities of UML used for real-time applications, covering such aspects as active objects, dynamic object creation and destruction, dynamically changing communication topologies in inter-object communication, asynchronous signal based communication, synchronous communication using operation calls, and shared memory communication through global attributes. We define a formal interleaving semantics for this kernel language by associating with each model M‚Äâ‚àà‚ÄâkrtUML a symbolic transition system STS(M). We outline how to compile industrial real-time UML models making use of generalisation hierarchies, weak- and strong aggregation, and hierarchical state-machines into krtUML, and propose modelling guidelines for real-time applications of UML. This work provides the semantical foundation for formal verification of real-time UML models described in the companion paper [11]."
2002,Applications of Formal Methods in Biology.,"Abstract
From the first introduction of the notion of ‚ÄúReactive Systems‚Äù and development of specification languages (such as Temporal Logic and Statecharts) and verification methods for this class of systems, it has been stated that this notion encompasses a wider class of systems than just programs or hardware designs, and should be applicable to other complex systems unrelated to computers. In a similar vein, the acronym UML talks about ‚Äúmodeling language‚Äù rather than ‚Äúprogramming language‚Äù, implying that the approach should be applicable to a more general class of systems than just computer-related.
While this claim of wider applicability has been always implied, it was never before seriously substantiated. In this talk, I will describe some recent attempts to apply the discipline of formal methods to the modeling, analysis, and prediction of biological systems. This corresponds to an emerging trend in Biology, according to which Biology in the 21st century will have to direct its attention towards understanding how component parts collaborate to create a whole system or organism. The transition from identifying building blocks (analysis) to integrating the parts into a whole (synthesis) will have to use mathematics and algorithmics. We need a language that is legible both to biologists and computers, and that is faithful to the logic of the biological system of interest.
In search for an appropriate rigorous approach to modeling biological systems, we examined formal modeling methods in computer science that were originally developed for specification, design, and analysis of reactive systems. We found that the visual formalism of statecharts can address this challenge, within the general framework of object-oriented modeling. This conclusion followed an initial study we carried out, in which we constructed a detailed executable model for T cell activation, and were able, using verification techniques to find and correct a flaw in the original model.
Following this preliminary study, we have now undertaken the more challenging project of applying and extending this methodology for constructing a detailed model of the developmental processes that lead to the formation of the egg-laying system in the nematode C. elegans. The model is built to capture in a natural yet rigorous and analyzable way the aspects of concurrency, multi scalar data, and hierarchical organization. This project involves a close collaboration with Naaman Kam, David Harel, and Irun Cohen from the department of Immunology at the Weizmannn Institute."
2002,Automatic Verification of Probabilistic Free Choice.,"Abstract
We study automatic methods for establishing P-validity (validity with probability 1) of simple temporal properties over finite-state probabilistic systems. The proposed approach replaces P-validity with validity over a non-probabilistic version of the system, in which probabilistic choices are replaced by non-deterministic choices constrained by compassion (strong fairness) requirements. ‚ÄúSimple‚Äù properties are temporal properties whose only temporal operators are ‚óä (eventually) and its dual ‚ñ° (always). In general, the appropriate compassion requirements are ‚Äúglobal,‚Äù since they involve global states of the system. Yet, in many cases they can be transformed into ‚Äúlocal‚Äù requirements, which enables their verification by model checkers. We demonstrate our methodology of translating the problem of P-validity into that of verification of a system with local compassion requirement on the ‚Äúcourteous philosophers‚Äù algorithm of [LR81], a parameterized probabilistic system that is notoriously difficult to verify, and outline a verification of the algorithm that was obtained by the TLV model checker."
2001,Verification by Augmented Abstraction: The Automata-Theoretic View.,"This paper deals with the proof method of verification by finitary abstraction (), which presents an alternative approach to the verification of (potentially infinite-state) reactive systems. We assume that the negation of the property to be verified is given by the user in the form of an infinite-state nondeterministic B¸chi discrete system (). The method consists of a two-step process by which, in a first step, the system and its (negated) specification are combined into a single infinite-state fair discrete system (, which is similar to a  but with Streett acceptance conditions), which is abstracted into a finite-state automaton. The second step uses model checking to establish that the abstracted automaton is infeasible, i.e., has no computations. The  method can be considered as a viable alternative to verification by temporal deduction, which, up to now, has been the main method generally applicable for verification of infinite-state systems. The paper presents a general recipe for an  abstraction, which is shown to be sound, where soundness means that infeasibility of the abstracted  implies infeasibility of the unabstracted one, implying in turn the validity of the property over the concrete (infinite-state) system. To make the method applicable for the verification of liveness properties, pure abstraction is sometimes no longer adequate. We show that by augmenting the system with an appropriate (and standardly constructible) progress monitor, we obtain an augmented system, whose computations are essentially the same as those of the original system and which may now be abstracted while preserving the desired liveness properties. We refer to the extended method as verification by augmented abstraction (). We then proceed to show that the  method is sound and complete for proving all properties whose negations are expressible by a . Given that every linear temporal logic () property can be translated to a , this establishes that the  method is sound and complete for proving the validity of all  properties, including both safety and liveness.
"
2001,Symbolic model checking with rich assertional languages.,"The paper shows that, by an appropriate choice of a rich assertional language, it is possible to extend the utility of symbolic model checking beyond the realm of BDD-represented finite-state systems into the domain of infinite-state systems, leading to a powerful technique for uniform verification of unbounded (parameterized) process networks. The main contributions of the paper are a formulation of a general framework for symbolic model checking of infinite-state systems, a demonstration that many individual examples of uniformly verified parameterized designs that appear in the literature are special cases of our general approach, verifying the correctness of the Futurebus+ design for all single-bus configurations, and extending the technique to tree architectures.
"
2001,Scheduling time-constrained instructions on pipelined processors.,"In this work we investigate the problem of scheduling instructions on idealized microprocessors with multiple pipelines, in the presence of precedence constraints, release-times, deadlines, and latency constraints. A latency of lij specifies that there must be at least lij time-steps between the completion time of instruction i and the start time of instruction j. A latency of lij=?1 can be used to specify that j may be scheduled concurrently with i but not earlier. We present a generic algorithm that runs in O(n2logn?(n)+ne) time, given n instructions and e edges in the precedence DAG, where ?(n) is the functional inverse of the Ackermann function. Our algorithm can be used to construct feasible schedules for various classes of instances, including instances with the following configurations: (1) one pipeline, with individual release-times and deadlines and where the latencies between instructions are restricted to 0 and 1; (2) m pipelines, with individual release-times and deadlines, and monotone-interval order precedences; (3) two pipelines with latencies of ?1 or 0, and release-times and deadlines; (4) one pipeline, latencies of 0 or 1 and individual processing times that are at least one; (5) m pipelines, intree precedences, constant latencies, and deadlines; (6) m pipelines, outtree precedences, constant latencies, and release-times. For instances with deadlines, optimal schedules that minimize the maximal tardiness can be constructed using binary search, in O(log n) iterations of our algorithm. We obtain our results using backward scheduling, a very general relaxation method, which extends, unifies, and clarifies many previous results on instruction scheduling for pipelined and parallel machines.
"
2001,Parameterized Verification with Automatically Computed Inductive Assertions.,"Abstract
The paper presents a method, called the method of verification by invisible invariants, for the automatic verification of a large class of parameterized systems. The method is based on the automatic calculation of candidate inductive assertions and checking for their inductiveness, using symbolic model-checking techniques for both tasks. First, we show how to use model-checking techniques over finite (and small) instances of the parameterized system in order to derive candidates for invariant assertions. Next, we show that the premises of the standard deductive INV rule for proving invariance properties can be automatically resolved by finite-state (BDD-based) methods with no need for interactive theorem proving. Combining the automatic computation of invariants with the automatic resolution of the VCs (verification conditions) yields a (necessarily) incomplete but fully automatic sound method for verifying large classes of parameterized systems. The generated invariants can be transferred to the VC-validation phase without ever been examined by the user, which explains why we refer to them as ‚Äúinvisible‚Äù. The efficacy of the method is demonstrated by automatic verification of diverse parameterized systems in a fully automatic and efficient manner."
2001,Beyond Regular Model Checking.,"Abstract
In recent years, it has been established that regular model checking can be successfully applied to several parameterized verification problems. However, there are many parameterized verification problems that cannot be described by regular languages, and thus cannot be verified using regular model checking. In this study we try to practice symbolic model checking using classes of languages more expressive than the regular languages. We provide three methods for the uniform verification of non-regular parameterized systems."
2001,From Falsification to Verification.,"Abstract
This paper enhances the linear temporal logic model checking process with the ability to automatically generate a deductive proof that the system meets its temporal specification. Thus, we emphasize the point of view that model checkingcan also be used to justify why the system actually works. We show that, by exploitingthe information in the graph that is generated during a failed search for counterexamples, we can generate a fully deductive proof that the system meets its specification."
2001,Range Allocation for Equivalence Logic.,"Abstract
The range allocation problem was recently introduced as part of an efficient decision procedure for deciding satisfiability of equivalence logic formulas with or without uninterpreted functions. These type of formulas are mainly used when proving equivalence or refinement between systems (hardware designs, compiler‚Äôs translation, etc). The problem is to find in polynomial time a small finite domain for each of the variables in an equality formula œÜ, such that œÜ is valid if and only if it is valid over this small domain. The heuristic that was presented for finding small domains was static, i.e. it finds a small set of integer constants for each variable. In this paper we show new, more flexible range allocation methods. We also show the limitations of these and other related approaches by proving a lower bound on the size of the state space generated by such procedures. To prove this lower bound we reduce the question to a graph theoretic counting question, which we believe to be of independent interest."
2001,Sticks and stones: a coding scheme for parameterized verification.,"We consider the problem of Uniform Algorithmic Verification of Parameterized Systems, which requires establishing in a single verification effort the correctness of a parameterized family of systems for any value of the parameter. As has been observed by several researchers, using regular expressions or equivalent formalisms (e.g. WS1S) as assertional language, we can perform symbolic model checking of systems of unbounded number of states.
We start by showing that the verification problem can be viewed as taking place in a space of 3 dimensions: Time, Control, and Data. We will illustrate how regular expressions can be naturally applied to deal with any of these dimensions in case it becomes unbounded. Unfortunately, extending the tool of regular expressions to 2 dimension leads to undecidability.
We therefore consider alternate ways of dealing with systems which have both unbounded control and unbounded data. By appropriate abstractions and encoding it is frequently possible to encode these two dimensions within a single dimension, using a coding scheme to which we refer as ‚Äústicks and stones‚Äù. The method will be illustrated on parameterized versions of the Bakery and Peterson's algorithms for mutual exclusion. Among other things, we will show that, in some cases, we can use languages more expressive than regular expressions and still get manageable verification algorithms. This is, for example, the case of Peterson's algorithm for N processes, which cannot be analyzed in terms of purely regular expressions."
2001,Automatic Deductive Verification with Invisible Invariants.,"Abstract
The paper presents a method for the automatic verification of a certain class of parameterized systems. These are bounded-data systems consisting of N processes (N being the parameter), where each process is finite-state. First, we show that if we use the standard deductive INV rule for proving invariance properties, then all the generated verification conditions can be automatically resolved by finite-state (BDD-based) methods with no need for interactive theorem proving.
Next, we show how to use model-checking techniques over finite (and small) instances of the parameterized system in order to derive candidates for invariant assertions. Combining this automatic computation of invariants with the previously mentioned resolution of the VCs (verification conditions) yields a (necessarily) incomplete but fully automatic sound method for verifying bounded-data parameterized systems. The generated invariants can be transferred to the VC-validation phase without ever been examined by the user, which explains why we refer to them as ‚Äúinvisible‚Äù.
We illustrate the method on a non-trivial example of a cache protocol, provided by Steve German."
2000,Verification of Clocked and Hybrid Systems.,"This paper presents a new computational model for real-time systems, called the clocked transition system (CTS) model. The CTS model is a development of our previous timed transition model, where some of the changes are inspired by the model of timed automata. The new model leads to a simpler style of temporal specification and verification, requiring no extension of the temporal language. We present verification rules for proving safety a nd liveness properties of clocked transition systems. All rules are associated with verification diagrams. The verification of response properties requires adjustments of the proof rules developed for untimed systems, reflecting the fact that progress in the real time systems is ensured by the progress of time and not by fairness. The style of the verification rules is very close to the verification style of untimed systems which allows the (re)use of verification methods and tools, developed for u ntimed reactive systems, for proving all interesting properties of real-time systems.
We conclude with the presentation of a branching-time based approach for verifying that an arbitrary given CTS is non-zeno. Finally, we present an extension of the model and the invariance proof rule for hybrid systems.

"
2000,Verification by Augmented Finitary Abstraction.,"The paper deals with the proof method of verification by finitary abstraction (VFA), which presents a feasible approach to the verification of the temporal properties of (potentially infinite-state) reactive systems. The method consists of a two-step process by which, in a first step, the system and its temporal specification are jointly abstracted into a finite-state system and a finite-state specification. The second step uses model checking to establish the validity of the abstracted property over the abstracted system. The VFA method can be considered a viable alternative to verification by temporal deduction which, up to now, has been the main method generally applicable for verification of infinite-state systems. The paper presents a general recipe for the joint abstraction, which is shown to be sound, where soundness means that validity over the abstract system implies validity over the concrete (original) system. To make the method applicable for the verification of liveness properties, pure abstraction is sometimes no longer adequate. We show that by augmenting the system by an appropriate (and standardly constructible) progress monitor, we obtain an augmented system, whose computations are essentially the same as the original system, and which may now be abstracted while preserving the desired liveness properties. We refer to the extended method as verification by augmented abstraction (VAA). We then proceed to show that the VAA method is sound and complete for proving all properties expressible by temporal logic (including both safety and liveness). Completeness establishes that whenever the property is valid, there exists a finitary abstraction which abstracts the system, augmented by an appropriate progress monitor, into a finite-state system which validated the abstracted property.
"
2000,Propositional Temporal Logics: Decidability and Completeness.,"A sound and complete axiomatic system and a tableau-based decision procedure are presented for propositional temporal logic over linear and discrete time models. The axiomatic system and decision procedure are presented for the full logic, including the past operators, but contain a clear identification of the parts whose omission yields axiomatization and a decision procedure for the future fragment. The paper summarizes work of over 20 years and is intended to provide a definitive reference to the version of propositional temporal logic used for the specification and verification of reactive systems.
"
2000,Control and Data Abstraction: The Cornerstones of Practical Formal Verification.,"In spite of the impressive progress in the development of the two main methods for formal verification of reactive systems ñ Symbolic Model Checking and Deductive Verification, they are still limited in their ability to handle large systems. It is generally recognized that the only way these methods can ever scale up is by the extensive use of abstraction and modularization, which break the task of verifying a large system into several smaller tasks of verifying simpler systems.
In this paper, we review the two main tools of compositionality and abstraction in the framework of linear temporal logic. We illustrate the application of these two methods for the reduction of an infinite-state system into a finite-state system that can then be verified using model checking.
The technical contributions contained in this paper are a full formulation of abstraction when applied to a system with both weak and strong fairness requirements and to a general temporal formula, and a presentation of a compositional framework for shared variables and its application for forming network invariants.
"
2000,Rigorous development of embedded systems.,"Opinions differ as to what are the main challenges posed by the meteoritically expanding area of embedded systems. Some consider communication and the correct blending of local-area and wide-area networks to be the main obstacle which, when overcome, will open the way to an accelerated development of the field. Others consider customized hardware to be the key that will open the last blocking lock. According to the opinion expressed in this talk, the most important problem, whose solution will greatly improve our ability to construct reliable embedded systems in a timely manner, is the development methodology and process. In this talk, we will outline a rigorous development approach which provides a seamless passage from requirements to running code (including customized hardware construction), where special care is taken to validate the correctness of each step in the process. The concept of the seamless development process for embedded systems grew out of the European Esprit project Sacres which constructed a prototype development environment for Safety Critical Systems. The components of the Sacres environment included executable system specification, using either the statebased specification language of Statecharts, or the dataflowbased specification language Sildex, or a combination thereof. It then translated this (combined) specification into a common format, and provided tools for the formal verification of the resulting design. The verification tools provided ìunit verificationî which could verify a single module or component within the design, using model-checking techniques. After this has been applied to some of the modules, one could invoke the tool of ìsystem verificationî which combines the results of unit verification to infer properties of bigger subsystems. Once the common design has been satisfactorily validated, the next development step invoked a code generator which translated the high-level specification into a running code program in a language of choice, such as C, Ada, or Java. As part of the code-generation process one could activate various allocation and optimization processes, the most relevant of which (for embedded systems) is that of code distribution. By this we mean that the user can earmark each of the activities/modules to be allocated to a node in a distributed architecture. On providing information about the communication regime in the distributed net, the code generator could also generate the necessary protocols for support of the application. An important element of the Sacres tool suit was that the translation performed by the code generator is continuously validated by a special code-validation tool. After presenting the capabilities of the Sacres kernel, we will proceed to outline the extensions that will stretch the scope of applicability of such a methodology to cover the full range from requirements to full implementation. The extensions are at both ends of the spectrum. At the low end, we will describe extensions which will enable these tools to add software/hardware partition in support of system co-design, and the appropriate techniques for hardware compilation, that will make customized hardware design part of the seamless process. At the upper end, we will discuss several approaches that will help the designers of an embedded system to formulate their requirements in either a visual style extending the popular message-sequence-charts notation, or by simulated test-driving of a mock-up of the system under construction. We will outline methods for automatic transformation from formal requirements into executable specifications. This will complete the top link of the seamless vertically integrated development process for embedded systems"
2000,"Keynote Address: Abstraction, Composition, Symmetry, and a Little Deduction: The Remedies to State Explosion.","Abstract
In this talk, we will consider possible remedies to the State Explosion problem, enabling the verification of large designs. All of these require some user interaction and cannot be done in a fully automatic manner. We will explore the tradeoffs and connections between the different approaches, such as deduction and abstraction, searching for the most natural and convenient mode of user interaction, and speculate about useful additional measures of automation which can make the task of user supervision even simpler."
2000,Liveness and Acceleration in Parameterized Verification.,"Abstract
The paper considers the problem of uniform verification of parameterizedsystems by symbolic model checking, using formulas in fs1s (a syntactic variant of the 2nd order logic ws1s) for the symbolic representation of sets of states. The technical difficulty addressed in this work is that, in many cases, standard model-checking computations fail to converge.
Using the tool tlv [P], we formulated a general approach to the acceleration of the transition relations, allowing an unbounded number of different processes to change their local state (or interact with their neighbor) in a single step. We demonstrate that this acceleration process solves the difficulty and enables an efficient symbolic model-checking of many parameterized systems such as mutual-exclusion and token-passing protocols for any value of N, the parameter specifying the size of the system.
Most previous approaches to the uniform verification of parameterized systems, only considered safety properties of such systems. In this paper, we present an approach to the verification of iveness properties and demonstrate its application to prove accessibility properties of the considered protocols."
2000,Formal Verification of the Ricart-Agrawala Algorithm.,"Abstract
This paper presents the first formal verification of the Ricart- Agrawala algorithm [RA81] for distributed mutual exclusion of an arbitrary number of nodes. It uses the Temporal Methodology of [MP95a]. We establish both the safety property of mutual exclusion and the liveness property of accessibility. To establish these properties for an arbitrary number of nodes, parameterized proof rules are used as presented in [MP95a] (for safety) and [MP94] (for liveness). A new and efficient notation is introduced to facilitate the presentation of liveness proofs by verification diagrams.
The proofs were carried out using the Stanford Temporal Prover (STeP) [BBC+95], a software package that supports formal verification of temporal specifications of concurrent and reactive systems."
2000,A Comparison of Two Verification Methods for Speculative Instruction Execution.,"Abstract
In this paper we describe and compare two methodologies for verifying the correctness of a speculative out-of-order execution system with interrupts. Both methods are deductive (we use PVS) and are based on refinement. The first proof is by direct refinement to a sequential system; the second proof combines refinement with induction over the number of retirement buffer slots."
1999,Proving Refinement Using Transduction.,"Summary.
When designing distributed systems, one is faced with the problem of verifying a refinement between two specifications, given at different levels of abstraction. Suggested verification techniques in the literature include refinement mappings and various forms of simulation. We present a verification method, in which refinement between two systems is proven by constructing a transducer that inputs a computation of a concrete system and outputs a matching computation of the abstract system. The transducer uses a FIFO queue that holds segments of the concrete computation that have not been matched yet. This allows a finite delay between the occurrence of a concrete event and the determination of the corresponding abstract event. This delay often makes the use of prophecy variables or backward simulation unnecessary. An important generalization of the method is to prove refinement modulo some transformation on the observed sequences of events. The method is adapted by replacing the FIFO queue by a component that allows the appropriate transformation on sequences of events. A particular case is partial-order refinement, i.e., refinement that preserves only a subset of the orderings between events of a system. Examples are sequential consistency and serializability. The case of sequential consistency is illustrated on a proof of sequential consistency of a cache protocol."
1999,Decidable Integration Graphs.,"Integration graphsare a computational model developed in the attempt to identify simple hybrid systems with decidable analysis problems. We start with the class ofconstant slope hybrid systems(CSHS), in which the right-hand side of all differential equations is an integer constant. We refer to continuous variables whose right-hand side constants are always 1 astimers. All other continuous variables are calledintegrators. The first result shown in the paper is that simple questions such as reachability of a given state are undecidable for even this simple class of systems. To restrict the model even further, we impose the requirement that no test that refers to integrators may appear within a loop in the graph. This restricted class of CSHS is calledintegration graphs. The main results of the paper are that the reachability problem of integration graphs is decidable for two special cases: the case of a single timer and the case of a single test involving integrators. The expressive power of the integration-graphs formalism is demonstrated by showing that some typical problems studied within the context of the calculus of durations and timed statecharts can be formulated as reachability problems for restricted integration graphs, and a high fraction of these fall into the subclasses of a single timer or a single test involving integrators.
"
1999,Translation Validation: From SIGNAL to C.,"Abstract
Translation validation is an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code produced on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation.
Since the validation process attempts to ‚Äúxunravel‚Äù the transformation effected by the translators, its task becomes increasingly more difficult (and necessary) with the increase of sophistication and variety of the optimizations methods employed by the translator. In this paper we address the practicability of translation validation for highly optimizing, industrial code generators from Signal, a widely used synchronous language, to C. We introduce new abstraction techniques as part of the automation of our approach."
1999,Deciding Equality Formulas by Small Domains Instantiations.,"Abstract
We introduce an efficient decision procedure for the theory of equality based on finite instantiations. When using the finite instantiations method, it is a common practice to take a range of [1..n] (where n is the number of input non-Boolean variables) as the range for all non-Boolean variables, resulting in a state-space of n n . Although various attempts to minimize this range were made, typically they either required various restrictions on the investigated formulas or were not very effective. In many cases, the n n state-space cannot be handled by BDD-based tools within a reasonable amount of time. In this paper we show that significantly smaller domains can be algorithmically found, by analyzing the structure of the formula. We also show an upper bound for the state-space based on this analysis. This method enabled us to verify formulas containing hundreds of integer and floating point variables."
1999,Verifying Liveness by Augmented Abstraction.,"Abstract
The paper deals with the proof method of verification by augmented finitary abstraction (VAA), which presents an effective approach to the verification of the temporal properties of (potentially infinitestate) reactive systems. The method consists of a two-step process by which, in a first step, the system and its temporal specification are combined an then abstracted into a finite-state B√ºchi automaton. The second step uses model checking to establish emptiness of the abstracted automaton.
The (VAA) method can be considered as a viable alternative to verification by temporal deduction which, up to now, has been the main method shown to be complete for the verification of infinite-state systems.
The paper presents a general recipe for the abstraction of B√ºchi automata which is shown to be sound, where soundness means that emptiness of the abstract automaton implies emptiness of the concrete (infinitestate) automaton. To make the method applicable for the verification of liveness properties, pure abstraction is sometimes no longer adequate.We show that by augmenting the system by an appropriate (and standardly constructible) progress monitor, we obtain an augmented system, whose computations are essentially the same as the original system, and which may now be abstracted while preserving the desired liveness properties. We then proceed to show that the (VAA) method is sound and complete for proving all properties expressible by temporal logic (including both safety and liveness). Completeness establishes that whenever an infinite-state B√ºchi automaton has no computations, there exists a finitary abstraction which abstracts the automaton, augmented by an appropriate progress monitor, into a finite-state B√ºchi automaton with no computations"
1999,A Perfect Verification: Combining Model Checking with Deductive Analysis to Verify Real-Life Software.,"Abstract
The paper presents an approach to the formal verification of a complete software system intended to support the flagship product of Perfecto Technologies which enforces application security over an open communication net.
Based on initial experimentation, it was decided that the verification method will be based on a combination of model-checking using spin with deductive verification which handles the more data-intensive elements of the design. The analysis was that only such a combination can cover by formal verification all the important aspects of the complete system.
In order to enable model checking of large portions of the design, we have developed an assume-guarantee approach which supports compositional verification. We describe how this general approach was implemented in the spin framework.
Then, we explain the need to split the verification activity into the modelchecking part which deals with the control issues such as concurrency or deadlocking and a deductive part which handles the data-intensive elements of the design."
1999,Orthogonal Polyhedra: Representation and Computation.,"Abstract
In this paper we investigate orthogonal polyhedra, i.e. polyhedra which are finite unions of full-dimensional hyper-rectangles. We define representation schemes for these polyhedra based on their vertices, and show that these compact representation schemes are canonical for all (convex and non-convex) polyhedra in any dimension. We then develop efficient algorithms for membership, face-detection and Boolean operations for these representations."
1999,A Framework for Scheduler Synthesis.,"Abstract:
We present a framework integrating specification and scheduler generation for real time systems. In a first step, the system, which can include arbitrarily designed tasks (cyclic or sporadic, with or without precedence constraints, any number of resources and CPUs) is specified as a timed Petri net. In a second step, our tool generates the most general non preemptive online scheduler for the specification, using a controller synthesis technique."
1999,Verifying Tomasulo's Algoithm by Refinement.,"Abstract:
In this paper Tomasulo's algorithm for out-of-order execution is shown to be a refinement of the sequential instruction execution algorithm. Correctness of Tomasulo's algorithm is established by proving that the register files of Tomasulo's algorithm and the sequential algorithm agree once all instructions have been completed."
1998,The Code Validation Tool CVT: Automatic Verification of a Compilation Process.,"We describe CVT - a fully automatic tool for code validation, i.e., verifying that the target code produced by a code-generator (equivalently, a compiler or a translator) is a correct implementation of the source specification. This approach is a viable alternative to a full formal verification of the code-generator program, and has the advantage of not ""freezing"" the code generator design after verification. CVT was developed in the context of the ESPRIT project SACRES, and validates the translation from StateMate/Slidex mixed specification into C. The use of novel techniques based on uninterpreted functions and their analysis over a BDD-represented small model enables us to validate source specifications of several thousand lines, which represents a typical industrial-size safety-critical application."
1998,A Fast Algorithm for Scheduling Time-Constrained Instructions on Processors with ILP.,"Abstract:
Instruction scheduling is central to achieving performance in modern processors with instruction level parallelism (ILP). Classical work in this area has spanned the theoretical foundations of algorithms for instruction scheduling with provable optimality, as well as heuristic approaches with experimentally validated performance improvements. Typically, the theoretical foundations are developed in the context of basic-blocks of code. In this paper, we provide the theoretical foundations for scheduling basic-blocks of instructions with time-constraints, which can play an important role in compile-time ILP optimizations in embedded applications. We present an algorithm for scheduling unit-execution-time instructions on machines with multiple pipelines, in the presence of precedence constraints, release-times, deadlines, and latencies l/sub ij/ between any pairs of instructions i and j. Our algorithm runs in time O(n/sup 3//spl alpha/(n)), where /spl alpha/(n) is the functional inverse of the Ackermann function. It can be used construct feasible schedules for two classes of instances: (1) one pipeline and the latencies between instructions are restricted to the values of 0 and 1, and (2) arbitrary number of pipelines and monotone-interval order precedences. Our result can be seen as a natural extension of previous work on instruction scheduling for pipelined machines in the presence of deadlines."
1998,Deductive vs. Model-Theoretic Approaches to Formal Verification (Abstract of Invited Talk).,"Abstract
The well-known duality between proof- and model-theoretic approaches in classic logic assumes even greater significance in the application of these approaches for formal verification of software and hardware designs.
In this talk, we will survey the main model-theoretic and deductive approaches to formal verification, as illustrated by enumerative and symbolic model checking techniques and deductive verification systems such as STeP, PVS, HOL, etc. We will motivate the current feeling that only the combination of these dual approaches will enable us to formally verify really complex and large systems. Some proposed ideas about how model-checking and deduction can be effectively combined in a mutually beneficial way will be described, and illustrated on simple case studies."
1998,Herbrand Automata for Hardware Verification.,"Abstract
The paper presents the new computational model of Herbrand engines which combines finite-state control with uninterpreted data and function registers, thus yielding a finite representation of infinite-state machines. Herbrand engines are used to provide a high-level model of out-of-order execution in the design of micro-processors. The problem of verifying that a highly parallel design for out-of-order execution correctly implements the Instruction Set Architecture is reduced to establishing the equivalence of two Herbrand engines. We show that, for a reasonably restricted class of such engines, the equivalence problem is decidable, and present two algorithms for solving this problem.
Ultimately, the appropriate statement of correctness is that the out-of-order execution produces the same final state (and all relevant intermediate actions, such as writes to memory) as a purely sequential machine running the same program."
1998,On Discretization of Delays in Timed Automata and Digital Circuits.,"Abstract
In this paper we solve the following problem: ‚Äúgiven a digital circuit composed of gates whose real-valued delays are in an integer-bounded interval, is there a way to discretize time while preserving the qualitative behavior of the circuit?‚Äù This problem is described as open in [BS94]. When ‚Äúpreservation of qualitative behavior‚Äù is interpreted in a strict sense, as having all original sequences of events with their original ordering we obtain the following two results:
1)
For acyclic (combinatorial) circuits whose inputs change only once, the answer is positive: there is a constant Œ¥, depending on the maximal number of possible events in the circuit, such that if we restrict all events to take place at multiples of Œ¥, we still preserve qualitative behaviors.
 2)
For cyclic circuits the answer is negative: a simple circuit with three gates can demonstrate a qualitative behavior which cannot be captured by any discretization.
  Nevertheless we show that a weaker notion of preservation, similar to that of [HMP92], allows in many cases to verify discretized circuits with Œ¥=1 such that the verification results are valid in dense time."
1998,Translation Validation: From DC+ to C*.,"Abstract
Translation validation is an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code produced on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation.
In this paper we demonstrate the feasibility of translation validation for industrial code generators from DC+ -a widely used intermediate format for synchronous languages- to C. We explain the compilation pattern from DC+ to C and advocate new abstraction techniques for a fragment of first order logic as part of the automation of our approach."
1998,Verification of Data-Insensitive CIrcuits: An In-Order-Retirement Case Study.,"Abstract
There is a large class of circuits (including pipeline and out-of-order execution components) which can be formally verified while completely ignoring the precise characteristics (e.g. word-size) of the data manipulated by the circuits. In the literature, this is often described as the use of uninterpreted functions, implying that the concrete operations applied to the data are abstracted into unknown and featureless functions. In this paper, we briefly introduce an abstract unifying model for such datainsensitive circuits, and claim that the development of such models, perhaps even a theory of circuit schemas, can significantly contribute to the development of efficient and comprehensive verification algorithms combining deductive as well as enumerative methods.
As a case study, we present in this paper an algorithm for out-of-order execution with in-order retirement and show it to be a refinement of the sequential instruction execution algorithm. Refinement is established by deductively proving (using pvs) that the register files of the out-of-order algorithm and the sequential algorithm agree at all times if the two systems are synchronized at instruction retirement time."
1998,Fair Synchronous Transition Systems and Their Liveness Proofs.,"Abstract
We present a compositional semantics of synchronous systems that captures both safety and progress properties of such systems. The fair synchronous transitions systems (Fsts) model we introduce in this paper extends the basic Œ±Sts model [KP96] by introducing operations for parallel composition, for the restriction of variables, and by addressing fairness. We introduce a weak fairness (justice) condition which ensures that any communication deadlock in a system can only occur through the need for external synchronization. We present an extended version of linear time temporal logic (Eltl) for expressing and proving safety and liveness properties of synchronous specifications, and provide a sound and compositional proof system for it."
1998,Algorithmic Verification of Linear Temporal Logic Specifications.,"Abstract
In this methodological paper we present a coherent framework for symbolic model checking verification of linear-time temporal logic (ltl) properties of reactive systems, taking full fairness into consideration. We use the computational model of a fair Kripke structure (fks) which takes into account both justice (weak fairness) and compassion (strong fairness). The approach presented here reduces the model checking problem into the question of whether a given FKS is feasible (i.e. has at least one computation).
The contribution of the paper is twofold: On the methodological level, it presents a direct self-contained exposition of full ltl symbolic model checking without resorting to reductions to either ctl or automata. On the technical level, it extends previous methods by dealing with compassion at the algorithmic level instead of adding it to the specification, and providing the first symbolic method for checking feasibility of fks's (equivalently, symbolically checking for the emptiness of Streett automata).
The presented algorithms can also be used (with minor modifications) for symbolic model-checking of ctl formulas over fair Kripke structures with compassion requirements."
1998,Translation Validation for Synchronous Languages.,"Abstract
Translation validations an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that, the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code producted on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation.
Since the validation process attempts to ‚Äúunravel‚Äù the transformation effected by the translators, its task becomes increasingly more difficult (and necessary) with the increase of sophistication and variety of the optimizations methods employed by the translator. In this paper we address the feasibility of translation validation for highly optimizing, industrial code generators from DC+, a widely used intermediate format for synchronous languages, to C."
1998,Modularization and Abstraction: The Keys to Practical Formal Verification.,"Abstract
In spite of the impressive progress in the development of the two main methods for formal verification of reactive systems ‚Äî Model Checking (in particular symbolic) and Deductive Verification, they are still limited in their ability to handle large systems. It is generally recognized that the only way these methods can ever scale up is by the extensive use of abstraction and modularization, which breaks the task of verifying a large system into several smaller tasks of verifying simpler systems.
In this methodological paper, we review the two main tools of compositionality and abstraction in the framework of linear temporal logic. We illustrate the application of these two methods for the reduction of an infinite-state system into a finite-state system that can then be verified using model checking.
The modest technical contributions contained in this paper are a full formulation of abstraction when applied to a system with both weak and strong fairness requirements and to a general temporal formula, and a presentation of a compositional framework for shared variables and its application for forming network invariants."
1998,Translation Validation.,"Abstract
We present the notion of translation validation as a new approach to the verification of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code produced on this run correctly implements the submitted source program. Several ingredients are necessary to set up the ‚Äî fully automatic ‚Äî translation validation process, among which are:
1.
A common semantic framework for the representation of the source code and the generated target code.
 2.
A formalization of the notion of ‚Äúcorrect implementation‚Äù as a refinement relation.
 3.
A syntactic simulation-based proof method which allows to automatically verify that one model of the semantic framework, representing the produced target code, correctly implements another model which represents the source.
  These, and other ingredients are elaborated in this paper, in which we illustrate the new approach in a most challenging case. We consider a translation (compilation) from the synchronous multi-clock data-flow language Signal to asynchronous (sequential) C-code."
1997,Some Progress in the Symbolic Verification of Timed Automata.,"Abstract
In this paper we discuss the practical difficulty of analyzing the behavior of timed automata and report some results obtained using an experimental BDD-based extension of KRONOS. We have treated examples originating from timing analysis of asynchronous boolean networks and CMOS circuits with delay uncertainties and the results outperform those obtained by previous implementations of timed automata verification tools."
1997,Symbolic Model Checking with Rich ssertional Languages.,"Abstract
The paper shows that, by an appropriate choice of a rich assertional language, it is possible to extend the utility of symbolic model checking beyond the realm of BDD-represented finite-state systems into the domain of infinite-state systems, leading to a powerful technique for uniform verification of unbounded (parameterized) process networks.
The main contributions of the paper are a formulation of a general framework for symbolic model checking of infinite-state systems, a demonstration that many individual examples of uniformly verified parameterized designs that appear in the literature are special cases of our general approach, verifying the correctness of the Futurebus+ design for all singlebus configurations, extending the technique to tree architectures, and establishing that the presented method is a precise dual to the top-down invariant generation method used in deductive verification."
1997,Verifying out-of-order executions.,n/a
1997,A Compositional Real-Time Semantics of STATEMATE Designs.,"Abstract
This paper presents a reference semantics for a verication tool currently under development allowing to verify temporal properties of embedded control sys- tems modelled using the StateMate system. The semantics reported divert from others reported in the literature [24] by faithfully modelling the semantics as supported in the StateMate simulation tool. It divers from the recent paper by Harel and Naamad [8] by providing a compositional semantics, a prerequisite for the support of compositional verication methods, and by the degree of math- ematical rigour. We use a variant of synchronous transition systems introduced by Manna and Pnueli [18] as base model for our semantics.
The StateMate modelling language constructs covered in this paper are Activity charts, modelling the functional decomposition of a design into subunits called activities as well as the information flow between these, and Statecharts, modelling reactive behaviour using the well established approach of hierarchically organized state-machines. We strive for a verication approach which is compositional w.r.t. the decomposition of systems into subsystems. This will allow activities of ‚Äúreasonable‚Äù complexity to be veried using symbolic model checking [5], [4], [19]. Larger activities will be veried on the basis of proof-systems relating properties of individual activities to properties of compound activities, using the well known assumption commitment paradigm [1], [21], [15]. A key topic for this paper is the construction of so called compositional models, which are ‚Äúrich enough‚Äù to model the StateMate parallel composition by intersection of the innite traces generated by the components of the parallel composition. Roughly, compositional models have to provide room for padding arbitrary (but still ‚Äúlegal‚Äù) environment interactions into computations of a component. Alternatively, the construction of compositional models can be phrased as a requirement on the model to support a sufficiently rich class of observables for assumption-commitment style reasoning to be complete. In this sense, this paper derives the set of atomic propositions included as observables in the assumption- commitment style temporal logic supported by the verication tool."
1997,Two Decades of Temporal Logic: Achievements and Challenges (Abstract).,
1997,Verifying Liveness Properties of Reactive Systems (Tutorial Abstract).,n/a
1997,Data-Structures for the Verification of Timed Automata.,"Abstract
In this paper we suggest numerical decision diagrams, a bdd-based data-structure for representing certain subsets of the Euclidean space, namely those encountered in verification of timed automata. Unlike other representation schemes, ndd's are canonical and provide for all the necessary operations needed in the verification and synthesis of timed automata. We report some preliminary experimental results."
1996,Using Ghost Variables to Prove Refinement.,"Abstract
We propose a method for proving refinement between programs, based on augmenting the program by ghost (auxiliary) variables and statements that assign values to these variables. We show that, in many cases, this augmentation can replace the need for an explicit refinement mapping from the variables of one system to the private variables of the other system. A novel feature of the proposed methodology is that the expressions assigned to the ghost variables may depend on the future. This may replace the need for prophecy variables that are defined by a decreasing induction and require some version of finite-image hypothesis. We believe that proving refinement by program augmentation leads to a more natural style of refinement and is easier to design and comprehend. Allowing future-dependent expressions in a program requires extensions to the temporal methodology for proving properties of programs. These extensions are explained and discussed in the paper."
1996,A Platform for Combining Deductive with Algorithmic Verification.,"Abstract
We describe a computer-aided verification system which combines deductive with algorithmic (model-checking) verification methods. The system, called tlv (for temporal verification system), is constructed as an additional layer superimposed on top of the cmu smv system, and can verify finite-state systems relative to linear temporal logic (ltl) as well as ctl specifications. The systems to be verified can be either hardware circuits written in the smv design language or finite-state reactive programs written in a simple programming language (spl).
The paper presents a common computational model which can support these two types of applications and a high-level interactive language tlv-Basic, in which temporal verification rules, proofs, and complex assertions can be written. We illustrate the efficiency and generality gained by combining deductive with algorithmic techniques on several examples, culminating in verification of fragments of the Futurebus+ system. In the analysis of the Futurebus+ system, we even managed to detect a bug that was not discovered in a previous model-checking analysis of this system."
1996,Verification of Clocked and Hybrid Systems.,"Abstract
This paper presents a new computational model for realtime systems, called the clocked transition system (CTS) model. The CTS model is a development of our previous timed transition model, where some of the changes are inspired by the model of timed automata. The new model leads to a simpler style of temporal specification and verification, requiring no extension of the temporal language. We present verification rules for proving safety properties (including time-bounded response properties) of clocked transition systems, and separate rules for proving (time-unbounded) response properties. All rules are associated with verification diagrams. The verification of response properties requires adjustments of the proof rules developed for untimed systems, reflecting the fact that progress in the real time systems is ensured by the progress of time and not by fairness. The style of the verification rules is very close to the verification style of untimed systems which allows the (re)use of verification methods and tools, developed for untimed reactive systems, for proving all interesting properties of real-time systems.
We conclude with the presentation of a branching-time based approach for verifying that an arbitrary given CTS is non-zeno.
Finally, we present an extension of the model and the invariance proof rule for hybrid systems."
1995,On the Learnability of Infinitary Regular Sets.,"In this paper we extend the automaton synthesis paradigm to infinitary languages, that is, to subsets of the set ?? of all infinite sequences over some alphabet ?. Our main result is a polynomial algorithm for learning a sub-class of the ?-regular sets from membership queries and counter-examples based on the framework suggested by Angluin (Angluin, D. (1987), Inform. and Comput.75, 87-106) for learning regular subsets of ?*.
"
1995,Reachability Analysis of Dynamical Systems Having Piecewise-Constant Derivatives.,"In this paper we consider a class of hybrid systems, namely dynamical systems with piecewise-constant derivatives (PCD systems). Such systems consist of a partition of the Euclidean space into a finite set of polyhedral sets (regions). Within each region the dynamics is defined by a constant vector field, hence discrete transitions occur only on the boundaries between regions where the trajectories change their direction.
With respect to such systems we investigate the reachability question: Given an effective description of the systems and of two polyhedral subsets P and Q of the state-space, is there a trajectory starting at some x?P and reaching some point in Q? Our main results are a decision procedure for two-dimensional systems, and an undecidability result for three or more dimensions.
"
1995,Timing analysis of asynchronous circuits using timed automata.,"Abstract
In this paper we present a method for modeling asynchronous digital circuits by timed automata. The constructed timed automata serve as ‚Äúmechanical‚Äù and verifiable objects for asynchronous sequential machines in the same sense that (untimed) automata do for synchronous machines. These results, combined with recent results concerning the analysis and synthesis of timed automata provide for the systematic Treatment of a large class of problems that could be treated by conventional simulation methods only in an ad-hoc fashion. The problems that can be solved due to the results presented in this paper include: the reachability analysis of a circuit with uncertainties in gate delays and input arrival times, inferring the necessary timing constraints on input signals that guarantee a proper functioning of a circuit and calculating the delay characteristics of the components required in order to meet some given behavioral specifications.
Notwithstanding the existence of negative theoretical results concerning the worst-case complexity of timed automata analysis algorithms, initial experimentation with the Kronos tool for timing analysis suggest that timed automata derived from circuits might not be so hard to analyze in practice."
1995,Verifying Clocked Transition Systems.,"Abstract
This paper presents a new computational model for real-time systems, called the clocked transition system (cts) model. The cts model is a development of our previous timed transition model, where some of the changes are inspired by the model of timed automata. The new model leads to a simpler style of temporal specification and verification, requiring no extension of the temporal language. We present verification rules for proving safety properties (including waiting-for and time-bounded response properties) of clocked transition systems, and separate rules for proving (time-unbounded) response properties. All rules are associated with verification diagrams. The verification of response properties requires adjustments of the proof rules developed for untimed systems, reflecting the fact that progress in the real time systems is ensured by the progress of time and not by fairness. The style of the verification rules is very close to the verification style of untimed systems which allows the (re)use of verification methods and tools, developed for untimed reactive systems, for proving properties of real-time systems."
1995,A Complete Proof Systems for QPTL.,"Abstract:
The paper presents an axiomatic system for quantified propositional temporal logic (QPTL), which is propositional temporal logic equipped with quantification over propositions (boolean variables). The advantages of this extended temporal logic is that its expressive power is strictly higher than that of the unquantified version (PTL) and is equal to that of SIS, as well as that of /spl omega/-automata. Another important application of QPTL is its use for formulating and verifying refinement relations between reactive systems. In fact, the completeness proof is based on the reduction of a QPTL formula into a Buchi automaton, and performing equivalence transformations on this automata, formally justifying these transformations."
1995,Once and For All.,"Abstract:
It has long been known that past-time operators add no expressive power to linear temporal logics. In this paper, we consider the extension of branching temporal logics with past-time operators. Two possible views regarding the nature of past in a branching-time model induce two different such extensions. In the first view, past is branching and each moment in time may have several possible futures and several possible pasts. In the second view, past is linear and each moment in time may have several possible futures and a unique past. Both views assume that past is finite. We discuss the practice of these extensions as specification languages, characterize their expressive power, and examine the complexity of their model-checking and satisfiability problems."
1995,On the Synthesis of Discrete Controllers for Timed Systems (An Extended Abstract).,"Abstract
This paper presents algorithms for the automatic synthesis of real-time controllers by finding a winning strategy for certain games defined by the timed-automata of Alur and Dill. In such games, the outcome depends on the players' actions as well as on their timing. We believe that these results will pave the way for the application of program synthesis techniques to the construction of real-time embedded systems from their specifications."
1994,Temporal Proof Methodologies for Timed Transition Systems.,"We extend the specification language of temporal logic, the corresponding verification framework, and the underlying computational model to deal with real-;time properties of reactive systems. The abstract notion of timed transition systems generalizes traditional transition systems conservatively: qualitative fairness requirements are replaced (and superseded) by quantitative lower-bound and upper-bound timing constraints on transitions. This framework can model real-time systems that communicate either through shared variables or by message passing and real-time issues such as timeouts, process priorities (interrupts), and process scheduling. We exhibit two styles for the specification of real-time systems. While the first approach uses time-bounded versions of the temporal operators, the second approach allows explicit references to time through a special clock variable. Corresponding to the two styles of specification, we present and compare two different proof methodologies for the verification of timing requirements that are expressed in these styles. For the bounded-operator style, we provide a set of proof rules for establishing bounded-invariance and bounded-responce properties of timed transition systems. This approach generalizes the standard temporal proof rules for verifying invariance and response properties conservatively. For the explicit-clock style, we exploit the observation that every time-bounded property is a safety property and use the standard temporal proof rules for establishing safety properties.
"
1994,Proving Partial Order Properties.,"A temporal verification method which is based upon partial order semantics of traces (Mazurkiewicz, 1987) is presented. The semantic model used here can express the distributed aspects of a program, e.g. properties such as serializability of database transactions, layering of a program, snapshots or the parallel execution of program segments. The proof rules are shown to be sound and relatively complete.
"
1994,Development of Hybrid Systems.,"Abstract
We consider goals and perspectives in the area of hybrid systems. In particular, we compare several semantic models, proof approaches, and temporal logics that were proposed for the formal treatment of hybrid systems."
1994,Prooving Safety Properties of Hybrid Systems.,"Abstract
We propose a methodology for the specification, verification, and design of hybrid systems. The methodology consists of the computational model of Concrete Phase Transition Systems (cptss), the specification language of Hybrid Temporal Logic (htl), the graphical system description language of Hybrid Automata, and a proof system for verifying that hybrid automata satisfy their HTL specifications.
The novelty of the approach lies in the continuous-time logic, which allows specification of both point-based and interval-based properties (i.e., properties which describe changes over an interval) and provides direct references to derivatives of variables, and in the proof system that supports verification of point-based and interval-based properties. The proof rules demonstrate that sound and convenient induction rules can be established for continuous-time logics. The proof rules are illustrated on several examples."
1994,Symbolic Controller Synthesis for Discrete and Timed Systems.,"Abstract
This paper presents algorithms for the symbolic synthesis of discrete and real-time controllers. At the semantic level the controller is synthesized by finding a winning strategy for certain games defined by automata or by timed-automata. The algorithms for finding such strategies need, this way or another, to search the state-space of the system which grows exponentially with the number of components. Symbolic methods allow such a search to be conducted without necessarily enumerating the state-space. This is achieved by representing sets of states using formulae (syntactic objects) over state variables. Although in the worst case such methods are as bad as enumerative ones, many huge practical problems can be treated by fine-tuned symbolic methods. In this paper the scope of these methods is extended from analysis to synthesis and from purely discrete systems to real-time systems.
We believe that these results will pave the way for the application of program synthesis techniques to the construction of real-time embedded systems from their specifications and to a solution of other related design problems associated with real-time systems in general and asynchronous circuits in particular."
1994,Compositional Verification of Real-Time Systems.,"Abstract:
Presents a compositional proof system for the verification of real-time systems. Real-time systems are modeled as timed transition modules, which explicitly model interaction with the environment and may be combined using composition operators. Composition rules are devised such that the correctness of a system may be determined from the correctness of its components. These proof rules are demonstrated on Fischer's mutual exclusion algorithm, for which mutual exclusion and bounded response are proven.< >"
1994,Temporal Verification Diagrams.,"Abstract
Most formal approaches to the verification of temporal properties of reactive programs infer temporal conclusions from verification conditions that are state formulas, i.e., contain no temporal operators. These proofs can often be effectively presented by the use of verification diagrams. In this paper, we present a self-contained presentation of verification diagrams for proving various temporal properties.
Beginning with safety properties, we present WAIT-POR and INVARIANCE diagrams for proving wait-for (precedence) and invariance formulas. Proceeding to liveness properties, we present verification diagrams for response properties that require a bounded number of helpful steps (CHAIN diagrams) and response properties that require an unbounded number of helpful steps (RANK diagrams).
Additional types of diagrams are proposed for handling response properties for parameterized programs (e.g., P-RANK diagrams) and response properties that rely on the full spectrum of fairness requirements, including compassionate helpful transitions (e.g., F-CHAIN diagrams)."
1993,Models for Reactivity.,"Abstract
A hierarchy of models that capture realistic aspects of reactive, real-time, and hybrid systems is introduced. On the most abstract level, the qualitative (non-quantitative) model ofreactive systems captures the temporal precedence aspect of time. A more refined model is that ofreal-time systems, which represents the metric aspect of time. The third and most detailed model is that ofhybrid systems, which allows the incorporation ofcontinuous components into a reactive system.
For each of the three levels, we present a computational model, a requirement specification language based on extensions of temporal logic, system description languages based on Statecharts and a textual programming language, proof rules for proving validity of properties, and examples of such proofs."
1993,Probabilistic Verification.,"Probabilistic elements are often introduced in concurrent programs in order to solve problems that either cannot be solved efficiently or cannot be solved at all by deterministic programs. Temporal logic is often used to specify the correctness conditions of concurrent programs. The paper presents a procedure that, given a probabilistic finite state program and a (restricted) temporal logic specification, decides whether the program satisfies its specification with probability 1. The paper also presents the notion of ?-fairness and shows that a program satisfies its temporal specification with probability 1 if and only if all its ?-fair computations satisfy the property.
"
1993,A Decision Algorithm for Full Propositional Temporal Logic.,"Abstract
The paper presents an efficient algorithm for checking the satisfiability of a propositional linear time temporal logic formula, which may have past as well as future operators. This algorithm can be used to check validity of such formulas over all models as well as over computations of a finite-state program (model checking). Unlike previous theoretical presentations of a decision method for checking satisfiability or validity, whose first step is to construct the full set of all possible atoms of a tableau (satisfaction graph) and immediately pay the worst case exponential complexity price, the algorithm presented here builds the tableau incrementally. This means that the algorithm constructs only those atoms that are reachable from a possible initial atom, satisfying the formula to be checked.
While incremental tableau construction for the future fragment of linear time temporal logic can be done in a single pass, the presence of past operators requires multiple passes that successively construct augmented versions of existing atoms, while still maintaining consistency and reachability.
The proof of correctness of the algorithm is based on showing that any model of the considered formula is embedded as a path in the tableau at all the construction stages, and can be delineated when the construction terminates.
The paper also describes an implementation of the algorithm with further attention to efficiency. This implementation is available as a support system for the book [8] under the name ‚Äútemporal prover‚Äù. It has been used to verify all the propositional temporal formulas and to model-check all the finite-state programs appearing in the book."
1993,Reachability Analysis of Planar Multi-limear Systems.,"Abstract
In this paper we study the reachability analysis of a simple class of hybrid systems, namely multi-linear systems. Such systems consist of a partition of the Euclidean space into a finite set of polyhedral sets (regions). Within each region the dynamics is defined by a constant vector field, hence the discrete transitions occur only on the boundaries between the regions where the trajectories change their direction. Such a system can be described by a finite set of guarded commands where the guards are conjunctions of linear inequalities and the commands are differential equations with constant right hand sides, corresponding to the vector fields.
Our goal is to verify, based on the description of the system, various reachability questions between regions of the plane. In particular we show that in planar deterministic systems, the question whether there exists a trajectory connecting a state in a source region to a state in a target region is decidable."
1993,In and Out of Temporal Logic.,"Abstract:
Two-way translations between various versions of temporal logic and between temporal logic over finite sequences and star-free regular expressions are presented. The main result is a translation from normal-form temporal logic formulas to formulas that use only future operators. The translation offers a new proof to a theorem claimed by D. Gabbay et al. (1980), stating that restricting temporal logic to the future operators does not impair its expressive power. The theorem is the basis of many temporal proof systems.< >"
1993,Temporal Verification of Simulation and Refinement.,"Abstract
The paper presents temporal logic methods for proving simulation and refinement relations between programs. After introducing the notions of fair transition systems and the specification language of temporal logic, we present proof rules for verifying properties of programs. We then define the relations of simulation and refinement between programs and relate them to inclusion relations between computations and observations of the compared systems.
We then show that these semantic definitions can be formalized in temporal logic by the use of the temporal and observational semantics formulas. This representation expresses simulation and refinement as implications between a pair of such formulas. We provide proof rules, based on the rules for verifying program properties. The proof rules are illustrated on several simple examples. Towards the end, we recognize the usefulness of having a stuttering robust version of temporal logic.
The second part of the paper presents a proposed temporal logic, called TLR, which is insensitive to stuttering. This logic is interpreted over sequences of sarnpling points, alternating between persistent and transient sample points. This logic possesses an idempotent next-time operator, which gives some insight into its stuttering robustness. We present a decision procedure and a complete axiomatic system for the propositional version of TLR. It is shown that, if all system variables are taken to be left-continuous, then most of the rules of regular temporal logic are still sound for TLR.
Finally, we present a stronger proof rule for refinement, and illustrate its use to prove refinement of two programs that cannot be done within the regular temporal logic framework."
1992,How Vital is Liveness? Verifying Timing Properties of Reactive and Hybrid Systems (Extended Abstract).,"Abstract
This extended abstract discusses the importance of the notion of liveness properties and their verification. The main observation is that they provide a most useful abstraction on the qualitative (non-quantitative) level of modeling. As we construct more refined models that take real-time into account, the importance of liveness and fairness decrease, and many important properties move to the safety class.
In the talk to be presented, we propose a framework for the formal specification and verification of timed and hybrid systems. For timed systems we propose a specification language that refers to time only through age functions which measure the length of the most recent time interval in which a given formula has been continuously true.
We then consider hybrid systems, which are systems consisting of a non-trivial mixture of discrete and continuous components, such as a digital controller that controls a continuous environment. The proposed framework extends the temporal logic approach which has proven useful for the formal analysis of discrete systems such as reactive programs. The new framework consists of a semantic model for hybrid time, the notion of phase transition systems, which extends the formalism of discrete transition systems, an extended version of Statecharts for the specification of hybrid behaviors, and an extended version of temporal logic that enables reasoning about continuous change.
The talk is based on extensive collaboration with Z. Manna, T. Henzinger, O. Maler, and Y. Kesten, whose results are reported in [HMP91], [MMP92], and [KP92]."
1992,System Specification and Refinement in Temporal Logic.,"Abstract
We consider two types of specifications of reactive systems: requirement specification which lists properties the system should satisfy, and System specification which describes the response of the system to each incoming input. Some of the differences between these two styles of specification are analyzed with the conclusion that both types are needed in an orderly system development.
Traditionally, temporal logic was used for requirement specification while process algebras, such as csp and ccs, were used for system specification. Recent developments, mainly represented in Lamport's temporal logic of actions (tla), demonstrated that temporal logic can be used effectively also for system specification.
This paper explores the use of temporal logic for systems specification, evaluates some of the advantages and disadvantages of such a use, and demonstrates the use of temporal logic for refinement and systematic development of systems. To allow simulation of a single high level step by several lower level steps, we go back to the temporal logic tlr which is based on a dense time domain, such as the reals."
1992,Timed and Hybrid Statecharts and Their Textual Representation.,"Abstract
A structured operational semantics is presented for Timed and Hybrid Statecharts, which are generalizations of the visual specification language of Statecharts intended to model real-time and hybrid systems. In order to study some of the basic features of Statecharts and the extensions necessary to treat real-time and continuous behaviors without being distracted by the graphical representation, we introduce a concurrent real-time language that can be viewed as a textual representation of Statecharts.
The language contains statements for delays, preemption, and timeouts. A structured operational semantics of the language and an illustrative example of its use for specification are presented. Extensions to the specification of hybrid systems are obtained by allowing a differential equation as a statement of the extended language. Structured operational semantics is also given for the hybrid version.
The same extensions are then applied to the visual Statechart language, and similar compositional semantics are defined."
1992,Verifying Hybrid Systems.,"Abstract
Hybrid systems are modeled as phase transition systems with sampling semantics. By identifying a set of important events it is ensured that all significant state changes are observed, thus correcting previous drawbacks of the sampling computations semantics. A proof rule for verifying properties of hybrid systems is presented and illustrated on several examples."
1992,Towards Refining Temporal Specifications into Hybrid Systems.,"Abstract
We propose a formal framework for designing hybrid systems by stepwise refinement. Starting with a specification in hybrid temporal logic, we make successively more transitions explicit until we obtain an executable system."
1992,Integration Graphs: A Class of Decidable Hybrid Systems.,"Abstract
Integration Graphs are a computational model developed in the attempt to identify simple Hybrid Systems with decidable analysis problems. We start with the class of constant slope hybrid systems (cshs), in which the right hand side of all differential equations is an integer constant. We refer to continuous variables whose right hand side constants are always 1 as timers. All other continuous variables are called integrators. The first result shown in the paper is that simple questions such as reachability of a given state are undecidable for even this simple class of systems.
To restrict the model even further, we impose the requirement that no test that refers to integrators may appear within a loop in the graph. This restricted class of cshs is called integration graphs. The main results of the paper are that the reachability problem of integration graphs is decidable for two special cases: The case of a single timer and the case of a single test involving integrators.
The expressive power of the integration graphs formalism is demonstrated by showing that some typical problems studied within the context of the Calculus of Durations and Timed Statecharts can be formulated as reachability problems for restricted integration graphs, and a high fraction of these fall into the subclasses of a single timer or a single dangerous test."
1992,Characterization of Temporal Property Classes.,"Abstract
This paper presents two novel characterizations of the classes of properties of reactive systems in terms of their expression by temporal logic. The first family of characterizations concerns the safety-progress classification, which describes a hierarchy within the set of temporal properties. Previous characterizations of this hierarchy depended critically on the use of past temporal operators. The characterization presented here identifies the future formulas that belong to each class. This characterization is shown to be complete.
The second characterization concerns the safety-liveness classification, which partitions temporal properties into the classes of safety and liveness. While automata-theoretic and temporal logic characterizations of the safety class have been known for some time, a complete characterization of the liveness class by temporal logic remained open. This paper provides such a characterization."
1992,What Good Are Digital Clocks?,"Abstract
Real-time systems operate in ‚Äúreal,‚Äù continuous time and state changes may occur at any real-numbered time point. Yet many verification methods are based on the assumption that states are observed at integer time points only. What can we conclude if a real-time system has been shown ‚Äúcorrect‚Äù for integral observations?
Integer time verification techniques suffice if the problem of whether all real-numbered behaviors of a system satisfy a property can be reduced to the question of whether the integral observations satisfy a (possibly modified) property. We show that this reduction is possible for a large and important class of systems and properties: the class of systems includes all systems that can be modeled as timed transition systems; the class of properties includes time-bounded invariance and time-bounded response."
1992,Time for Concurrency.,"Abstract
A hierarchy of models that capture realistic aspects of reactive and real-time systems is introduced. On the most abstract level, the qualitative (non-quantitative) model captures the temporal precedence aspect of time. A more refined model is that of timed transition systems, representing the metric aspects of time. The third and most detailed model is that of hybrid systems. This model allows the incorporation of continuous components into the studied reactive system."
1992,A Temporal Proof Methodology for Reactive Systems.,"Abstract
The paper presents a minimal proof theory which is adequate for proving the main important temporal properties of reactive programs. The properties we consider consist of the classes of invariance, response, and precedence properties. For each of these classes we present a small set of rules that is complete for verifying properties belonging to this class. We illustrate the application of these rules on several examples. We discuss concise presentations of complex proofs using the devices of transition tables and proof diagrams."
1991,Completing the Temporal Picture.,"The paper presents a relatively complete proof system for proving the validity of temporal properties of reactive programs. The presented proof system improves on previous temporal systems, in that it reduces the validity of program properties into pure assertional reasoning, not involving additional temporal reasoning. The proof system is based on the classification of temporal properties according to the Borel hierarchy, providing appropriate proof rules for the classes of safety, response, and reactivity properties.
"
1991,On the Learnability of Infinitary Regular Sets.,n/a
1991,Specifying and Proving Serializability in Temporal Logic.,"Abstract:
Serializability of database transactions is first defined within the framework of linear temporal logic. For commutativity-based serializability, an alternative specification is given in a temporal logic whose semantic interpretation is especially tailored for reasoning about equivalence sequences of histories. The alternative specification method is given in ISTL* and is limited to the specification of concurrency control algorithms based on commutativity. A formal verification system for serializability that uses classical logic reasoning is provided. Within it, proving serializability of transactions executing a concurrency control algorithm is done along the same lines as proving properties of concurrent programs. Serializability for the multiversion-timestamp algorithm is verified.< >"
1991,On the Faithfulness of Formal Models.,"Abstract
The paper presents a critical examination of the way certain central aspects of concurrent programs are formally modeled. The main formal model examined is the operational model of fair transition system which represents concurrency by interleaving of actions considered atomic. Several questions concerning the faithfulness of this representation naturally arise. The paper considers some of these questions and, while presenting and analyzing some of the alternatives, attempts to justify the design decisions actually taken in the construction of the model."
1991,Communication with Directed Logic Variables.,n/a
1991,Temporal Proof Methodologies for Real-time Systems.,n/a
1991,Timed Transition Systems.,"Abstract
We incorporate time into an interleaving model of concurrency. In timed transition systems, the qualitative fairness requirements of traditional transition system are replaced (and superseded) by quantitative lower-bound and upperbound timing constraints on transitions. The purpose of this paper is to explore the scope of applicability for the abstract model of timed transition systems. We demonstrate that the model can represent a wide variety of phenomena that routinely occur in conjunction with the timed execution of concurrent processes. Our treatment covers both processes that are executed in parallel on separate processors and communicate either through shared variables or by message passing, and processes that time-share a limited number of processors under a given scheduling policy. Often it is this scheduling policy that determines if a system meets its real-time requirements. Thus we explicitly address such questions as time-outs, interrupts, static and dynamic priorities."
1991,From Timed to Hybrid Systems.,"Abstract
We propose a framework for the formal specification and verification of timed and hybrid systems. For timed systems we propose a specification language that refers to time only through age functions which measure the length of the most recent time interval in which a given formula has been continuously true.
We then consider hybrid systems, which are systems consisting of a non-trivial mixture of discrete and continuous components, such as a digital controller that controls a continuous environment. The proposed framework extends the temporal logic approach which has proven useful for the formal analysis of discrete systems such as reactive programs. The new framework consists of a semantic model for hybrid time, the notion of phase transition systems, which extends the formalism of discrete transition systems, an extended version of Statecharts for the specification of hybrid behaviors, and an extended version of temporal logic that enables reasoning about continuous change."
1991,What is in a Step: On the Semantics of Statecharts.,"Abstract
This paper presents a proposal for the definition of a step in the execution of a statechart. The proposed semantics maintains the synchrony hypothesis, by which the system is infinitely faster than its environment, and can always finish computing its response before the next stimulus arrives. However, it corrects some inconsistencies present in previous definitions, by requiring global consistency of the step."
1990,STATEMATE: A Working Environment for the Development of Complex Reactive Systems.,"Abstract:
STATEMATE is a set of tools, with a heavy graphical orientation, intended for the specification, analysis, design, and documentation of large and complex reactive systems. It enables a user to prepare, analyze, and debug diagrammatic, yet precise, descriptions of the system under development from three interrelated points of view, capturing structure, functionality, and behavior. These views are represented by three graphical languages, the most intricate of which is the language of statecharts, used to depict reactive behavior over time. In addition to the use of statecharts, the main novelty of STATEMATE is in the fact that it understands the entire descriptions perfectly, to the point of being able to analyze them for crucial dynamic properties, to carry out rigorous executions and simulations of the described system, and to create running code automatically. These features are invaluable when it comes to the quality and reliability of the final outcome.<>"
1990,Tight Bounds on the Complexity of Cascaded Decomposition of Automata.,"Abstract:
Exponential upper and lower bounds on the size of the cascaded (Krohn-Rhodes) decomposition of automata are given. These results are used to obtain elementary algorithms for various translations between automata and temporal logic, where the previously known translations were nonelementary. The relevance of the result is discussed.< >"
1990,Distributed Reactive Systems Are Hard to Synthesize.,"Abstract:
The problem of synthesizing a finite-state distributed reactive system is considered. Given a distributed architecture A, which comprises several processors P/sub 1/, . . ., P/sub k/ and their interconnection scheme, and a propositional temporal specification phi , a solution to the synthesis problem consists of finite-state programs Pi /sub 1/, . . ., Pi /sub k/ (one for each processor), whose joint (synchronous) behavior maintains phi against all possible inputs from the environment. Such a solution is referred to as the realization of the specification phi over the architecture A. Specifically, it is shown that the problem of realizing a given propositional specification over a given architecture is undecidable, and it is nonelementarily decidable for the very restricted class of hierarchical architectures. An extensive characterization of architecture classes for which the realizability problem is elementarily decidable and of classes for which it is undecidable is given.< >"
1990,Proving Partial Order Liveness Properties.,"Abstract
A temporal verification method which is based upon partial order semantics of traces [31] is presented. The semantic model used here can express the distributed nature of a program. E.g., properties such as serializability of database transactions, layering of a program, snapshots or the parallel execution of program segments."
1990,An interleaving model for real-time.,"Abstract:
Real-time is incorporated into the interleaving model, which is used for the practical specification and verification of many properties of concurrent systems, by defining the abstract notion of a real-time transition system as a conservative extension of traditional transition systems. Qualitative fairness requirements are replaced (and superseded) by quantitative lower-bound and upper-bound real-time requirements for transitions. Proof rules are presented and used to establish lower and upper real-time bounds for response properties of real-time transition systems. This proof system can be used to verify bounded-invariance and bounded-response properties, such as timely termination of shared-variables multiprocessing systems whose semantics is defined in terms of real-time transition systems.< >"
1990,A temporal proof methodology for reactive systems.,"Abstract:
A minimal proof theory that is adequate for proving the main important temporal properties of reactive programs is presented. The properties considered consist of the classes of invariance and response properties. For each of these classes a small set of rules that is complete for verifying properties belonging to the class is given. The application of these rules is illustrated by several examples. Concise presentations of complex proofs using the devices of transition tables and proof diagrams are discussed.< >"
1990,Explicit Clock Temporal Logic.,"Abstract:
The authors present a single exponent decision procedure for the validity of XCTL formulas, and a double exponent decision procedure for the validity of XCTL formulas over finite state programs (model checking). The expressive power of XCTL is compared with that of some other logics proposed for the expression of real time properties. It is shown that it is incomparable with the expressive power of the recently proposed logic TPTL (timed propositional temporal logic).< >"
1990,A Hierarchy of Temporal Properties.,"We propose a classification of temporal properties into a hierarchy which refines the known safety-liveness classification of properties. The new classification recognizes the classes of safety, guarantee, persistence, fairness, and hyper-fairness. The classification suggested here is based on the different ways a property of finite computations can be extended into a property of infinite computations. For properties that are expressible by temporal logic and predicate automata, we provide a syntactic characterization of the formulae and automata that specify properties in the different classes. We consider the verification of properties over a given program, and provide a unique proof principle for each class."
1989,Learning omega-Regular Languages from Queries and Counter-Examples (A Preliminary Report).,"Abstract
In this paper we discuss problems concerning the learnability of œâ-regular languages from examples via the synthesis of their corresponding finite-state acceptors. The main technical contribution of this paper is a polynomial algortihm that learns a sub-class of the œâ-regular languages from queries and counter-examples. A similar setting has been suggested in [Ang87] for learning (finitary) regular languages. The algorithm given there produces the minimal automaton accepting the desired language using polynomially many (in the number of states) queries and computation steps. Our algorithm tackles some special problems that arise when adapting this framework to the infinitary case."
1989,Completing the Temporal Picture.,"Abstract
The paper presents a relatively complete proof system for proving the validity of temporal properties of reactive programs. The presented proof system improves on previous temporal systems, such as [MP83a] and [MP83b], in that it reduces the validity of program properties into pure assertional reasoning, not involving additional temporal reasoning. The proof system is based on the classification of temporal properties according to the Borel hierarchy, providing an appropriate proof rule for each of the main classes, such as safety, response, and progress properties."
1989,On the Synthesis of an Asynchronous Reactive Module.,"Abstract
We consider the synthesis of a reactive asynchronous module which communicates with its environment via the shared input variable x and the shared output variable y, assuming that the module is specified by the linear temporal formula œï(x,y). We derive from œï(x,y) another linear formula œá(r,w,x,y), with the additional scheduling variables r,w, and show that there exists a program satisfying œï iff the branching time formula (‚àÄr,w,x)(‚àÉy)Aœá(r,w,x,y) is valid over all tree models. For the restricted case that all variables range over finite domains, the validity problem is decidable, and we present an algorithm, of doubly exponential time and space complexity, for constructing a program that implements the specification whenever it is implementable. In addition, we provide some matching lower bounds."
1989,Specification and verification of VLSI systems.,"Abstract:
A hardware verification approach based on linear time temporal logic is described. The authors show that by introducing appropriate abbreviations into linear temporal logic, which facilitate the expression of precise timing constraints, they obtain a very convenient language for the description of the behavior of hardware systems, and for the development of a formal verification system used in proving that designs meet their specifications. The authors automatically verified several sequential circuits. As an example they describe the specification and verification of an edge-triggered D-type flip-flop and the discovery of an error in a published specification. It is demonstrated that the approach is practical and offers a viable alternative to simulation. Comparison is made with other formal methods.< >"
1989,On the Synthesis of a Reactive Module.,"We consider the synthesis of a reactive module with input x and output y, which is specified by the linear temporal formula @@@@(x, y). We show that there exists a program satisfying @@@@ iff the branching time formula (‚àÄx) (‚àÉy) A@@@@(x, y) is valid over all tree models. For the restricted case that all variables range over finite domains, the validity problem is decidable, and we present an algorithm for constructing the program whenever it exists. The algorithm is based on a new procedure for checking the emptiness of Rabin automata on infinite trees in time exponential in the number of pairs, but only polynomial in the number of states. This leads to a synthesis algorithm whose complexity is double exponential in the length of the given specification."
1988,The grammar of dimensions in machine drawings.,"Dimensioning is an important constituent in machine drawings. Recognition of dimensions in machaine drawings is a prerequisite for the development of a machine drawing understanding system (MDUS), which is a special class of image understanding systems (IUSs). The approach proposed in this work is a syntactic analysis of the dimensions, which are represented by undirected, labeled graphs called ìwebsî. Utilizing the conventions of web grammar, a set of web rewriting rules is established, which specify how all the possible dimension-sets can be generated and detected. The recognition process starts by detecting arrows using statistical methods. The location and orientation of the arrows together with rewriting rules of the dimensioning grammar are used to detect the rest of the components and the tree structure of the corresponding dimension set.
"
1988,A Framework for the Synthesis of Reactive Modules.,"Abstract
We consider the synthesis of a reactive module with input x and output y, which is specified by the linear temporal formula œï(x, y). We show that there exists a program satisfying œï iff the branching time formula (‚àÄx)(‚àÉy)Aœï(x, y) is valid over all tree models."
1988,Applications of Temporal Logic to the Specification of Real-time Systems.,n/a
1988,STATEMATE; A Working Environment for the Development of Complex Reactive Systems.,"This paper provides a brief overview of the STATEMATE system, constructed over the past three years by i-Logix Inc., and Ad Cad Ltd. STATEMATE is a graphical working environment, intended for the specification, analysis, design and documentation of large and complex reactive systems, such as real-time embedded systems, control and communication systems, and interactive software. It enables a user to prepare, analyze and debug diagrammatic, yet precise, descriptions of the system under development from three inter-related points of view, capturing, structure, functionality and behavior. These views are represented by three graphical languages, the most intricate of which is the language of statecharts used to depict reactive behavior over time. In addition to the use of state-charts, the main novelty of STATEMATE is in the fact that it `understands` the entire descriptions perfectly, to the point of being able to analyze them for crucial dynamic properties, to carry out rigorous animated executions and simulations of the described system, and to create running code automatically. These features are invaluable when it comes to the quality and reliability of the final outcome."
1988,The anchored version of the temporal framework.,"Abstract
In this survey paper we present some of the recent developments in the temporal formal system for the specification, verification and development of reactive programs. While the general methodology remains very much the one presented in some earlier works on the subject, such as [MP83c,MP83a,Pnu86], there have been several technical improvements and gained insights in understanding the computational model, the logic itself, the proof system and its presentation, and connections with alternative formalisms, such as finite automata. In this paper we explicate some of these improvements and extensions.
The main difference between this and preceding versions is that here we consider a notion of validity for temporal formulae, which is anchored at the initial state of the computation. The paper discusses some of the consequences of this decision."
1987,Very High Level Concurrent Programming.,"Abstract:
Concurrent systems are typically large and complex, requiring long, development time and much labor. They are, therefore, prime candidates for simplification and automation of the design and programming process. Their major application areas include real time systems, operating systems and cooperative computation. New applications are emerging with the trends towards wide usage of personal computers connected in a network and towards use of parallel processing in supercomputer architectures."
1987,On the Formal Semantics of Statecharts (Extended Abstract).,n/a
1987,A Hierarchy of Temporal Properties (Abstract).,n/a
1987,Specification and Verification of Concurrent Programs By Forall-Automata.,"‚àÄ-automata are non-deterministic finite-state automata over infinite sequences. They differ from conventional automata in that a sequence is accepted if all runs of the automaton over the sequence are accepting. These automata are suggested as a formalism for the specification and verification of temporal properties of concurrent programs. It is shown that they are as expressive as extended-temporal-logic (ETL), and in some cases provide a more compact representation of properties than temporal logic. A structured diagram notation is suggested for the graphical representation of these automata. A single sound and complete proof rule is presented for proving that all computations of a program have the property specified by a ‚àÄ-automaton."
1987,Specification and Implementation of Concurrently Accessed Data Structures: An Abstract Data Type Approach.,"Abstract
In this paper, we extended abstract data types methods to the question of the specification and the implementation of data structures accessed concurrently by several processes. Our approach provides the underlying theory for modularity and development by a stepwise refinement strategy of such systems.
We have identified the properties that must be checked in order to prove that an implementation is correct. They consist of two groups: the first one is similar to the properties usually required when proving the implementation of a classical, non-concurrent algebraic specification; they are dealt with in the usual fashion. The second group states that no new, undesirable interleavings occur in the implementation; we have designed a proof method for this.
One direction of future research, is to investigate the introduction of more sophisticated primitives for the construction of non-atomic processes (conditionals, guarded choice,...). Several new questions then arise; in particular, our notion of strong implementation should be refined, and our proof methods extended accordingly."
1987,Specification and Verification of Concurrent Programs by forall-Automata.,"Abstract
‚àÄ-automata are non-deterministic finite-state automata over infinite sequences. They differ from conventional automata in that a sequence is accepted if all runs of the automaton over the sequence are accepting. These automata are suggested as a formalism for the specification and verification of temporal properties of concurrent programs. It is shown that they are as expressive as extended temporal logic (ETL), and, in some cases, provide a more compact representation of properties than temporal logic. A structured diagram notation is suggested for the graphical representation of these automata. A single sound and complete proof rule is presented for proving that all computations of a program have the property specified by a ‚àÄ-automaton."
1986,Verification of Multiprocess Probabilistic Protocols.,"Abstract
In this paper we demonstrate the utility of temporal logic to the formal verification of probabilistic distributed programs. The approach taken is to represent the quantitative notion of probabilistic computations by the qualitative abstraction ofextreme fairness. The method is illustrated first on the dining philosophers problem [3] and then on a new probabilistic symmetric solution to then-processes mutual exclusion problem. Two related solutions are presented corresponding to different assumptions about the granularity of a compound test."
1986,Specification and Development of Reactive Systems (Invited Paper).,n/a
1986,A Choppy Logic.,n/a
1986,Probabilistic Verification by Tableaux.,n/a
1986,A Really Abstract Concurrent Model and its Temporal Logic.,"In this paper we advance the radical notion that a computational model based on the <i>reals</i> provides a more abstract description of concurrent and reactive systems, than the conventional <i>integers</i> based behavioral model of execution <i>sequences.</i> The real model is studied in the setting of temporal logic, and we illustrate its advantages by providing a <i>fully abstract</i> temporal semantics for a simple concurrent language, and an example of verification of a concurrent program within the real temporal logic defined here. It is shown that, by imposing the crucial condition of <i>finite variability,</i> we achieve a balanced formalism that is insensitive to <i>finite</i> stuttering, but can recognize <i>infinite</i> stuttering, a distinction which is essential for obtaining a fully abstract semantics of non-terminating processes. Among other advantages, going into real-based semantics obviates the need for the controversial representation of concurrency by interleaving, and most of the associated fairness constraints."
1985,Linear and Branching Structures in the Semantics and Logics of Reactive Systems.,"Abstract
In this presentation we reviewed the dichotomy between branching and linear views of reactive systems as they are reflected in three different approaches to the formalization of reactive systems. Hopefully we succeeded in convincing the reader that these views are distinct and represent different attitudes to the desired level of abstractness in the semantics of reactive systems. The branching view is always more detailed than the linear view, and the important question that should be left open for the user of the approach, is whether this additional detail is necessary for his application.
In this presentation we only considered the branching vs. linear dichotomy in the treatment of nondeterminism. A very similar dichotomy exists in the treatment of concurrency itself, namely between the partial order (hence acyclic graph) representation of causality and concurrency and its linearization by all the total orders consistent with this partial order. We suggest a similar study for the identification of the elements captured in the partial order which are lost in the linearization."
1985,Proving Termination of Prolog Programs.,"Abstract
The paper presented two kinds of proof rules to prove B-termination, the kind of termination obtained by the combination of backtracking and recursion as displayed by Prolog. The first kind of rule takes into account the context of the whole program and is based on a tree oriented operational semantics. The second kind is more compositional, dealing with separate procedures in a context independent way. It is based on a stream oriented semantics.
We would like to stress that such proof rules may be successfully used for defining other search strategies than the actual one used by prolog. An interesting question is to define in this way a probabilistic backtracking search strategy."
1985,The Glory of the Past.,"Abstract
An extension of propositional temporal logic that includes operators referring to a bounded past is considered. An exponential time decision procedure and a complete axiomatic system are presented. A suggested normal form leads to a syntactic classification of safety and liveness formulae. The adequacy of temporal logic to modular verification is examined. Finally we present the notion of Œ±-fairness which is proved to fully capture the behavior of probabilistic finite state programs."
1985,Checking That Finite State Concurrent Programs Satisfy Their Linear Specification.,"We present an algorithm for checking satisfiability of a linear time temporal logic formula over a finite state concurrent program. The running time of the algorithm is exponential in the size of the formula but linear in the size of the checked program. The algorithm yields also a formal proof in case the formula is valid over the program. The algorithm has four versions that check satisfiability by unrestricted, impartial, just and fair computations of the given program."
1984,Adequate Proof Principles for Invariance and Liveness Properties of Concurrent Programs.,"This paper presents proof principles for establishing invariance and liveness properties of concurrent programs. Invariance properties are established by systematically checking that they are preserved by every atomic instruction in the program. The methods for establishing liveness properties are based on well-founded assertions and are applicable to both ëjustí and ëfairí computations. These methods do not assume a decrease of the rank at each computation step. It is sufficient that there exists one process which decreases the rank when activated. Fairness then ensures that the program will eventually attain its goal. In the finite state case such proofs can be represented by diagrams. Several examples are given.
"
1984,Verification of Probabilistic Programs.,"A general method for proving properties of probabilistic programs is presented. This method generalizes the intermediate assertion method in that it extends a given assertion on the output distribution into an invariant assertion on all intermediate distributions, too. The proof method is shown to be sound and complete for programs which terminate with probability 1. A dual approach, based on the expected number of visits in each intermediate state, is also presented. All the methods are presented under the uniform framework which considers a probabilistic program as a discrete Markov process.



"
1984,Is the Interesting Part of Process Logic Uninteresting? A Translation from PL to PDL.,"With the (necessary) condition that atomic programs in process logic (PL) be binary, we present an algorithm for the translation of a PL formula p into a program $\zeta (p)$ of propositional dynamic logic (PDL) such that a finite path satisfies p if it belongs to $\zeta (p)$. This reduction has two immediate corollaries: 1) validity in this PL can be tested by testing validity of formulas in PDL; 2) all state properties expressible in this PL are expressible in PDL. The translation, however, is of nonelementary time complexity.The significance of the result to the search for natural and powerful logics of programs is discussed.



"
1984,A Linear-History Semantics for Languages for Distributed Programming.,"A denotational semantics is given for a language for distributed programming based on communication (CSP). The semantics uses both linear sequences of communications to record computations and special states, called ëexpectation setsí, characterizing potential deadlocks. For any well-formed program segment the semantics is a relation between attainable states and the communication sequences needed to attain these states. In binding two or more processes we match and merge the communication sequences assumed by each process to obtain a sequence and state of the combined process. The approach taken here is distinguished by relatively simple semantic domains and ordering.
"
1984,Fair Termination Revisited-With Delay.,"A proof method for establishing the fair termination and total correctness of both nondeterministic and concurrent programs is presented. The method calls for the extension of state by auxiliary delay variables which count down to the instant in which certain action will be scheduled. It then uses well-founded ranking to prove fair termination allowing nested fair selection and loops.
"
1984,Symmetric and Economical Solutions to the Mutual Exclusion Problem in a Distributed System.,"The mutual exclusion problem in a distributed system, in which each process has a memory of its own, into which it has exclusive write privileges but from which others may read, is reconsidered. Symmetric solutions are looked for. It is shown that, though no such solution may be deterministic, there are probabilistic solutions. Different solutions are provided for two processes, and then a solution is proposed for any number of processes. The solutions offered are amenable to a formal proof of their correctness with a small effort. The solutions are correct even against a very well informed scheduler, unlike Rabin's probabilistic solution to the mutual exclusion problem in a centralized system. Some of the solutions are correct even against an evil scheduler the knows in advance the results of the future random draws, in sharp contrast with the algorithms of Lehmann and Rabin (1981). The solutions are economical: mutual exclusion between two processes may be achieved with variables capable of holding four different values (to be compared with Peterson and Fischer's three), mutual exclusion between n processes may be achieved with variables capable of holding ten different values (to be compared with Peterson and Fischer's fourteen). All solutions have been attained by careful reasoning and not by an exhaustive computer search: they exhibit general principles of design that may be useful in solving other similar problems.
"
1984,Automatic program generation in distributed cooperative computation.,"Abstract:
Describes the use of a very high-level equational language and distributed processing in a methodology for the development of large-scale systems in natural and social sciences, or engineering. The methodology denoted as cooperative computation, consists of dividing the labour among a number of organizationally and geographically dispersed groups, with each responsible for a respective local area, and the integration of the local areas into a global system. With an equational language, the user is able to express computations in terms of equations that are commonly used in science and engineering, without the detail required in programming computers. Object programs are then produced automatically through the use of a program generator and a configurator. The methodology is discussed primarily through an example, using the model language applied in environment of Project Link."
1984,On the scope of static checking in definitional languages.,"The paper concerns the use in software development of a class of very high level languages characterized as definitional, where a specification of a program consists of assertions expressed as conditional equations. As compared to logic programming, where assertion are expressed in the form of Horn clauses, definitional languages are more amenable to efficient compilation. Also, use of equations is a natural way of expressing mathematical models in science, engineering and economics, where computer simulation of such models is often required. Finally, definitional languages are well suited for programming dataflow machines, another important building block in a Fifth Generation Project. Thus, in many applications definitional languages are preferred choice for programming new generation computers. In using definitional languages to develop programs, a user relies heavily on static analysis during the compilation stage of development, as compared to the traditional practice of relying much more extensively on dynamic analysis performed by execution of the program with test data. As this seems to be the common trend in development of all software tools for Fifth Generation Computers, the limits of static checking are investigated for definitional languages in this paper. A comprehensive approach to selecting and implementing automatic checks in the compiler is proposed. The checking methodology consists of representing the specification of a program by a directed graph and propagating various attributes throughout the entire graph. The choice of attributes and checks depends greatly on the types of errors that users are prone to make. This approach is described in the context of the MODEL language and compiler. The paper reports also on an experiment to evaluate the effectiveness of various checking methods incorporated in the compiler and on reliance of static vs dynamic methods of checking. The types of checking constructed were: syntax analysis, ambiguity in naming, completeness of definitions, data type consistency, dimensionality (corresponds to nesting of loops), ranges of dimensions (corresponds to loop terminations) and circular logic."
1984,A Hardware Implementation of the CSP Primitives and its Verification.,"Abstract
A design for a hardware interface that implements CSP-like communication primitives is presented. The design is based on a bus scheme that allows processes to ‚Äúeavesdrop‚Äù on messages not directly addressed to them. A temporal logic specification is given for the network and an outline of a verification proof is sketched."
1984,Verification of Multiprocess Probabilistic Protocols.,A new probabilistic symmetric solution to the n processes mutual exclusion problem is presented. The algorithm is verified formally using the extreme fairness approach to probabilistic verification.
1984,Temporal Verification of Carrier-Sense Local Area Network Protocols.,"We examine local area network protocols and verify the correctness of two representative algorithms using temporal logic. We introduce an interval temporal logic that allows us to make assertions of the form ‚Äúin the next k units, X holds.‚Äù This logic encodes intuitive arguments about contention protocols quite directly. We present two proofs of an Ethernet-like contention protocol, one using the interval temporal logic and one using classical temporal logic. We also verify a contention-free protocol using an invariant that seems to have wide applicability for such protocols."
1984,Now You May Compose Temporal Logic Specifications.,A compositional temporal logic proof system for the specification and verification of concurrent programs is presented. Versions of the system are developed for shared variables and communication based programming languages that include procedures.
1983,The Temporal Logic of Branching Time.,"Summary
A temporal logic is defined which contains both linear and branching operators. The underlying model is the tree of all possible computations. The following metatheoretical results are proven: 1) an exponential decision procedure for satisfiability; 2) a finite model property; 3) the completeness of an axiomatization."
1983,Propositional Dynamic Logic of Nonregular Programs.,"The borderline between decidable and undecidable propositional dynamic Logic (PDL) is sought when iterative programs represented by regular expressions are augmented with increasingly more complex recursive programs represented by nonregular languages. The results in this paper indicate that this line is extremely close to the original regular PDL. Moreover, the versions of PDL which we show to be beyond this borderline are shown to be actually very highly undecidable. The main results of the paper are: (a) The validity problem for PDL with the single additional context-free program A? (B)A?, for atomic programs A, B, defined as ?i?0Ai;B;Ai, is ?11-complete. (b) There exists a recursive (but nonregular, and hence noncontext-free) one-letter program L ? A such that the validity problem for PDL with the single additional program L is ?11-complete. Undecidability and ?11-completeness of a less restricted version of PDL than the one in (a) are proved separately using different techniques.
"
1983,Termination of Probabilistic Concurrent Program.,"The asynchronous execution behavior of several concurrent processes, which may use randomization, is studied. Viewing each process as a discrete Markov chain over the set of common execution states, we give necessary and sufficient conditions for the proc"
1983,Compilation of Nonprocedural Specifications into Computer Programs.,"Abstract:
The paper describes the compilation of a program specification, written in the very high level nonprocedural MODEL language, into an object, PL/1 or Cobol, procedural language program. Nonprocedural programming languages are descriptive and devoid of procedural controls. They are therefore easier to use and require less programming skills than procedural languages. The MODEL language is briefly presented and illustrated followed by a description of the compilation process. An important early phase in the compilation is the representation of the specification by a dependency graph, denoted as array graph, which expresses the data flow interdependencies between statements. Two classes of algorithms which utilize this graph are next described. The first class checks various completeness, nonambiguity, and consistency aspects of the specification. Upon detecting any problems, the system attempts some automatic correcting measures which are reported to the user, or alternately, when no corrections appear as reasonable, it reports the error and solicits a modification from the user. The second class of algorithms produces an intermediate design of an object program in a language independent form. Finally, PL/1 or Cobol code is generated."
1983,Solutions to Problem No.2.,n/a
1983,Symmetric and Economical Solutions to the Mutual Exclusion Problem in a Distributed System (Extended Abstract).,"Abstract
The mutual exclusion problem in a distributed system, in which each process has a memory of its own, into which it has exclusive write privileges but from which others may read, is reconsidered. Symmetric solutions are looked for. It is shown that, though no such solution may be deterministic, there are probabilistic solutions. Different solutions are provided for two processes, and then a solution is proposed for any number of processes. The solutions offered are amenable to a formal proof of their correctness with a small effort. The solutions are correct even against a very well informed scheduler, unlike Rabin's probabilistic solution to the mutual exclusion problem in a centralized system. Some of the solutions are correct even against an evil scheduler that knows in advance the results of the future random draws, in sharp contrast with the algorithms of [LR]. The solutions are economical: mutual exclusion between two processes may be achieved with variables capable of holding four different values (to be compared with Peterson and Fischer's three), mutual exclusion between n processes may be achieved with variables capable of holding ten different values (to be compared with Peterson and Fischer's fourteen). All solutions have been attained by careful reasoning and not by an exhaustive computer search, they exhibit general principles of design that may be useful in solving other similar problems."
1983,Proving Precedence Properties: The Temporal Way.,"Abstract
The paper explores the three important classes of temporal properties of concurrent programs: invariance, liveness and precedence. It presents the first methodological approach to the precedence properties, while providing a review of the invariance and liveness properties. The approach is based on the unless operator \mathfrak{A}, which is a weak version of the until operator U. For each class of properties, we present a single complete proof principle."
1983,There Exit Decidable Context Free Propositional Dynamic Logics.,"Abstract
It is shown that PDL remains decidable when we allow as programs regular expressions over a finite alphabet as well as over the single context free program A‚Ä°B‚Ä° = {AiBi | i ‚â• 0}. The decision algorithm constructs a finite push-down model for all satisfiable PDL RG(A‚Ä°B‚Ä°) formulas. Generalization to additional context free programs whose addition does not destroy decidability is discussed."
1983,How to Cook a Temporal Proof System for Your Pet Language.,"An abstract temporal proof system is presented whose program-dependent part has a high-level interface with the programming language actually studied. Given a new language, it is sufficient to deline the interface notions of atomic transitions, justice, and fairness in order to obtain a full temporal proof system for this language. This construction is particularly useful for the analysis of concurrent systems. We illustrate the construction on the shared-variable model and on CSP. The generic proof system is shown to be relatively complete with respect to pure first-order temporal logic."
1983,On the Extremely Fair Treatment of Probabilistic Algorithms.,A proof system based on linear temporal logic for the qualitative verification of concurrent probabilistic programs is proposed. The concept of extreme fairness is introduced as an approximation to the notion of probabilistic executions. The proof system proposed is shown to be relatively complete with respect to validity over all extremely fair computations. The proof methodology is demonstrated by proving correctness of a new probabilistic algorithm for solving the mutual exclusion problem ([CLP]).
1982,"Deterministic Propositional Dynamic Logic: Finite Models, Complexity, and Completeness.","Let p be a formula in deterministic propositional dynamic logic. A decision procedure for the satisfiability of p is given along with a construction of a finite model for every satisfiable p. The decision procedure runs in deterministic time 2cn and the size of the model is bounded by n2 ∑ 4n, where n is the length of p. Finally, a complete axiomatization for deterministic propositional dynamic logic is given, based on the Segerberg axoms for propositional dynamic logic.
"
1982,Termination of Probabilistic Concurrent Programs.,"The asynchronous execution behavior of several concurrent processes, which may use randomization, is studied. Viewing each process as a discrete Markov chain over the set of common execution states, we give necessary and sufficient conditions for the processes to converge almost surely to a given set of goal states, under any fair, but otherwise arbitrary schedule, provided that the state space is finite. (These conditions can be checked mechanically.) An interesting feature of the proof method is that it depends only on the topology of the transitions and not on the actual values of the probabilities. We also show that in our model synchronization protocols that use randomization are in certain cases no more powerful than deterministic protocols. This is demonstrated by (a) Proving lower bounds on the size of a shared variable necessary to ensure mutual exlusion and lockout-free behavior of the protocol; and (b) Showing that no fully symmetric 'randomized' protocol can ensure mutual exclusion and freedom from lockout."
1982,Is the Interesting Part of Process Logic Uninteresting - A Translation from PL to PDL.,"With the (necessary) condition that atomic programs in PL be binary, we present an algorithm for the translation of a PL formula X into a PDL program œÑ (X) such that a finite path satisfies X iff it belongs to œÑ (X). This reduction has two immediate corollaries: 1) validity in this PL can be tested by testing validity of formulas in PDL; 2) all finite-path program properties expressible in this PL are expressible in PDL.The translation, however, seems to be of non-elementary time complexity. The significance of the result to the search for natural and powerful logics of programs is discussed."
1981,Automatic Programming of Finite State Linear Programs.,"Finite State Linear Programs (FSLP) are introduced to model simple data processing applications. Essentially these are finite automata with the added capability of performing linear operations on a set of registers and the input. Algorithmic constructions are given to test equivalence of FSLP programs, and to minimize the number of states and registers. Linear algebraic methods are used for the register minimization procedure (and its correctness proof).
"
1981,The Temporal Semantics of Concurrent Programs.,"The formalism of Temporal Logic is suggested as an appropriate tool for formalizing the semantics of concurrent programs. A simple model of concurrent program is presented in which n processors are executing concurrent n disjoint programs under a shared memory environment. The semantics of such a program specifies the class of state sequences which are admissible as proper execution sequences under the program.
The two main criteria which are required are
1.
(a) Each state is obtained from its predecessor in the sequence by exactly one processor performing an atomic instruction in its process.

2.
(b) Fair Scheduling: no processor which is infinitely often enabled will be indefinitely delayed.


The basic elements of Temporal Logic are introduced in a particular logic framework DX. The usefulness of Temporal Logic notation in describing properties of concurrent programs is demonstrated. A construction is then given for assigning to a program P a temporal formula W(P) which is true on all proper execution sequences of P. In order to prove that a program P possesses a property R1, one has only to prove the implications W(P)?R.

An example of such proof is given. It is then demonstrated that specification of the Temporal character of the program's behavior is absolutely essential for the unambiguous understanding of the meaning of programming constructs."
1981,Propositional Dynamic Logic of Context-Free Programs.,"Abstract:
The borderline between decidable and undecidable Propositional Dynamic Logic (PDL) is sought when iterative programs represented by regular expressions are augmented with increasingly more complex recursive programs represented by context-free languages. The results in this paper and its companion [HPS] indicate that this line is extremely close to the original regular PDL. The main result of the present paper is: The validity problem for PDL with additional programs Œ±Œî(Œ≤)Œ≥Œî for regular Œ±, Œ≤ and Œ≥, defined as UiŒ±i; Œ≤; Œ≥i, is Œ†11-complete. One of the results of [HPS] shows that the single program AŒî(B) AŒî for atomic A and B is actually sufficient for obtaining Œ†11- completeness. However, the proofs of this paper use different techniques which seem to be worthwhile in their own right."
1981,Finite Models for Deterministic Propositional Dynamic Logic.,n/a
1981,"Impartiality, Justice and Fairness: The Ethics of Concurrent Termination.","Abstract
The method of well founded structures for proving termination of programs is extended to concurrent programs. The more complicated case is when a program terminates only for fair executions. Different versions of fairness are introduced: Impartiality, Fairness and Justice, and Methods for proving their termination are presented."
1981,Realizing an Equational Specification.,n/a
1981,Further Results on Propositional Dynamic Logic of Nonregular Programs.,"Abstract
The main results of this paper are:
(a)
The validity problem for PDL with the single additional context-free program AŒî(B)AŒî, for atomic programs A,B, defined as \mathop \cup \limits_{i \geqslant o} Ai;B;Ai, is ‚àè 1 1 -complete.
 (b)
There exists a recursive (but nonregular) one-letter program L\subseteqA* such that the validity problem for PDL with the single additional program L is ‚àè 1 1 -complete.
 "
1981,Verification of Concurrent Programs: Temporal Proof Principles.,"Abstract
In this paper, the second of a series on the application of temporal logic to concurrent programs, we present proof methods for establishing invariance (safety) and eventuality (liveness) properties.
The proof principle for establishing invariance properties is based on computational induction, and is a generalization of the inductive assertion method. For a restricted class of concurrent programs we present an algorithm for the automatic derivation of invariant assertions.
In order to establish eventuality properties we present several proof principles that translate the structure of the program into basic temporal statements about its behavior. These principles can be viewed as providing the temporal semantics of the program. The basic statements thus derived are then combined into temporal proofs for the establishment of eventuality properties. This method generalizes the intermittent assertion method.
The proof principles are amply illustrated by examples."
1981,The Temporal Logic of Branching Time.,"A temporal language and system are presented which are based on branching time structure. By the introduction of symmetrically dual sets of temporal operators, it is possible to discuss properties which hold either along one path or along all paths. Consequently it is possible to express in this system all the properties that were previously expressible in linear time or branching time systems. We present an exponential decision procedure for satisfiability in the language based on tableaux methods, and a complete deduction system. As associated temporal semantics is illustrated for both structured and graph representation of programs."
1980,A Linear History Semantics for Distributed Languages (Extended Abstract).,"Abstract:
A denotational semantics is given for a distributed language based on communication (CSP). The semantics uses linear sequences of communications to record computations; for any well formed program segment the semantics is a relation between attainable states and the communication sequences needed to attain these states. In binding two or more processes we match and merge the communication sequences assumed by each process to obtain a sequence and State of the combined process. The approach taken here is distinguished by relatively simple semantic domains and ordering."
1980,Synchronous Schemes and Their Decision Problems.,"A class of schemes called synchronous schemes is defined. A synchronous scheme can have several variables, but all the active ones are required to keep a synchronized rate of computation as measured by the height of their respective Herbrand values. A ""reset"" statement, which causes all the variables to restart a new computation, is admitted. It is shown that equivalence, convergence, and other properties are decidable for schemes in this class. The class of synchronous schemes contains, as special cases, the known decidable classes of Ianov schemes, one-variable schemes with resets, and progressive schemes."
1980,On the Temporal Basis of Fairness.,"The use of the temporal logic formalism for program reasoning is reviewed. Several aspects of responsiveness and fairness are analyzed, leading to the need for an additional temporal operator: the 'until' operator -U. Some general questions involving the 'until' operator are then discussed. It is shown that with the addition of this operator the temporal language becomes expressively complete. Then, two deductive systems DX and DUX are proved to be complete for the languages without and with the new operator respectively."
1979,Use of a Nonprocedural Specification Language and Associated Program Generator in Software Development.,"The Model II language and the associated program generator are used to explain and illustrate the use of very high level nonprocedural languages for computer programming. The effect of a very high level language is obtained in Model II through the elimination of procedural and control facilities that exist in high level programming languages such as PL/I or Cobol. In particular, the statements may be given in any order and there are no control constructs such as input/output, iterations, and memory allocation. The task of ordering the statements for execution and providing control statements is performed by the automatic program generator. The specification of a program is therefore much shorter (approximately one-fifth) than the equivalent high level procedural language program. Most important, a user need not regard the task of specifying a program as defining a process but rather as describing data and relations. This point of view greatly reduces the computer programming proficiency required of a user. The paper focuses on an example of the use of the language in business data processing, its advantages, and its novelty. It only briefly reviews the methodology incorporated in the existing program generator, a detailed description of which may be found in the references."
1979,The Modal Logic of Programs.,"Abstract
We explore the general framework of Modal Logic and its applicability to program reasoning. We relate the basic concepts of Modal Logic to the programming environment: the concept of ""world"" corresponds to a program state, and the concept of ""accessibility relation"" corresponds to the relation of derivability between states during execution. Thus we adopt the Temporal interpretation of Modal Logic. The variety of program properties expressible within the modal formalism is demonstrated.
The first axiomatic system studied, the sometime system, is adequate for proving total correctness and ‚Äòeventuality‚Äô properties. However, it is inadequate for proving invariance properties. The stronger nexttime system obtained by adding the next operator is shown to be adequate for invariances as well."
1979,The Temporal Semantics of Concurrent Programs.,"Abstract
The formalism of Temporal logic is suggested as an appropriate tool for formalizing the semantics of concurrent programs. A simple model of concurrent program is presented in which n processors are executing concurrently n disjoint programs under a shared memory environment. The semantics of such a program specifies the class of state sequences which are admissible as proper execution sequences under the program.
The two main criteria which are required are
a) Each state is obtained from its predecessor in the sequence by exactly one processor performing an atomic instruction in its process.
b) Fair Scheduling: No processor which is infinitely often enabled will be indefinitely delayed.
The basic elements of Temporal Logic are introduced in a particular logic framework DX. The usefulness of Temporal Logic notation in describing properties of concurrent programs is demonstrated. A construction is then given for assigning to a program P a temporal formula W(P) which is true on all proper execution sequences of P. In order to prove that a program P possesses a property R, one has only to prove the implication W(P)‚äÉR.
An example of such proof is given. It is then demonstrated that specification of the Temporal character of the program's behavior is absolutely essential for the unabiguous undestanding of the meaning of programming constructs."
1978,A Proof Method for Cyclic Programs.,"We consider the specification and verification of cyclic (sequential and concurrent) programs. The input-output based concept of correctness traditionally applied to functional programs is replaced by another, based on the concept of eventual behaviour. Various types of eventual behaviour are introduced. In the case of concurrency, the introduction of interface-predicates reduces the proof complexity and achieves greater readability. All specifications use explicitly the auxiliary variables of a location counter ? and elapsing time t.
"
1977,Backtracking in Recursive Computations.,"Summary
A mathematical (denotational) semantics is constructed for a formalism of recursive equations with the Alternative operator. This formalism enables the combination of recursion and backtracking. The semantics is defined by applying fixpoint theory to set valued functions. We introduce the notion of strategy to produce subsets of the result. Two implementations are suggested using an auxiliary stack, that trade off recomputation time with space in the auxiliary stack. The concept of a sub-fixpoint is introduced, and the implementations are shown to be incomplete even w.r.t. sub-fixpoint values. One special strategy, the leftmost strategy, which stems from problems such as pattern matching or parsing, is discussed."
1977,A Direct Algorithm for Checking Equivalence of LL(k) Grammars.,"We deal with the problem of testing equivalence of two LL(k) grammars. The problem had been shown to be decidable for general k by Rosenkrantz and Stearns [2], who solved it by reduction into an equivalence problem for special DPDA's. In a paper by Korenjak and Hopcroft [1] the equivalence problem for LL(1) grammars is solved by a branching algorithm operating directly on the grammars. Our work presents a direct branching algorithm for the general LL(k) grammars equivalence problem.
"
1977,The Temporal Logic of Programs.,"Abstract:
A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two formal systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb, and is particularly suitable for reasoning about concurrent programs."
1977,Simple Programs and Their Decision Problems.,n/a
1977,A Complete Axiomatic System for Proving Deductions about Recursive Programs.,"Denoting a version of Hoare's system for proving partial correctness of recursive programs by H, we present an extension D which may be thought of as H &ugr; {@@@@,@@@@,@@@@,@@@@} &ugr; H-1, including the rules of H, four special purpose rules and inverse rules to those of Hoare. D is shown to be a complete system (in Cook's sense) for proving deductions of the form &sgr;1,....&sgr;n @@@@ &sgr; over a language, the wff's of which are assertions in some assertion language L and partial correctness specifications of the form p(&agr;)q. All valid formulae of L are taken as axioms of D. It is shown that D is sufficient for proving partial correctness, total correctness and program equivalence as well as other important properties of programs, the proofs of which are impossible in H. The entire presentation is worked out in the framework of nondeterministic programs employing iteration and mutually recursive procedures."
1974,Axiomatic Approach to Total Correctness of Programs.,"Summary
We present here an axiomatic approach which enables one to prove by formal methods that his program is ‚Äútotally correct‚Äù (i.e., it terminates and is logically correct‚Äîdoes what it is supposed to do). The approach is similar to Hoare's approach [3] for proving that a program is ‚Äúpartially correct‚Äù (i.e., that whenever it terminates it produces correct results). Our extension to Hoare's method lies in the possibility of proving both correctness and termination by one unified formalism. One can choose to prove total correctness by a single step, or by incremental proof steps, each step establishing more properties of the program."
1973,Decidable Properties of Monadic Functional Schemas.,"A class of (monadic) functional schemas which properly includes ‚ÄúIanov‚Äù flowchart schemas is defined. It is shown that the termination, divergence, and freedom problems for functional schemas are decidable. Although it is possible to translate a large class of non-free functional schemas into equivalent free functional schemas, it is shown that in general this cannot be done. It is also shown that the equivalence problem for free functional schemas is decidable. Most of the results are obtained from well-known results in formal languages and automata theory."
1972,Permutation Graphs and Transitive Graphs.,"A graph G with vertex set N = {1, 2, Ö, n} is called a permutation graph there exists a permutation P on N such that for I, j in N if only If I and j are joined by an edge in G. A structural relationship is established between permutation graphs and transitive graphs. An algorithm for determining whether a given graph is a permutation graph is given. Efficient algorithms for finding a maximum size clique and a minimum coloration of transitive graphs are presented. These algorithms are then shown to be applicable in solving problems in memory allocation and circuit layout."
1971,Marked Directed Graphs.,n/a
1970,Formalization of Properties of Functional Programs.,"The problems of convergence, correctness, and equivalence of computer programs can be formulated by means of the satisfiability or validity of certain first-order formulas. An algorithm is presented for constructing such formulas for functional programs, i.e. programs defined by LISP-like conditional recursive expressions."
1969,Formalization of Properties of Recursively Defined Functions.,"This paper is concerned with the relationship between the convergence, correctness and equivalence of recursively defined functions and the satisfiability (or unsatisfiability) of certain first-order formulas."
